<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=../eventarray/ rel=prev><link href=../intervalarray/ rel=next><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.16"><title>AnalogSignalArray - nelpy</title><link rel=stylesheet href=../../../assets/stylesheets/main.7e37652d.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../assets/_mkdocstrings.css><link rel=stylesheet href=../../../stylesheets/extra.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#analogsignalarray class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title=nelpy class="md-header__button md-logo" aria-label=nelpy data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> nelpy </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> AnalogSignalArray </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=light data-md-color-primary=custom data-md-color-accent=custom aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=blue aria-label="Switch to system preference" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to system preference" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/nelpy/nelpy title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> nelpy/nelpy </div> </a> </div> </nav> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> Home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../eventarray/ class=md-tabs__link> API Reference </a> </li> <li class=md-tabs__item> <a href=../../../tutorials/GettingStarted/ class=md-tabs__link> Tutorials </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title=nelpy class="md-nav__button md-logo" aria-label=nelpy data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> nelpy </label> <div class=md-nav__source> <a href=https://github.com/nelpy/nelpy title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg> </div> <div class=md-source__repository> nelpy/nelpy </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> API Reference </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> API Reference </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../eventarray/ class=md-nav__link> <span class=md-ellipsis> EventArray </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> AnalogSignalArray </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> AnalogSignalArray </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray class=md-nav__link> <span class=md-ellipsis> _analogsignalarray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.AbscissaSlicer class=md-nav__link> <span class=md-ellipsis> AbscissaSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.AnalogSignalArray class=md-nav__link> <span class=md-ellipsis> AnalogSignalArray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.DataSlicer class=md-nav__link> <span class=md-ellipsis> DataSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.IMUSensorArray class=md-nav__link> <span class=md-ellipsis> IMUSensorArray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.IntervalSignalSlicer class=md-nav__link> <span class=md-ellipsis> IntervalSignalSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.MinimalExampleArray class=md-nav__link> <span class=md-ellipsis> MinimalExampleArray </span> </a> <nav class=md-nav aria-label=MinimalExampleArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.MinimalExampleArray.custom_func class=md-nav__link> <span class=md-ellipsis> custom_func </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray class=md-nav__link> <span class=md-ellipsis> PositionArray </span> </a> <nav class=md-nav aria-label=PositionArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray.x class=md-nav__link> <span class=md-ellipsis> x </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray.y class=md-nav__link> <span class=md-ellipsis> y </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray class=md-nav__link> <span class=md-ellipsis> RegularlySampledAnalogSignalArray </span> </a> <nav class=md-nav aria-label=RegularlySampledAnalogSignalArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abs class=md-nav__link> <span class=md-ellipsis> abs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abscissa_vals class=md-nav__link> <span class=md-ellipsis> abscissa_vals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.angle class=md-nav__link> <span class=md-ellipsis> angle </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.base_unit class=md-nav__link> <span class=md-ellipsis> base_unit </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.data class=md-nav__link> <span class=md-ellipsis> data </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.domain class=md-nav__link> <span class=md-ellipsis> domain </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.fs class=md-nav__link> <span class=md-ellipsis> fs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.imag class=md-nav__link> <span class=md-ellipsis> imag </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.iscomplex class=md-nav__link> <span class=md-ellipsis> iscomplex </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isempty class=md-nav__link> <span class=md-ellipsis> isempty </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isreal class=md-nav__link> <span class=md-ellipsis> isreal </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.labels class=md-nav__link> <span class=md-ellipsis> labels </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.lengths class=md-nav__link> <span class=md-ellipsis> lengths </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_bytes class=md-nav__link> <span class=md-ellipsis> n_bytes </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_intervals class=md-nav__link> <span class=md-ellipsis> n_intervals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_samples class=md-nav__link> <span class=md-ellipsis> n_samples </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_signals class=md-nav__link> <span class=md-ellipsis> n_signals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.range class=md-nav__link> <span class=md-ellipsis> range </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.real class=md-nav__link> <span class=md-ellipsis> real </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.signals class=md-nav__link> <span class=md-ellipsis> signals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.step class=md-nav__link> <span class=md-ellipsis> step </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.support class=md-nav__link> <span class=md-ellipsis> support </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.add_signal class=md-nav__link> <span class=md-ellipsis> add_signal </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.asarray class=md-nav__link> <span class=md-ellipsis> asarray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.center class=md-nav__link> <span class=md-ellipsis> center </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.clip class=md-nav__link> <span class=md-ellipsis> clip </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.copy class=md-nav__link> <span class=md-ellipsis> copy </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.ddt class=md-nav__link> <span class=md-ellipsis> ddt </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.downsample class=md-nav__link> <span class=md-ellipsis> downsample </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.empty class=md-nav__link> <span class=md-ellipsis> empty </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.join class=md-nav__link> <span class=md-ellipsis> join </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.max class=md-nav__link> <span class=md-ellipsis> max </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.mean class=md-nav__link> <span class=md-ellipsis> mean </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.median class=md-nav__link> <span class=md-ellipsis> median </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.min class=md-nav__link> <span class=md-ellipsis> min </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.normalize class=md-nav__link> <span class=md-ellipsis> normalize </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.partition class=md-nav__link> <span class=md-ellipsis> partition </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.simplify class=md-nav__link> <span class=md-ellipsis> simplify </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.smooth class=md-nav__link> <span class=md-ellipsis> smooth </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.standardize class=md-nav__link> <span class=md-ellipsis> standardize </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.std class=md-nav__link> <span class=md-ellipsis> std </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.subsample class=md-nav__link> <span class=md-ellipsis> subsample </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.trim class=md-nav__link> <span class=md-ellipsis> trim </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.unwrap class=md-nav__link> <span class=md-ellipsis> unwrap </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.wrap class=md-nav__link> <span class=md-ellipsis> wrap </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.zscore class=md-nav__link> <span class=md-ellipsis> zscore </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.legacyASAkwargs class=md-nav__link> <span class=md-ellipsis> legacyASAkwargs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.rsasa_init_wrapper class=md-nav__link> <span class=md-ellipsis> rsasa_init_wrapper </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../intervalarray/ class=md-nav__link> <span class=md-ellipsis> IntervalArray </span> </a> </li> <li class=md-nav__item> <a href=../valeventarray/ class=md-nav__link> <span class=md-ellipsis> ValeventArray </span> </a> </li> <li class=md-nav__item> <a href=../coordinates/ class=md-nav__link> <span class=md-ellipsis> Coordinates </span> </a> </li> <li class=md-nav__item> <a href=../../analysis/ class=md-nav__link> <span class=md-ellipsis> Analysis </span> </a> </li> <li class=md-nav__item> <a href=../../auxiliary/ class=md-nav__link> <span class=md-ellipsis> Auxiliary </span> </a> </li> <li class=md-nav__item> <a href=../../decoding/ class=md-nav__link> <span class=md-ellipsis> Decoding </span> </a> </li> <li class=md-nav__item> <a href=../../plotting/ class=md-nav__link> <span class=md-ellipsis> Plotting </span> </a> </li> <li class=md-nav__item> <a href=../../utils/ class=md-nav__link> <span class=md-ellipsis> Utilities </span> </a> </li> <li class=md-nav__item> <a href=../../estimators/ class=md-nav__link> <span class=md-ellipsis> Estimators </span> </a> </li> <li class=md-nav__item> <a href=../../filtering/ class=md-nav__link> <span class=md-ellipsis> Filtering </span> </a> </li> <li class=md-nav__item> <a href=../../preprocessing/ class=md-nav__link> <span class=md-ellipsis> Preprocessing </span> </a> </li> <li class=md-nav__item> <a href=../../hmmutils/ class=md-nav__link> <span class=md-ellipsis> HMM Utils </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Tutorials </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Tutorials </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../tutorials/GettingStarted/ class=md-nav__link> <span class=md-ellipsis> Getting Started </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/AnalogSignalArrayTutorial/ class=md-nav__link> <span class=md-ellipsis> AnalogSignalArray Tutorial </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/EpochArrayTutorial/ class=md-nav__link> <span class=md-ellipsis> EpochArray Tutorial </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/LinearTrackDemo/ class=md-nav__link> <span class=md-ellipsis> Linear Track Demo </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/SpikeTrainSmoothing/ class=md-nav__link> <span class=md-ellipsis> SpikeTrain Smoothing </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/plotting/ class=md-nav__link> <span class=md-ellipsis> plotting </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/WMazeDemo/ class=md-nav__link> <span class=md-ellipsis> WMaze Demo </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/BackyardBrainsEEG/ class=md-nav__link> <span class=md-ellipsis> Backyard Brains EEG </span> </a> </li> <li class=md-nav__item> <a href=../../../tutorials/develop/ class=md-nav__link> <span class=md-ellipsis> develop </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray class=md-nav__link> <span class=md-ellipsis> _analogsignalarray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.AbscissaSlicer class=md-nav__link> <span class=md-ellipsis> AbscissaSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.AnalogSignalArray class=md-nav__link> <span class=md-ellipsis> AnalogSignalArray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.DataSlicer class=md-nav__link> <span class=md-ellipsis> DataSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.IMUSensorArray class=md-nav__link> <span class=md-ellipsis> IMUSensorArray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.IntervalSignalSlicer class=md-nav__link> <span class=md-ellipsis> IntervalSignalSlicer </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.MinimalExampleArray class=md-nav__link> <span class=md-ellipsis> MinimalExampleArray </span> </a> <nav class=md-nav aria-label=MinimalExampleArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.MinimalExampleArray.custom_func class=md-nav__link> <span class=md-ellipsis> custom_func </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray class=md-nav__link> <span class=md-ellipsis> PositionArray </span> </a> <nav class=md-nav aria-label=PositionArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray.x class=md-nav__link> <span class=md-ellipsis> x </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.PositionArray.y class=md-nav__link> <span class=md-ellipsis> y </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray class=md-nav__link> <span class=md-ellipsis> RegularlySampledAnalogSignalArray </span> </a> <nav class=md-nav aria-label=RegularlySampledAnalogSignalArray> <ul class=md-nav__list> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abs class=md-nav__link> <span class=md-ellipsis> abs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abscissa_vals class=md-nav__link> <span class=md-ellipsis> abscissa_vals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.angle class=md-nav__link> <span class=md-ellipsis> angle </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.base_unit class=md-nav__link> <span class=md-ellipsis> base_unit </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.data class=md-nav__link> <span class=md-ellipsis> data </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.domain class=md-nav__link> <span class=md-ellipsis> domain </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.fs class=md-nav__link> <span class=md-ellipsis> fs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.imag class=md-nav__link> <span class=md-ellipsis> imag </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.iscomplex class=md-nav__link> <span class=md-ellipsis> iscomplex </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isempty class=md-nav__link> <span class=md-ellipsis> isempty </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isreal class=md-nav__link> <span class=md-ellipsis> isreal </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.labels class=md-nav__link> <span class=md-ellipsis> labels </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.lengths class=md-nav__link> <span class=md-ellipsis> lengths </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_bytes class=md-nav__link> <span class=md-ellipsis> n_bytes </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_intervals class=md-nav__link> <span class=md-ellipsis> n_intervals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_samples class=md-nav__link> <span class=md-ellipsis> n_samples </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_signals class=md-nav__link> <span class=md-ellipsis> n_signals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.range class=md-nav__link> <span class=md-ellipsis> range </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.real class=md-nav__link> <span class=md-ellipsis> real </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.signals class=md-nav__link> <span class=md-ellipsis> signals </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.step class=md-nav__link> <span class=md-ellipsis> step </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.support class=md-nav__link> <span class=md-ellipsis> support </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.add_signal class=md-nav__link> <span class=md-ellipsis> add_signal </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.asarray class=md-nav__link> <span class=md-ellipsis> asarray </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.center class=md-nav__link> <span class=md-ellipsis> center </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.clip class=md-nav__link> <span class=md-ellipsis> clip </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.copy class=md-nav__link> <span class=md-ellipsis> copy </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.ddt class=md-nav__link> <span class=md-ellipsis> ddt </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.downsample class=md-nav__link> <span class=md-ellipsis> downsample </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.empty class=md-nav__link> <span class=md-ellipsis> empty </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.join class=md-nav__link> <span class=md-ellipsis> join </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.max class=md-nav__link> <span class=md-ellipsis> max </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.mean class=md-nav__link> <span class=md-ellipsis> mean </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.median class=md-nav__link> <span class=md-ellipsis> median </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.min class=md-nav__link> <span class=md-ellipsis> min </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.normalize class=md-nav__link> <span class=md-ellipsis> normalize </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.partition class=md-nav__link> <span class=md-ellipsis> partition </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.simplify class=md-nav__link> <span class=md-ellipsis> simplify </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.smooth class=md-nav__link> <span class=md-ellipsis> smooth </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.standardize class=md-nav__link> <span class=md-ellipsis> standardize </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.std class=md-nav__link> <span class=md-ellipsis> std </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.subsample class=md-nav__link> <span class=md-ellipsis> subsample </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.trim class=md-nav__link> <span class=md-ellipsis> trim </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.unwrap class=md-nav__link> <span class=md-ellipsis> unwrap </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.wrap class=md-nav__link> <span class=md-ellipsis> wrap </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.zscore class=md-nav__link> <span class=md-ellipsis> zscore </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.legacyASAkwargs class=md-nav__link> <span class=md-ellipsis> legacyASAkwargs </span> </a> </li> <li class=md-nav__item> <a href=#nelpy.core._analogsignalarray.rsasa_init_wrapper class=md-nav__link> <span class=md-ellipsis> rsasa_init_wrapper </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/nelpy/nelpy/edit/master/docs/reference/core/analogsignalarray.md title="Edit this page" class="md-content__button md-icon" rel=edit> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg> </a> <a href=https://github.com/nelpy/nelpy/raw/master/docs/reference/core/analogsignalarray.md title="View source of this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg> </a> <h1 id=analogsignalarray>AnalogSignalArray</h1> <div class="doc doc-object doc-module"> <a id=nelpy.core._analogsignalarray></a> <div class="doc doc-contents first"> <details class=regularlysampledanalogsignalarray open> <summary>RegularlySampledAnalogSignalArray</summary> <p>Core object definition and implementation for RegularlySampledAnalogSignalArray.</p> </details> <div class="doc doc-children"> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.AbscissaSlicer class="doc doc-heading"> <code>AbscissaSlicer</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><span title=object>object</span></code></p> <p>Slicer for extracting abscissa values from analog signal arrays by interval.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>parent</code> </td> <td> <code><span title=object>object</span></code> </td> <td> <div class=doc-md-description> <p>The parent object to slice.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>176</span>
<span class=normal>177</span>
<span class=normal>178</span>
<span class=normal>179</span>
<span class=normal>180</span>
<span class=normal>181</span>
<span class=normal>182</span>
<span class=normal>183</span>
<span class=normal>184</span>
<span class=normal>185</span>
<span class=normal>186</span>
<span class=normal>187</span>
<span class=normal>188</span>
<span class=normal>189</span>
<span class=normal>190</span>
<span class=normal>191</span>
<span class=normal>192</span>
<span class=normal>193</span>
<span class=normal>194</span>
<span class=normal>195</span>
<span class=normal>196</span>
<span class=normal>197</span>
<span class=normal>198</span>
<span class=normal>199</span>
<span class=normal>200</span>
<span class=normal>201</span>
<span class=normal>202</span>
<span class=normal>203</span>
<span class=normal>204</span>
<span class=normal>205</span>
<span class=normal>206</span>
<span class=normal>207</span>
<span class=normal>208</span>
<span class=normal>209</span>
<span class=normal>210</span>
<span class=normal>211</span>
<span class=normal>212</span>
<span class=normal>213</span>
<span class=normal>214</span>
<span class=normal>215</span>
<span class=normal>216</span>
<span class=normal>217</span>
<span class=normal>218</span>
<span class=normal>219</span>
<span class=normal>220</span>
<span class=normal>221</span>
<span class=normal>222</span>
<span class=normal>223</span>
<span class=normal>224</span>
<span class=normal>225</span>
<span class=normal>226</span>
<span class=normal>227</span>
<span class=normal>228</span>
<span class=normal>229</span>
<span class=normal>230</span>
<span class=normal>231</span>
<span class=normal>232</span>
<span class=normal>233</span>
<span class=normal>234</span>
<span class=normal>235</span>
<span class=normal>236</span>
<span class=normal>237</span>
<span class=normal>238</span>
<span class=normal>239</span>
<span class=normal>240</span>
<span class=normal>241</span>
<span class=normal>242</span>
<span class=normal>243</span>
<span class=normal>244</span>
<span class=normal>245</span>
<span class=normal>246</span>
<span class=normal>247</span>
<span class=normal>248</span>
<span class=normal>249</span>
<span class=normal>250</span>
<span class=normal>251</span>
<span class=normal>252</span>
<span class=normal>253</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>AbscissaSlicer</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Slicer for extracting abscissa values from analog signal arrays by interval.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    parent : object</span>
<span class=sd>        The parent object to slice.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>parent</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Initialize the AbscissaSlicer.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        parent : object</span>
<span class=sd>            The parent object to slice.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>parent</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_abscissa_vals_generator</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>interval_indices</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Generator for abscissa values by interval.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interval_indices : list or array-like</span>
<span class=sd>            Indices of intervals.</span>

<span class=sd>        Yields</span>
<span class=sd>        ------</span>
<span class=sd>        abscissa_vals : np.ndarray</span>
<span class=sd>            Abscissa values for each interval.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>interval_indices</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>yield</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
            <span class=k>except</span> <span class=ne>StopIteration</span><span class=p>:</span>
                <span class=k>return</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
        <span class=n>intervalslice</span><span class=p>,</span> <span class=n>signalslice</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_intervalsignalslicer</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>

        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>[</span><span class=n>intervalslice</span><span class=p>])</span>

        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>:</span>
            <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=o>=</span> <span class=n>interval_indices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals_generator</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>plot_generator</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>interval_indices</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>yield</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
            <span class=k>except</span> <span class=ne>StopIteration</span><span class=p>:</span>
                <span class=k>return</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__next__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_index</span>

        <span class=k>if</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>n_intervals</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>StopIteration</span>

        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=n>interval_indices</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
        <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=o>=</span> <span class=n>interval_indices</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.AnalogSignalArray class="doc doc-heading"> <code>AnalogSignalArray</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code></p> <p>Array of continuous analog signals with regular sampling rates.</p> <p>This class extends RegularlySampledAnalogSignalArray with additional aliases and legacy support for backward compatibility.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Array of signal data with shape (n_signals, n_samples). Default is empty array.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>abscissa_vals</code> </td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Time values corresponding to samples, with shape (n_samples,). Default is None.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency in Hz. Default is None.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>step</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling interval in seconds. Default is None.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>merge_sample_gap</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Maximum gap between samples to merge intervals (seconds). Default is 0.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>support</code> </td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.IntervalArray>IntervalArray</a></code> </td> <td> <div class=doc-md-description> <p>Time intervals where signal is defined. Default is None.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>in_core</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether to keep data in core memory. Default is True.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>labels</code> </td> <td> <code><span title=array>array</span> - <span title=like>like</span></code> </td> <td> <div class=doc-md-description> <p>Labels for each signal. Default is None.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>empty</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, creates empty array. Default is False.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>abscissa</code> </td> <td> <code><a class="autorefs autorefs-internal" href=../coordinates/#nelpy.core._coordinates.AnalogSignalArrayAbscissa>AnalogSignalArrayAbscissa</a></code> </td> <td> <div class=doc-md-description> <p>Abscissa object. Default is created from support.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>ordinate</code> </td> <td> <code><a class="autorefs autorefs-internal" href=../coordinates/#nelpy.core._coordinates.AnalogSignalArrayOrdinate>AnalogSignalArrayOrdinate</a></code> </td> <td> <div class=doc-md-description> <p>Ordinate object. Default is empty.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <details class=aliases open> <summary>Aliases</summary> <p>time : abscissa_vals Alias for time values.</p> <p>n_epochs : n_intervals Alias for number of intervals. ydata : data Legacy alias for data.</p> </details> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>numpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>np</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span><span class=w> </span><span class=nn>nelpy</span><span class=w> </span><span class=kn>import</span> <span class=n>AnalogSignalArray</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Create a simple sine wave signal</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>time</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>  <span class=c1># 1 second of data</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mi>5</span> <span class=o>*</span> <span class=n>time</span><span class=p>)</span>  <span class=c1># 5 Hz sine wave</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Create AnalogSignalArray with default parameters</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asa</span> <span class=o>=</span> <span class=n>AnalogSignalArray</span><span class=p>(</span>
<span class=gp>... </span>    <span class=n>data</span><span class=o>=</span><span class=n>signal</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>,</span> <span class=p>:],</span> <span class=n>abscissa_vals</span><span class=o>=</span><span class=n>time</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=mi>1000</span>
<span class=gp>... </span><span class=p>)</span>  <span class=c1># 1 kHz sampling</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Access data using different aliases</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>asa</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>  <span class=c1># (1, 1000)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>asa</span><span class=o>.</span><span class=n>ydata</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>  <span class=c1># same as data (legacy alias)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>asa</span><span class=o>.</span><span class=n>time</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>  <span class=c1># (1000,) alias for abscissa_vals</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Plot the signal (requires matplotlib)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># asa.plot()</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Create multi-channel signal with labels</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>signals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span><span class=n>signal</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span> <span class=o>*</span> <span class=mi>5</span> <span class=o>*</span> <span class=n>time</span><span class=p>)])</span>  <span class=c1># add cosine wave</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asa2</span> <span class=o>=</span> <span class=n>AnalogSignalArray</span><span class=p>(</span>
<span class=gp>... </span>    <span class=n>data</span><span class=o>=</span><span class=n>signals</span><span class=p>,</span> <span class=n>abscissa_vals</span><span class=o>=</span><span class=n>time</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=mi>1000</span><span class=p>,</span> <span class=n>labels</span><span class=o>=</span><span class=p>[</span><span class=s2>&quot;sine&quot;</span><span class=p>,</span> <span class=s2>&quot;cosine&quot;</span><span class=p>]</span>
<span class=gp>... </span><span class=p>)</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Access individual channels</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sine_channel</span> <span class=o>=</span> <span class=n>asa2</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>cosine_channel</span> <span class=o>=</span> <span class=n>asa2</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>]</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <ul> <li>Inherits all attributes and methods from RegularlySampledAnalogSignalArray</li> <li>Provides backward compatibility with legacy parameter names</li> <li>Automatically handles abscissa and ordinate objects if not provided</li> </ul> </details> <details class=see-also open> <summary>See Also</summary> <p>RegularlySampledAnalogSignalArray : Parent class with core functionality</p> </details> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2738</span>
<span class=normal>2739</span>
<span class=normal>2740</span>
<span class=normal>2741</span>
<span class=normal>2742</span>
<span class=normal>2743</span>
<span class=normal>2744</span>
<span class=normal>2745</span>
<span class=normal>2746</span>
<span class=normal>2747</span>
<span class=normal>2748</span>
<span class=normal>2749</span>
<span class=normal>2750</span>
<span class=normal>2751</span>
<span class=normal>2752</span>
<span class=normal>2753</span>
<span class=normal>2754</span>
<span class=normal>2755</span>
<span class=normal>2756</span>
<span class=normal>2757</span>
<span class=normal>2758</span>
<span class=normal>2759</span>
<span class=normal>2760</span>
<span class=normal>2761</span>
<span class=normal>2762</span>
<span class=normal>2763</span>
<span class=normal>2764</span>
<span class=normal>2765</span>
<span class=normal>2766</span>
<span class=normal>2767</span>
<span class=normal>2768</span>
<span class=normal>2769</span>
<span class=normal>2770</span>
<span class=normal>2771</span>
<span class=normal>2772</span>
<span class=normal>2773</span>
<span class=normal>2774</span>
<span class=normal>2775</span>
<span class=normal>2776</span>
<span class=normal>2777</span>
<span class=normal>2778</span>
<span class=normal>2779</span>
<span class=normal>2780</span>
<span class=normal>2781</span>
<span class=normal>2782</span>
<span class=normal>2783</span>
<span class=normal>2784</span>
<span class=normal>2785</span>
<span class=normal>2786</span>
<span class=normal>2787</span>
<span class=normal>2788</span>
<span class=normal>2789</span>
<span class=normal>2790</span>
<span class=normal>2791</span>
<span class=normal>2792</span>
<span class=normal>2793</span>
<span class=normal>2794</span>
<span class=normal>2795</span>
<span class=normal>2796</span>
<span class=normal>2797</span>
<span class=normal>2798</span>
<span class=normal>2799</span>
<span class=normal>2800</span>
<span class=normal>2801</span>
<span class=normal>2802</span>
<span class=normal>2803</span>
<span class=normal>2804</span>
<span class=normal>2805</span>
<span class=normal>2806</span>
<span class=normal>2807</span>
<span class=normal>2808</span>
<span class=normal>2809</span>
<span class=normal>2810</span>
<span class=normal>2811</span>
<span class=normal>2812</span>
<span class=normal>2813</span>
<span class=normal>2814</span>
<span class=normal>2815</span>
<span class=normal>2816</span>
<span class=normal>2817</span>
<span class=normal>2818</span>
<span class=normal>2819</span>
<span class=normal>2820</span>
<span class=normal>2821</span>
<span class=normal>2822</span>
<span class=normal>2823</span>
<span class=normal>2824</span>
<span class=normal>2825</span>
<span class=normal>2826</span>
<span class=normal>2827</span>
<span class=normal>2828</span>
<span class=normal>2829</span>
<span class=normal>2830</span>
<span class=normal>2831</span>
<span class=normal>2832</span>
<span class=normal>2833</span>
<span class=normal>2834</span>
<span class=normal>2835</span>
<span class=normal>2836</span>
<span class=normal>2837</span>
<span class=normal>2838</span>
<span class=normal>2839</span>
<span class=normal>2840</span>
<span class=normal>2841</span>
<span class=normal>2842</span>
<span class=normal>2843</span>
<span class=normal>2844</span>
<span class=normal>2845</span>
<span class=normal>2846</span>
<span class=normal>2847</span>
<span class=normal>2848</span>
<span class=normal>2849</span>
<span class=normal>2850</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>AnalogSignalArray</span><span class=p>(</span><span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Array of continuous analog signals with regular sampling rates.</span>

<span class=sd>    This class extends RegularlySampledAnalogSignalArray with additional aliases</span>
<span class=sd>    and legacy support for backward compatibility.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray, optional</span>
<span class=sd>        Array of signal data with shape (n_signals, n_samples).</span>
<span class=sd>        Default is empty array.</span>
<span class=sd>    abscissa_vals : np.ndarray, optional</span>
<span class=sd>        Time values corresponding to samples, with shape (n_samples,).</span>
<span class=sd>        Default is None.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Sampling frequency in Hz. Default is None.</span>
<span class=sd>    step : float, optional</span>
<span class=sd>        Sampling interval in seconds. Default is None.</span>
<span class=sd>    merge_sample_gap : float, optional</span>
<span class=sd>        Maximum gap between samples to merge intervals (seconds).</span>
<span class=sd>        Default is 0.</span>
<span class=sd>    support : nelpy.IntervalArray, optional</span>
<span class=sd>        Time intervals where signal is defined. Default is None.</span>
<span class=sd>    in_core : bool, optional</span>
<span class=sd>        Whether to keep data in core memory. Default is True.</span>
<span class=sd>    labels : array-like, optional</span>
<span class=sd>        Labels for each signal. Default is None.</span>
<span class=sd>    empty : bool, optional</span>
<span class=sd>        If True, creates empty array. Default is False.</span>
<span class=sd>    abscissa : nelpy.core.AnalogSignalArrayAbscissa, optional</span>
<span class=sd>        Abscissa object. Default is created from support.</span>
<span class=sd>    ordinate : nelpy.core.AnalogSignalArrayOrdinate, optional</span>
<span class=sd>        Ordinate object. Default is empty.</span>

<span class=sd>    Aliases</span>
<span class=sd>    -------</span>
<span class=sd>    time : abscissa_vals</span>
<span class=sd>        Alias for time values.</span>

<span class=sd>    n_epochs : n_intervals</span>
<span class=sd>        Alias for number of intervals.</span>
<span class=sd>    ydata : data</span>
<span class=sd>        Legacy alias for data.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; import numpy as np</span>
<span class=sd>    &gt;&gt;&gt; from nelpy import AnalogSignalArray</span>

<span class=sd>    &gt;&gt;&gt; # Create a simple sine wave signal</span>
<span class=sd>    &gt;&gt;&gt; time = np.linspace(0, 1, 1000)  # 1 second of data</span>
<span class=sd>    &gt;&gt;&gt; signal = np.sin(2 * np.pi * 5 * time)  # 5 Hz sine wave</span>

<span class=sd>    &gt;&gt;&gt; # Create AnalogSignalArray with default parameters</span>
<span class=sd>    &gt;&gt;&gt; asa = AnalogSignalArray(</span>
<span class=sd>    ...     data=signal[np.newaxis, :], abscissa_vals=time, fs=1000</span>
<span class=sd>    ... )  # 1 kHz sampling</span>

<span class=sd>    &gt;&gt;&gt; # Access data using different aliases</span>
<span class=sd>    &gt;&gt;&gt; print(asa.data.shape)  # (1, 1000)</span>
<span class=sd>    &gt;&gt;&gt; print(asa.ydata.shape)  # same as data (legacy alias)</span>
<span class=sd>    &gt;&gt;&gt; print(asa.time.shape)  # (1000,) alias for abscissa_vals</span>

<span class=sd>    &gt;&gt;&gt; # Plot the signal (requires matplotlib)</span>
<span class=sd>    &gt;&gt;&gt; # asa.plot()</span>

<span class=sd>    &gt;&gt;&gt; # Create multi-channel signal with labels</span>
<span class=sd>    &gt;&gt;&gt; signals = np.vstack([signal, np.cos(2 * np.pi * 5 * time)])  # add cosine wave</span>
<span class=sd>    &gt;&gt;&gt; asa2 = AnalogSignalArray(</span>
<span class=sd>    ...     data=signals, abscissa_vals=time, fs=1000, labels=[&quot;sine&quot;, &quot;cosine&quot;]</span>
<span class=sd>    ... )</span>

<span class=sd>    &gt;&gt;&gt; # Access individual channels</span>
<span class=sd>    &gt;&gt;&gt; sine_channel = asa2[:, 0]</span>
<span class=sd>    &gt;&gt;&gt; cosine_channel = asa2[:, 1]</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - Inherits all attributes and methods from RegularlySampledAnalogSignalArray</span>
<span class=sd>    - Provides backward compatibility with legacy parameter names</span>
<span class=sd>    - Automatically handles abscissa and ordinate objects if not provided</span>

<span class=sd>    See Also</span>
<span class=sd>    --------</span>
<span class=sd>    RegularlySampledAnalogSignalArray : Parent class with core functionality</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># specify class-specific aliases:</span>
    <span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span>
        <span class=s2>&quot;time&quot;</span><span class=p>:</span> <span class=s2>&quot;abscissa_vals&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_time&quot;</span><span class=p>:</span> <span class=s2>&quot;_abscissa_vals&quot;</span><span class=p>,</span>
        <span class=s2>&quot;n_epochs&quot;</span><span class=p>:</span> <span class=s2>&quot;n_intervals&quot;</span><span class=p>,</span>
        <span class=s2>&quot;ydata&quot;</span><span class=p>:</span> <span class=s2>&quot;data&quot;</span><span class=p>,</span>  <span class=c1># legacy support</span>
        <span class=s2>&quot;_ydata&quot;</span><span class=p>:</span> <span class=s2>&quot;_data&quot;</span><span class=p>,</span>  <span class=c1># legacy support</span>
    <span class=p>}</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=c1># add class-specific aliases to existing aliases:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>,</span> <span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>}</span>

        <span class=c1># legacy ASA constructor support for backward compatibility</span>
        <span class=n>kwargs</span> <span class=o>=</span> <span class=n>legacyASAkwargs</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

        <span class=n>support</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;support&quot;</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>EpochArray</span><span class=p>(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>))</span>
        <span class=n>abscissa</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span>
            <span class=s2>&quot;abscissa&quot;</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>AnalogSignalArrayAbscissa</span><span class=p>(</span><span class=n>support</span><span class=o>=</span><span class=n>support</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=n>ordinate</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;ordinate&quot;</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>AnalogSignalArrayOrdinate</span><span class=p>())</span>

        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;abscissa&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>abscissa</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;ordinate&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>ordinate</span>

        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.DataSlicer class="doc doc-heading"> <code>DataSlicer</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><span title=object>object</span></code></p> <p>Slicer for extracting data from analog signal arrays by interval and signal.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>parent</code> </td> <td> <code><span title=object>object</span></code> </td> <td> <div class=doc-md-description> <p>The parent object to slice.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 94</span>
<span class=normal> 95</span>
<span class=normal> 96</span>
<span class=normal> 97</span>
<span class=normal> 98</span>
<span class=normal> 99</span>
<span class=normal>100</span>
<span class=normal>101</span>
<span class=normal>102</span>
<span class=normal>103</span>
<span class=normal>104</span>
<span class=normal>105</span>
<span class=normal>106</span>
<span class=normal>107</span>
<span class=normal>108</span>
<span class=normal>109</span>
<span class=normal>110</span>
<span class=normal>111</span>
<span class=normal>112</span>
<span class=normal>113</span>
<span class=normal>114</span>
<span class=normal>115</span>
<span class=normal>116</span>
<span class=normal>117</span>
<span class=normal>118</span>
<span class=normal>119</span>
<span class=normal>120</span>
<span class=normal>121</span>
<span class=normal>122</span>
<span class=normal>123</span>
<span class=normal>124</span>
<span class=normal>125</span>
<span class=normal>126</span>
<span class=normal>127</span>
<span class=normal>128</span>
<span class=normal>129</span>
<span class=normal>130</span>
<span class=normal>131</span>
<span class=normal>132</span>
<span class=normal>133</span>
<span class=normal>134</span>
<span class=normal>135</span>
<span class=normal>136</span>
<span class=normal>137</span>
<span class=normal>138</span>
<span class=normal>139</span>
<span class=normal>140</span>
<span class=normal>141</span>
<span class=normal>142</span>
<span class=normal>143</span>
<span class=normal>144</span>
<span class=normal>145</span>
<span class=normal>146</span>
<span class=normal>147</span>
<span class=normal>148</span>
<span class=normal>149</span>
<span class=normal>150</span>
<span class=normal>151</span>
<span class=normal>152</span>
<span class=normal>153</span>
<span class=normal>154</span>
<span class=normal>155</span>
<span class=normal>156</span>
<span class=normal>157</span>
<span class=normal>158</span>
<span class=normal>159</span>
<span class=normal>160</span>
<span class=normal>161</span>
<span class=normal>162</span>
<span class=normal>163</span>
<span class=normal>164</span>
<span class=normal>165</span>
<span class=normal>166</span>
<span class=normal>167</span>
<span class=normal>168</span>
<span class=normal>169</span>
<span class=normal>170</span>
<span class=normal>171</span>
<span class=normal>172</span>
<span class=normal>173</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>DataSlicer</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Slicer for extracting data from analog signal arrays by interval and signal.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    parent : object</span>
<span class=sd>        The parent object to slice.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>parent</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Initialize the DataSlicer.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        parent : object</span>
<span class=sd>            The parent object to slice.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>parent</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_data_generator</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>interval_indices</span><span class=p>,</span> <span class=n>signalslice</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Generator for data slices by interval and signal.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interval_indices : list or array-like</span>
<span class=sd>            Indices of intervals.</span>
<span class=sd>        signalslice : int or slice</span>
<span class=sd>            Signal slice.</span>

<span class=sd>        Yields</span>
<span class=sd>        ------</span>
<span class=sd>        data : np.ndarray</span>
<span class=sd>            Data for each interval and signal.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>interval_indices</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>yield</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data</span><span class=p>[</span><span class=n>signalslice</span><span class=p>,</span> <span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
            <span class=k>except</span> <span class=ne>StopIteration</span><span class=p>:</span>
                <span class=k>return</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
        <span class=n>intervalslice</span><span class=p>,</span> <span class=n>signalslice</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_intervalsignalslicer</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>

        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>[</span><span class=n>intervalslice</span><span class=p>])</span>

        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>:</span>
            <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=o>=</span> <span class=n>interval_indices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data</span><span class=p>[</span><span class=n>signalslice</span><span class=p>,</span> <span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_data_generator</span><span class=p>(</span><span class=n>interval_indices</span><span class=p>,</span> <span class=n>signalslice</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>plot_generator</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>interval_indices</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>yield</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
            <span class=k>except</span> <span class=ne>StopIteration</span><span class=p>:</span>
                <span class=k>return</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__next__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_index</span>

        <span class=k>if</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>n_intervals</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>StopIteration</span>

        <span class=n>interval_indices</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data_interval_indices</span><span class=p>()</span>
        <span class=n>interval_indices</span> <span class=o>=</span> <span class=n>interval_indices</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
        <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=o>=</span> <span class=n>interval_indices</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_parent</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>]</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.IMUSensorArray class="doc doc-heading"> <code>IMUSensorArray</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code></p> <p>Array for storing IMU (Inertial Measurement Unit) sensor data with regular sampling rates.</p> <p>This class extends RegularlySampledAnalogSignalArray for IMU-specific data, such as accelerometer, gyroscope, and magnetometer signals.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>*args</code> </td> <td> </td> <td> <div class=doc-md-description> <p>Positional arguments passed to the parent class.</p> </div> </td> <td> <code>()</code> </td> </tr> <tr class=doc-section-item> <td> <code>**kwargs</code> </td> <td> </td> <td> <div class=doc-md-description> <p>Keyword arguments passed to the parent class.</p> </div> </td> <td> <code>{}</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Attributes:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.IMUSensorArray.__aliases__>__aliases__</span></code></td> <td> <code><span title=dict>dict</span></code> </td> <td> <div class=doc-md-description> <p>Dictionary of class-specific aliases.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>imu</span> <span class=o>=</span> <span class=n>IMUSensorArray</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=p>[[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]],</span> <span class=n>fs</span><span class=o>=</span><span class=mi>100</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>imu</span><span class=o>.</span><span class=n>data</span>
<span class=go>array([[0, 1, 2],</span>
<span class=go>       [3, 4, 5]])</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>3032</span>
<span class=normal>3033</span>
<span class=normal>3034</span>
<span class=normal>3035</span>
<span class=normal>3036</span>
<span class=normal>3037</span>
<span class=normal>3038</span>
<span class=normal>3039</span>
<span class=normal>3040</span>
<span class=normal>3041</span>
<span class=normal>3042</span>
<span class=normal>3043</span>
<span class=normal>3044</span>
<span class=normal>3045</span>
<span class=normal>3046</span>
<span class=normal>3047</span>
<span class=normal>3048</span>
<span class=normal>3049</span>
<span class=normal>3050</span>
<span class=normal>3051</span>
<span class=normal>3052</span>
<span class=normal>3053</span>
<span class=normal>3054</span>
<span class=normal>3055</span>
<span class=normal>3056</span>
<span class=normal>3057</span>
<span class=normal>3058</span>
<span class=normal>3059</span>
<span class=normal>3060</span>
<span class=normal>3061</span>
<span class=normal>3062</span>
<span class=normal>3063</span>
<span class=normal>3064</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>IMUSensorArray</span><span class=p>(</span><span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Array for storing IMU (Inertial Measurement Unit) sensor data with regular sampling rates.</span>

<span class=sd>    This class extends RegularlySampledAnalogSignalArray for IMU-specific data, such as accelerometer, gyroscope, and magnetometer signals.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    *args :</span>
<span class=sd>        Positional arguments passed to the parent class.</span>
<span class=sd>    **kwargs :</span>
<span class=sd>        Keyword arguments passed to the parent class.</span>

<span class=sd>    Attributes</span>
<span class=sd>    ----------</span>
<span class=sd>    __aliases__ : dict</span>
<span class=sd>        Dictionary of class-specific aliases.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; imu = IMUSensorArray(data=[[0, 1, 2], [3, 4, 5]], fs=100)</span>
<span class=sd>    &gt;&gt;&gt; imu.data</span>
<span class=sd>    array([[0, 1, 2],</span>
<span class=sd>           [3, 4, 5]])</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># specify class-specific aliases:</span>
    <span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{}</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=c1># add class-specific aliases to existing aliases:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>,</span> <span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>}</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.IntervalSignalSlicer class="doc doc-heading"> <code>IntervalSignalSlicer</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><span title=object>object</span></code></p> <p>Slicer for extracting intervals and signals from analog signal arrays.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>obj</code> </td> <td> <code><span title=object>object</span></code> </td> <td> <div class=doc-md-description> <p>The parent object to slice.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span>
<span class=normal>81</span>
<span class=normal>82</span>
<span class=normal>83</span>
<span class=normal>84</span>
<span class=normal>85</span>
<span class=normal>86</span>
<span class=normal>87</span>
<span class=normal>88</span>
<span class=normal>89</span>
<span class=normal>90</span>
<span class=normal>91</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>IntervalSignalSlicer</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Slicer for extracting intervals and signals from analog signal arrays.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    obj : object</span>
<span class=sd>        The parent object to slice.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obj</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Initialize the IntervalSignalSlicer.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        obj : object</span>
<span class=sd>            The parent object to slice.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>obj</span> <span class=o>=</span> <span class=n>obj</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Extract intervals and signals based on the provided arguments.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        *args : int, slice, or IntervalArray</span>
<span class=sd>            Indices or slices for intervals and signals.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        intervalslice : int, slice, or IntervalArray</span>
<span class=sd>            The interval slice.</span>
<span class=sd>        signalslice : int or slice</span>
<span class=sd>            The signal slice.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=c1># by default, keep all signals</span>
        <span class=n>signalslice</span> <span class=o>=</span> <span class=nb>slice</span><span class=p>(</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
            <span class=n>intervalslice</span> <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>IntervalArray</span><span class=p>):</span>
            <span class=n>intervalslice</span> <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>slices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>s_</span><span class=p>[</span><span class=n>args</span><span class=p>]</span>
                <span class=n>slices</span> <span class=o>=</span> <span class=n>slices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>slices</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
                        <span class=s2>&quot;only [intervals, signal] slicing is supported at this time!&quot;</span>
                    <span class=p>)</span>
                <span class=k>elif</span> <span class=nb>len</span><span class=p>(</span><span class=n>slices</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
                    <span class=n>intervalslice</span><span class=p>,</span> <span class=n>signalslice</span> <span class=o>=</span> <span class=n>slices</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>intervalslice</span> <span class=o>=</span> <span class=n>slices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
                <span class=c1># only interval to slice:</span>
                <span class=n>intervalslice</span> <span class=o>=</span> <span class=n>slices</span>

        <span class=k>return</span> <span class=n>intervalslice</span><span class=p>,</span> <span class=n>signalslice</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.MinimalExampleArray class="doc doc-heading"> <code>MinimalExampleArray</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code></p> <p>MinimalExampleArray is a custom example subclass of RegularlySampledAnalogSignalArray.</p> <p>This class demonstrates how to extend RegularlySampledAnalogSignalArray with custom aliases and methods.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>*args</code> </td> <td> </td> <td> <div class=doc-md-description> <p>Positional arguments passed to the parent class.</p> </div> </td> <td> <code>()</code> </td> </tr> <tr class=doc-section-item> <td> <code>**kwargs</code> </td> <td> </td> <td> <div class=doc-md-description> <p>Keyword arguments passed to the parent class.</p> </div> </td> <td> <code>{}</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Attributes:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.MinimalExampleArray.__aliases__>__aliases__</span></code></td> <td> <code><span title=dict>dict</span></code> </td> <td> <div class=doc-md-description> <p>Dictionary of class-specific aliases.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>arr</span> <span class=o>=</span> <span class=n>MinimalExampleArray</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=p>[[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]],</span> <span class=n>fs</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>arr</span><span class=o>.</span><span class=n>custom_func</span><span class=p>()</span>
<span class=go>Woot! We have some special skillz!</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>3070</span>
<span class=normal>3071</span>
<span class=normal>3072</span>
<span class=normal>3073</span>
<span class=normal>3074</span>
<span class=normal>3075</span>
<span class=normal>3076</span>
<span class=normal>3077</span>
<span class=normal>3078</span>
<span class=normal>3079</span>
<span class=normal>3080</span>
<span class=normal>3081</span>
<span class=normal>3082</span>
<span class=normal>3083</span>
<span class=normal>3084</span>
<span class=normal>3085</span>
<span class=normal>3086</span>
<span class=normal>3087</span>
<span class=normal>3088</span>
<span class=normal>3089</span>
<span class=normal>3090</span>
<span class=normal>3091</span>
<span class=normal>3092</span>
<span class=normal>3093</span>
<span class=normal>3094</span>
<span class=normal>3095</span>
<span class=normal>3096</span>
<span class=normal>3097</span>
<span class=normal>3098</span>
<span class=normal>3099</span>
<span class=normal>3100</span>
<span class=normal>3101</span>
<span class=normal>3102</span>
<span class=normal>3103</span>
<span class=normal>3104</span>
<span class=normal>3105</span>
<span class=normal>3106</span>
<span class=normal>3107</span>
<span class=normal>3108</span>
<span class=normal>3109</span>
<span class=normal>3110</span>
<span class=normal>3111</span>
<span class=normal>3112</span>
<span class=normal>3113</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>MinimalExampleArray</span><span class=p>(</span><span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    MinimalExampleArray is a custom example subclass of RegularlySampledAnalogSignalArray.</span>

<span class=sd>    This class demonstrates how to extend RegularlySampledAnalogSignalArray with custom aliases and methods.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    *args :</span>
<span class=sd>        Positional arguments passed to the parent class.</span>
<span class=sd>    **kwargs :</span>
<span class=sd>        Keyword arguments passed to the parent class.</span>

<span class=sd>    Attributes</span>
<span class=sd>    ----------</span>
<span class=sd>    __aliases__ : dict</span>
<span class=sd>        Dictionary of class-specific aliases.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; arr = MinimalExampleArray(data=[[1, 2, 3]], fs=1000)</span>
<span class=sd>    &gt;&gt;&gt; arr.custom_func()</span>
<span class=sd>    Woot! We have some special skillz!</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># specify class-specific aliases:</span>
    <span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{}</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=c1># add class-specific aliases to existing aliases:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>,</span> <span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>}</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>custom_func</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Print a custom message demonstrating a special method.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; arr = MinimalExampleArray(data=[[1, 2, 3]], fs=1000)</span>
<span class=sd>        &gt;&gt;&gt; arr.custom_func()</span>
<span class=sd>        Woot! We have some special skillz!</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;Woot! We have some special skillz!&quot;</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.MinimalExampleArray.custom_func class="doc doc-heading"> <code class="highlight language-python"><span class=n>custom_func</span><span class=p>()</span></code> </h3> <div class="doc doc-contents "> <p>Print a custom message demonstrating a special method.</p> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>arr</span> <span class=o>=</span> <span class=n>MinimalExampleArray</span><span class=p>(</span><span class=n>data</span><span class=o>=</span><span class=p>[[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]],</span> <span class=n>fs</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>arr</span><span class=o>.</span><span class=n>custom_func</span><span class=p>()</span>
<span class=go>Woot! We have some special skillz!</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>3103</span>
<span class=normal>3104</span>
<span class=normal>3105</span>
<span class=normal>3106</span>
<span class=normal>3107</span>
<span class=normal>3108</span>
<span class=normal>3109</span>
<span class=normal>3110</span>
<span class=normal>3111</span>
<span class=normal>3112</span>
<span class=normal>3113</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>custom_func</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Print a custom message demonstrating a special method.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; arr = MinimalExampleArray(data=[[1, 2, 3]], fs=1000)</span>
<span class=sd>    &gt;&gt;&gt; arr.custom_func()</span>
<span class=sd>    Woot! We have some special skillz!</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>&quot;Woot! We have some special skillz!&quot;</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.PositionArray class="doc doc-heading"> <code>PositionArray</code> </h2> <div class="doc doc-contents "> <p class="doc doc-class-bases"> Bases: <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.AnalogSignalArray>AnalogSignalArray</a></code></p> <p>An array for storing position data in 1D or 2D space.</p> <p>PositionArray is a specialized subclass of AnalogSignalArray designed to handle position tracking data. It provides convenient access to x and y coordinates, supports both 1D and 2D positional data, and includes spatial boundary information.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code><span title=array_like>array_like</span> or None</code> </td> <td> <div class=doc-md-description> <p>Position data with shape (n_signals, n_samples). For 1D position data, n_signals should be 1. For 2D position data, n_signals should be 2, where the first row contains x-coordinates and the second row contains y-coordinates. Can also be specified using the alias 'posdata'.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>timestamps</code> </td> <td> <code><span title=array_like>array_like</span> or None</code> </td> <td> <div class=doc-md-description> <p>Time stamps corresponding to each sample in data. If None, timestamps are automatically generated based on fs and start time.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency in Hz. Used to generate timestamps if not provided.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>support</code> </td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.EpochArray>EpochArray</a> or None</code> </td> <td> <div class=doc-md-description> <p>EpochArray defining the time intervals over which the position data is valid.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>label</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Descriptive label for the position array.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>xlim</code> </td> <td> <code><span title=tuple>tuple</span> or None</code> </td> <td> <div class=doc-md-description> <p>Spatial boundaries for x-coordinate as (min_x, max_x).</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>ylim</code> </td> <td> <code><span title=tuple>tuple</span> or None</code> </td> <td> <div class=doc-md-description> <p>Spatial boundaries for y-coordinate as (min_y, max_y).</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Attributes:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.PositionArray.x>x</a></code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>X-coordinates as a 1D numpy array.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.PositionArray.y>y</a></code></td> <td> <code><span title=ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Y-coordinates as a 1D numpy array (only available for 2D data).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.PositionArray.is_1d>is_1d</span></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>True if position data is 1-dimensional.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.PositionArray.is_2d>is_2d</span></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>True if position data is 2-dimensional.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.PositionArray.xlim>xlim</span></code></td> <td> <code><span title=tuple>tuple</span> or None</code> </td> <td> <div class=doc-md-description> <p>Spatial boundaries for x-coordinate (only for 2D data).</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.PositionArray.ylim>ylim</span></code></td> <td> <code><span title=tuple>tuple</span> or None</code> </td> <td> <div class=doc-md-description> <p>Spatial boundaries for y-coordinate (only for 2D data).</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <p>Create a 1D position array:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>numpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>np</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span><span class=w> </span><span class=nn>nelpy</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>nel</span>
<span class=gp>&gt;&gt;&gt; </span><span class=c1># 1D position data (e.g., position on a linear track)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>x_pos</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>  <span class=c1># 100 cm track</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>timestamps</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>  <span class=c1># 10 seconds</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>pos_1d</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>PositionArray</span><span class=p>(</span>
<span class=gp>... </span>    <span class=n>data</span><span class=o>=</span><span class=n>x_pos</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>,</span> <span class=p>:],</span>
<span class=gp>... </span>    <span class=n>timestamps</span><span class=o>=</span><span class=n>timestamps</span><span class=p>,</span>
<span class=gp>... </span>    <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Linear track position&quot;</span><span class=p>,</span>
<span class=gp>... </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;1D position: </span><span class=si>{</span><span class=n>pos_1d</span><span class=o>.</span><span class=n>is_1d</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;X range: </span><span class=si>{</span><span class=n>pos_1d</span><span class=o>.</span><span class=n>x</span><span class=o>.</span><span class=n>min</span><span class=p>()</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> to </span><span class=si>{</span><span class=n>pos_1d</span><span class=o>.</span><span class=n>x</span><span class=o>.</span><span class=n>max</span><span class=p>()</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> cm&quot;</span><span class=p>)</span>
</code></pre></div> <p>Create a 2D position array:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># 2D position data (e.g., open field behavior)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>t</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>pi</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>x_pos</span> <span class=o>=</span> <span class=mi>50</span> <span class=o>+</span> <span class=mi>30</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>  <span class=c1># circular trajectory</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>y_pos</span> <span class=o>=</span> <span class=mi>50</span> <span class=o>+</span> <span class=mi>30</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>pos_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span><span class=n>x_pos</span><span class=p>,</span> <span class=n>y_pos</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>pos_2d</span> <span class=o>=</span> <span class=n>nel</span><span class=o>.</span><span class=n>PositionArray</span><span class=p>(</span>
<span class=gp>... </span>    <span class=n>posdata</span><span class=o>=</span><span class=n>pos_data</span><span class=p>,</span>
<span class=gp>... </span>    <span class=n>fs</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span>  <span class=c1># 100 Hz sampling</span>
<span class=gp>... </span>    <span class=n>xlim</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>
<span class=gp>... </span>    <span class=n>ylim</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>
<span class=gp>... </span>    <span class=n>label</span><span class=o>=</span><span class=s2>&quot;Open field position&quot;</span><span class=p>,</span>
<span class=gp>... </span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;2D position: </span><span class=si>{</span><span class=n>pos_2d</span><span class=o>.</span><span class=n>is_2d</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;X position shape: </span><span class=si>{</span><span class=n>pos_2d</span><span class=o>.</span><span class=n>x</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Y position shape: </span><span class=si>{</span><span class=n>pos_2d</span><span class=o>.</span><span class=n>y</span><span class=o>.</span><span class=n>shape</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Spatial bounds: x=</span><span class=si>{</span><span class=n>pos_2d</span><span class=o>.</span><span class=n>xlim</span><span class=si>}</span><span class=s2>, y=</span><span class=si>{</span><span class=n>pos_2d</span><span class=o>.</span><span class=n>ylim</span><span class=si>}</span><span class=s2>&quot;</span><span class=p>)</span>
</code></pre></div> <p>Access position data:</p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=c1># Get position at specific time</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>time_idx</span> <span class=o>=</span> <span class=mi>500</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>if</span> <span class=n>pos_2d</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>x_at_time</span> <span class=o>=</span> <span class=n>pos_2d</span><span class=o>.</span><span class=n>x</span><span class=p>[</span><span class=n>time_idx</span><span class=p>]</span>
<span class=gp>... </span>    <span class=n>y_at_time</span> <span class=o>=</span> <span class=n>pos_2d</span><span class=o>.</span><span class=n>y</span><span class=p>[</span><span class=n>time_idx</span><span class=p>]</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&quot;Position at sample </span><span class=si>{</span><span class=n>time_idx</span><span class=si>}</span><span class=s2>: (</span><span class=si>{</span><span class=n>x_at_time</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2>, </span><span class=si>{</span><span class=n>y_at_time</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2>)&quot;</span><span class=p>)</span>
</code></pre></div> <details class=note open> <summary>Notes</summary> <ul> <li>For 2D position data, the first row of data should contain x-coordinates and the second row should contain y-coordinates.</li> <li>The xlim and ylim parameters are only meaningful for 2D position data.</li> <li>Attempting to access y-coordinates or spatial limits on 1D data will raise a ValueError.</li> <li>The 'posdata' alias can be used interchangeably with 'data' parameter.</li> </ul> </details> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2856</span>
<span class=normal>2857</span>
<span class=normal>2858</span>
<span class=normal>2859</span>
<span class=normal>2860</span>
<span class=normal>2861</span>
<span class=normal>2862</span>
<span class=normal>2863</span>
<span class=normal>2864</span>
<span class=normal>2865</span>
<span class=normal>2866</span>
<span class=normal>2867</span>
<span class=normal>2868</span>
<span class=normal>2869</span>
<span class=normal>2870</span>
<span class=normal>2871</span>
<span class=normal>2872</span>
<span class=normal>2873</span>
<span class=normal>2874</span>
<span class=normal>2875</span>
<span class=normal>2876</span>
<span class=normal>2877</span>
<span class=normal>2878</span>
<span class=normal>2879</span>
<span class=normal>2880</span>
<span class=normal>2881</span>
<span class=normal>2882</span>
<span class=normal>2883</span>
<span class=normal>2884</span>
<span class=normal>2885</span>
<span class=normal>2886</span>
<span class=normal>2887</span>
<span class=normal>2888</span>
<span class=normal>2889</span>
<span class=normal>2890</span>
<span class=normal>2891</span>
<span class=normal>2892</span>
<span class=normal>2893</span>
<span class=normal>2894</span>
<span class=normal>2895</span>
<span class=normal>2896</span>
<span class=normal>2897</span>
<span class=normal>2898</span>
<span class=normal>2899</span>
<span class=normal>2900</span>
<span class=normal>2901</span>
<span class=normal>2902</span>
<span class=normal>2903</span>
<span class=normal>2904</span>
<span class=normal>2905</span>
<span class=normal>2906</span>
<span class=normal>2907</span>
<span class=normal>2908</span>
<span class=normal>2909</span>
<span class=normal>2910</span>
<span class=normal>2911</span>
<span class=normal>2912</span>
<span class=normal>2913</span>
<span class=normal>2914</span>
<span class=normal>2915</span>
<span class=normal>2916</span>
<span class=normal>2917</span>
<span class=normal>2918</span>
<span class=normal>2919</span>
<span class=normal>2920</span>
<span class=normal>2921</span>
<span class=normal>2922</span>
<span class=normal>2923</span>
<span class=normal>2924</span>
<span class=normal>2925</span>
<span class=normal>2926</span>
<span class=normal>2927</span>
<span class=normal>2928</span>
<span class=normal>2929</span>
<span class=normal>2930</span>
<span class=normal>2931</span>
<span class=normal>2932</span>
<span class=normal>2933</span>
<span class=normal>2934</span>
<span class=normal>2935</span>
<span class=normal>2936</span>
<span class=normal>2937</span>
<span class=normal>2938</span>
<span class=normal>2939</span>
<span class=normal>2940</span>
<span class=normal>2941</span>
<span class=normal>2942</span>
<span class=normal>2943</span>
<span class=normal>2944</span>
<span class=normal>2945</span>
<span class=normal>2946</span>
<span class=normal>2947</span>
<span class=normal>2948</span>
<span class=normal>2949</span>
<span class=normal>2950</span>
<span class=normal>2951</span>
<span class=normal>2952</span>
<span class=normal>2953</span>
<span class=normal>2954</span>
<span class=normal>2955</span>
<span class=normal>2956</span>
<span class=normal>2957</span>
<span class=normal>2958</span>
<span class=normal>2959</span>
<span class=normal>2960</span>
<span class=normal>2961</span>
<span class=normal>2962</span>
<span class=normal>2963</span>
<span class=normal>2964</span>
<span class=normal>2965</span>
<span class=normal>2966</span>
<span class=normal>2967</span>
<span class=normal>2968</span>
<span class=normal>2969</span>
<span class=normal>2970</span>
<span class=normal>2971</span>
<span class=normal>2972</span>
<span class=normal>2973</span>
<span class=normal>2974</span>
<span class=normal>2975</span>
<span class=normal>2976</span>
<span class=normal>2977</span>
<span class=normal>2978</span>
<span class=normal>2979</span>
<span class=normal>2980</span>
<span class=normal>2981</span>
<span class=normal>2982</span>
<span class=normal>2983</span>
<span class=normal>2984</span>
<span class=normal>2985</span>
<span class=normal>2986</span>
<span class=normal>2987</span>
<span class=normal>2988</span>
<span class=normal>2989</span>
<span class=normal>2990</span>
<span class=normal>2991</span>
<span class=normal>2992</span>
<span class=normal>2993</span>
<span class=normal>2994</span>
<span class=normal>2995</span>
<span class=normal>2996</span>
<span class=normal>2997</span>
<span class=normal>2998</span>
<span class=normal>2999</span>
<span class=normal>3000</span>
<span class=normal>3001</span>
<span class=normal>3002</span>
<span class=normal>3003</span>
<span class=normal>3004</span>
<span class=normal>3005</span>
<span class=normal>3006</span>
<span class=normal>3007</span>
<span class=normal>3008</span>
<span class=normal>3009</span>
<span class=normal>3010</span>
<span class=normal>3011</span>
<span class=normal>3012</span>
<span class=normal>3013</span>
<span class=normal>3014</span>
<span class=normal>3015</span>
<span class=normal>3016</span>
<span class=normal>3017</span>
<span class=normal>3018</span>
<span class=normal>3019</span>
<span class=normal>3020</span>
<span class=normal>3021</span>
<span class=normal>3022</span>
<span class=normal>3023</span>
<span class=normal>3024</span>
<span class=normal>3025</span>
<span class=normal>3026</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>PositionArray</span><span class=p>(</span><span class=n>AnalogSignalArray</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;An array for storing position data in 1D or 2D space.</span>

<span class=sd>    PositionArray is a specialized subclass of AnalogSignalArray designed to</span>
<span class=sd>    handle position tracking data. It provides convenient access to x and y</span>
<span class=sd>    coordinates, supports both 1D and 2D positional data, and includes</span>
<span class=sd>    spatial boundary information.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : array_like or None, optional</span>
<span class=sd>        Position data with shape (n_signals, n_samples). For 1D position data,</span>
<span class=sd>        n_signals should be 1. For 2D position data, n_signals should be 2,</span>
<span class=sd>        where the first row contains x-coordinates and the second row contains</span>
<span class=sd>        y-coordinates. Can also be specified using the alias &#39;posdata&#39;.</span>
<span class=sd>    timestamps : array_like or None, optional</span>
<span class=sd>        Time stamps corresponding to each sample in data. If None, timestamps</span>
<span class=sd>        are automatically generated based on fs and start time.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Sampling frequency in Hz. Used to generate timestamps if not provided.</span>
<span class=sd>    support : EpochArray or None, optional</span>
<span class=sd>        EpochArray defining the time intervals over which the position data</span>
<span class=sd>        is valid.</span>
<span class=sd>    label : str, optional</span>
<span class=sd>        Descriptive label for the position array.</span>
<span class=sd>    xlim : tuple or None, optional</span>
<span class=sd>        Spatial boundaries for x-coordinate as (min_x, max_x).</span>
<span class=sd>    ylim : tuple or None, optional</span>
<span class=sd>        Spatial boundaries for y-coordinate as (min_y, max_y).</span>

<span class=sd>    Attributes</span>
<span class=sd>    ----------</span>
<span class=sd>    x : ndarray</span>
<span class=sd>        X-coordinates as a 1D numpy array.</span>
<span class=sd>    y : ndarray</span>
<span class=sd>        Y-coordinates as a 1D numpy array (only available for 2D data).</span>
<span class=sd>    is_1d : bool</span>
<span class=sd>        True if position data is 1-dimensional.</span>
<span class=sd>    is_2d : bool</span>
<span class=sd>        True if position data is 2-dimensional.</span>
<span class=sd>    xlim : tuple or None</span>
<span class=sd>        Spatial boundaries for x-coordinate (only for 2D data).</span>
<span class=sd>    ylim : tuple or None</span>
<span class=sd>        Spatial boundaries for y-coordinate (only for 2D data).</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    Create a 1D position array:</span>

<span class=sd>    &gt;&gt;&gt; import numpy as np</span>
<span class=sd>    &gt;&gt;&gt; import nelpy as nel</span>
<span class=sd>    &gt;&gt;&gt; # 1D position data (e.g., position on a linear track)</span>
<span class=sd>    &gt;&gt;&gt; x_pos = np.linspace(0, 100, 1000)  # 100 cm track</span>
<span class=sd>    &gt;&gt;&gt; timestamps = np.linspace(0, 10, 1000)  # 10 seconds</span>
<span class=sd>    &gt;&gt;&gt; pos_1d = nel.PositionArray(</span>
<span class=sd>    ...     data=x_pos[np.newaxis, :],</span>
<span class=sd>    ...     timestamps=timestamps,</span>
<span class=sd>    ...     label=&quot;Linear track position&quot;,</span>
<span class=sd>    ... )</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;1D position: {pos_1d.is_1d}&quot;)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;X range: {pos_1d.x.min():.1f} to {pos_1d.x.max():.1f} cm&quot;)</span>

<span class=sd>    Create a 2D position array:</span>

<span class=sd>    &gt;&gt;&gt; # 2D position data (e.g., open field behavior)</span>
<span class=sd>    &gt;&gt;&gt; t = np.linspace(0, 2 * np.pi, 1000)</span>
<span class=sd>    &gt;&gt;&gt; x_pos = 50 + 30 * np.cos(t)  # circular trajectory</span>
<span class=sd>    &gt;&gt;&gt; y_pos = 50 + 30 * np.sin(t)</span>
<span class=sd>    &gt;&gt;&gt; pos_data = np.vstack([x_pos, y_pos])</span>
<span class=sd>    &gt;&gt;&gt; pos_2d = nel.PositionArray(</span>
<span class=sd>    ...     posdata=pos_data,</span>
<span class=sd>    ...     fs=100,  # 100 Hz sampling</span>
<span class=sd>    ...     xlim=(0, 100),</span>
<span class=sd>    ...     ylim=(0, 100),</span>
<span class=sd>    ...     label=&quot;Open field position&quot;,</span>
<span class=sd>    ... )</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;2D position: {pos_2d.is_2d}&quot;)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;X position shape: {pos_2d.x.shape}&quot;)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Y position shape: {pos_2d.y.shape}&quot;)</span>
<span class=sd>    &gt;&gt;&gt; print(f&quot;Spatial bounds: x={pos_2d.xlim}, y={pos_2d.ylim}&quot;)</span>

<span class=sd>    Access position data:</span>

<span class=sd>    &gt;&gt;&gt; # Get position at specific time</span>
<span class=sd>    &gt;&gt;&gt; time_idx = 500</span>
<span class=sd>    &gt;&gt;&gt; if pos_2d.is_2d:</span>
<span class=sd>    ...     x_at_time = pos_2d.x[time_idx]</span>
<span class=sd>    ...     y_at_time = pos_2d.y[time_idx]</span>
<span class=sd>    ...     print(f&quot;Position at sample {time_idx}: ({x_at_time:.1f}, {y_at_time:.1f})&quot;)</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    - For 2D position data, the first row of data should contain x-coordinates</span>
<span class=sd>      and the second row should contain y-coordinates.</span>
<span class=sd>    - The xlim and ylim parameters are only meaningful for 2D position data.</span>
<span class=sd>    - Attempting to access y-coordinates or spatial limits on 1D data will</span>
<span class=sd>      raise a ValueError.</span>
<span class=sd>    - The &#39;posdata&#39; alias can be used interchangeably with &#39;data&#39; parameter.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># specify class-specific aliases:</span>
    <span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&quot;posdata&quot;</span><span class=p>:</span> <span class=s2>&quot;data&quot;</span><span class=p>}</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=c1># add class-specific aliases to existing aliases:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>,</span> <span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=p>}</span>
        <span class=n>xlim</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;xlim&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=n>ylim</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;ylim&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_xlim</span> <span class=o>=</span> <span class=n>xlim</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_ylim</span> <span class=o>=</span> <span class=n>ylim</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>is_2d</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>==</span> <span class=mi>2</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>False</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>is_1d</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>==</span> <span class=mi>1</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>False</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>x</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;return x-values, as numpy array.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=p>:]</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>y</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;return y-values, as numpy array.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=p>:]</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;PositionArray is not 2 dimensional, so y-values are undefined!&quot;</span>
        <span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>xlim</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_xlim</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;PositionArray is not 2 dimensional, so xlim is not undefined!&quot;</span>
        <span class=p>)</span>

    <span class=nd>@xlim</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>xlim</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_xlim</span> <span class=o>=</span> <span class=n>xlim</span>  <span class=c1># noqa: F821</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;PositionArray is not 2 dimensional, so xlim cannot be defined!&quot;</span>
        <span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>ylim</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ylim</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;PositionArray is not 2 dimensional, so ylim is not undefined!&quot;</span>
        <span class=p>)</span>

    <span class=nd>@ylim</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>ylim</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_2d</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_ylim</span> <span class=o>=</span> <span class=n>ylim</span>  <span class=c1># noqa: F821</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;PositionArray is not 2 dimensional, so ylim cannot be defined!&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.PositionArray.x class="doc doc-heading"> <code class="highlight language-python"><span class=n>x</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>return x-values, as numpy array.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.PositionArray.y class="doc doc-heading"> <code class="highlight language-python"><span class=n>y</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>return y-values, as numpy array.</p> </div> </div> </div> </div> </div> <div class="doc doc-object doc-class"> <h2 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray class="doc doc-heading"> <code>RegularlySampledAnalogSignalArray</code> </h2> <div class="doc doc-contents "> <p>Continuous analog signal(s) with regular sampling rates (irregular sampling rates can be corrected with operations on the support) and same support. NOTE: data that is not equal dimensionality will NOT work and error/warning messages may/may not be sent out. Assumes abscissa_vals are identical for all signals passed through and are therefore expected to be 1-dimensional.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>data</code> </td> <td> <code>np.ndarray, with shape (n_signals, n_samples).</code> </td> <td> <div class=doc-md-description> <p>Data samples.</p> </div> </td> <td> <code>[]</code> </td> </tr> <tr class=doc-section-item> <td> <code>abscissa_vals</code> </td> <td> <code>np.ndarray, with shape (n_samples, ).</code> </td> <td> <div class=doc-md-description> <p>The abscissa coordinate values. Currently we assume that (1) these values are timestamps, and (2) the timestamps are sampled regularly (we rely on these assumptions to generate intervals). Irregular sampling rates can be corrected with operations on the support.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The sampling rate. abscissa_vals are still expected to be in units of time and fs is expected to be in the corresponding sampling rate (e.g. abscissa_vals in seconds, fs in Hz). Default is 1 Hz.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>step</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The sampling interval of the data, in seconds. Default is None. specifies step size of samples passed as tdata if fs is given, default is None. If not passed it is inferred by the minimum difference in between samples of tdata passed in (based on if FS is passed). e.g. decimated data would have sample numbers every ten samples so step=10</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>merge_sample_gap</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Optional merging of gaps between support intervals. If intervals are within a certain amount of time, gap, they will be merged as one interval. Example use case is when there is a dropped sample</p> </div> </td> <td> <code>0</code> </td> </tr> <tr class=doc-section-item> <td> <code>support</code> </td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.IntervalArray>IntervalArray</a></code> </td> <td> <div class=doc-md-description> <p>Where the data are defined. Default is [0, last abscissa value] inclusive.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>in_core</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether the abscissa values should be treated as residing in core memory. During RSASA construction, np.diff() is called, so for large data, passing in in_core=True might help. In that case, a slower but much smaller memory footprint function is used.</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>labels</code> </td> <td> <code>np.array, dtype=np.str</code> </td> <td> <div class=doc-md-description> <p>Labels for each of the signals. If fewer labels than signals are passed in, labels are padded with None's to match the number of signals. If more labels than signals are passed in, labels are truncated to match the number of signals. Default is None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>empty</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Return an empty RegularlySampledAnalogSignalArray if true else false. Default is false.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>abscissa</code> </td> <td> <code><span title=optional>optional</span></code> </td> <td> <div class=doc-md-description> <p>The object handling the abscissa values. It is recommended to leave this parameter alone and let nelpy take care of this. Default is a nelpy.core.Abscissa object.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>ordinate</code> </td> <td> <code><span title=optional>optional</span></code> </td> <td> <div class=doc-md-description> <p>The object handling the ordinate values. It is recommended to leave this parameter alone and let nelpy take care of this. Default is a nelpy.core.Ordinate object.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Attributes:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.data>data</a></code></td> <td> <code>np.ndarray, with shape (n_signals, n_samples)</code> </td> <td> <div class=doc-md-description> <p>The underlying data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abscissa_vals>abscissa_vals</a></code></td> <td> <code>np.ndarray, with shape (n_samples, )</code> </td> <td> <div class=doc-md-description> <p>The values of the abscissa coordinate.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.is1d>is1d</span></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether there is only 1 signal in the RSASA</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.iswrapped>iswrapped</span></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether the RSASA's data is wrapping.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.base_unit>base_unit</a></code></td> <td> <code><span title=string>string</span></code> </td> <td> <div class=doc-md-description> <p>Base unit of the abscissa.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.signals>signals</a></code></td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>A list of RegularlySampledAnalogSignalArrays, each RSASA containing a single signal (channel). WARNING: this method creates a copy of each signal, so is not particularly efficient at this time.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isreal>isreal</a></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether ALL of the values in the RSASA's data are real.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.iscomplex>iscomplex</a></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether ANY values in the data are complex.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abs>abs</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>A copy of the RSASA, whose data is the absolute value of the original original RSASA's (potentially complex) data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><span title=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.phase>phase</span></code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>A copy of the RSASA, whose data is just the phase angle (in radians) of the original RSASA's data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.real>real</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>A copy of the RSASA, whose data is just the real part of the original RSASA's data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.imag>imag</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>A copy of the RSASA, whose data is just the imaginary part of the original RSASA's data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.lengths>lengths</a></code></td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>The number of samples in each interval.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.labels>labels</a></code></td> <td> <code><span title=list>list</span></code> </td> <td> <div class=doc-md-description> <p>The labels corresponding to each signal.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_signals>n_signals</a></code></td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of signals in the RSASA.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.support>support</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.IntervalArray>IntervalArray</a></code> </td> <td> <div class=doc-md-description> <p>The support of the RSASA.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.domain>domain</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.IntervalArray>IntervalArray</a></code> </td> <td> <div class=doc-md-description> <p>The domain of the RSASA.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.range>range</a></code></td> <td> <code><a class="autorefs autorefs-internal" href=../intervalarray/#nelpy.core._intervalarray.IntervalArray>IntervalArray</a></code> </td> <td> <div class=doc-md-description> <p>The range of the RSASA's data.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.step>step</a></code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The sampling interval of the RSASA. Currently the units are in seconds.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.fs>fs</a></code></td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>The sampling frequency of the RSASA. Currently the units are in Hz.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isempty>isempty</a></code></td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>Whether the underlying data has zero length, i.e. 0 samples</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_bytes>n_bytes</a></code></td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Approximate number of bytes taken up by the RSASA.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_intervals>n_intervals</a></code></td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of underlying intervals in the RSASA.</p> </div> </td> </tr> <tr class=doc-section-item> <td><code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_samples>n_samples</a></code></td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>The number of abscissa values in the RSASA.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 368</span>
<span class=normal> 369</span>
<span class=normal> 370</span>
<span class=normal> 371</span>
<span class=normal> 372</span>
<span class=normal> 373</span>
<span class=normal> 374</span>
<span class=normal> 375</span>
<span class=normal> 376</span>
<span class=normal> 377</span>
<span class=normal> 378</span>
<span class=normal> 379</span>
<span class=normal> 380</span>
<span class=normal> 381</span>
<span class=normal> 382</span>
<span class=normal> 383</span>
<span class=normal> 384</span>
<span class=normal> 385</span>
<span class=normal> 386</span>
<span class=normal> 387</span>
<span class=normal> 388</span>
<span class=normal> 389</span>
<span class=normal> 390</span>
<span class=normal> 391</span>
<span class=normal> 392</span>
<span class=normal> 393</span>
<span class=normal> 394</span>
<span class=normal> 395</span>
<span class=normal> 396</span>
<span class=normal> 397</span>
<span class=normal> 398</span>
<span class=normal> 399</span>
<span class=normal> 400</span>
<span class=normal> 401</span>
<span class=normal> 402</span>
<span class=normal> 403</span>
<span class=normal> 404</span>
<span class=normal> 405</span>
<span class=normal> 406</span>
<span class=normal> 407</span>
<span class=normal> 408</span>
<span class=normal> 409</span>
<span class=normal> 410</span>
<span class=normal> 411</span>
<span class=normal> 412</span>
<span class=normal> 413</span>
<span class=normal> 414</span>
<span class=normal> 415</span>
<span class=normal> 416</span>
<span class=normal> 417</span>
<span class=normal> 418</span>
<span class=normal> 419</span>
<span class=normal> 420</span>
<span class=normal> 421</span>
<span class=normal> 422</span>
<span class=normal> 423</span>
<span class=normal> 424</span>
<span class=normal> 425</span>
<span class=normal> 426</span>
<span class=normal> 427</span>
<span class=normal> 428</span>
<span class=normal> 429</span>
<span class=normal> 430</span>
<span class=normal> 431</span>
<span class=normal> 432</span>
<span class=normal> 433</span>
<span class=normal> 434</span>
<span class=normal> 435</span>
<span class=normal> 436</span>
<span class=normal> 437</span>
<span class=normal> 438</span>
<span class=normal> 439</span>
<span class=normal> 440</span>
<span class=normal> 441</span>
<span class=normal> 442</span>
<span class=normal> 443</span>
<span class=normal> 444</span>
<span class=normal> 445</span>
<span class=normal> 446</span>
<span class=normal> 447</span>
<span class=normal> 448</span>
<span class=normal> 449</span>
<span class=normal> 450</span>
<span class=normal> 451</span>
<span class=normal> 452</span>
<span class=normal> 453</span>
<span class=normal> 454</span>
<span class=normal> 455</span>
<span class=normal> 456</span>
<span class=normal> 457</span>
<span class=normal> 458</span>
<span class=normal> 459</span>
<span class=normal> 460</span>
<span class=normal> 461</span>
<span class=normal> 462</span>
<span class=normal> 463</span>
<span class=normal> 464</span>
<span class=normal> 465</span>
<span class=normal> 466</span>
<span class=normal> 467</span>
<span class=normal> 468</span>
<span class=normal> 469</span>
<span class=normal> 470</span>
<span class=normal> 471</span>
<span class=normal> 472</span>
<span class=normal> 473</span>
<span class=normal> 474</span>
<span class=normal> 475</span>
<span class=normal> 476</span>
<span class=normal> 477</span>
<span class=normal> 478</span>
<span class=normal> 479</span>
<span class=normal> 480</span>
<span class=normal> 481</span>
<span class=normal> 482</span>
<span class=normal> 483</span>
<span class=normal> 484</span>
<span class=normal> 485</span>
<span class=normal> 486</span>
<span class=normal> 487</span>
<span class=normal> 488</span>
<span class=normal> 489</span>
<span class=normal> 490</span>
<span class=normal> 491</span>
<span class=normal> 492</span>
<span class=normal> 493</span>
<span class=normal> 494</span>
<span class=normal> 495</span>
<span class=normal> 496</span>
<span class=normal> 497</span>
<span class=normal> 498</span>
<span class=normal> 499</span>
<span class=normal> 500</span>
<span class=normal> 501</span>
<span class=normal> 502</span>
<span class=normal> 503</span>
<span class=normal> 504</span>
<span class=normal> 505</span>
<span class=normal> 506</span>
<span class=normal> 507</span>
<span class=normal> 508</span>
<span class=normal> 509</span>
<span class=normal> 510</span>
<span class=normal> 511</span>
<span class=normal> 512</span>
<span class=normal> 513</span>
<span class=normal> 514</span>
<span class=normal> 515</span>
<span class=normal> 516</span>
<span class=normal> 517</span>
<span class=normal> 518</span>
<span class=normal> 519</span>
<span class=normal> 520</span>
<span class=normal> 521</span>
<span class=normal> 522</span>
<span class=normal> 523</span>
<span class=normal> 524</span>
<span class=normal> 525</span>
<span class=normal> 526</span>
<span class=normal> 527</span>
<span class=normal> 528</span>
<span class=normal> 529</span>
<span class=normal> 530</span>
<span class=normal> 531</span>
<span class=normal> 532</span>
<span class=normal> 533</span>
<span class=normal> 534</span>
<span class=normal> 535</span>
<span class=normal> 536</span>
<span class=normal> 537</span>
<span class=normal> 538</span>
<span class=normal> 539</span>
<span class=normal> 540</span>
<span class=normal> 541</span>
<span class=normal> 542</span>
<span class=normal> 543</span>
<span class=normal> 544</span>
<span class=normal> 545</span>
<span class=normal> 546</span>
<span class=normal> 547</span>
<span class=normal> 548</span>
<span class=normal> 549</span>
<span class=normal> 550</span>
<span class=normal> 551</span>
<span class=normal> 552</span>
<span class=normal> 553</span>
<span class=normal> 554</span>
<span class=normal> 555</span>
<span class=normal> 556</span>
<span class=normal> 557</span>
<span class=normal> 558</span>
<span class=normal> 559</span>
<span class=normal> 560</span>
<span class=normal> 561</span>
<span class=normal> 562</span>
<span class=normal> 563</span>
<span class=normal> 564</span>
<span class=normal> 565</span>
<span class=normal> 566</span>
<span class=normal> 567</span>
<span class=normal> 568</span>
<span class=normal> 569</span>
<span class=normal> 570</span>
<span class=normal> 571</span>
<span class=normal> 572</span>
<span class=normal> 573</span>
<span class=normal> 574</span>
<span class=normal> 575</span>
<span class=normal> 576</span>
<span class=normal> 577</span>
<span class=normal> 578</span>
<span class=normal> 579</span>
<span class=normal> 580</span>
<span class=normal> 581</span>
<span class=normal> 582</span>
<span class=normal> 583</span>
<span class=normal> 584</span>
<span class=normal> 585</span>
<span class=normal> 586</span>
<span class=normal> 587</span>
<span class=normal> 588</span>
<span class=normal> 589</span>
<span class=normal> 590</span>
<span class=normal> 591</span>
<span class=normal> 592</span>
<span class=normal> 593</span>
<span class=normal> 594</span>
<span class=normal> 595</span>
<span class=normal> 596</span>
<span class=normal> 597</span>
<span class=normal> 598</span>
<span class=normal> 599</span>
<span class=normal> 600</span>
<span class=normal> 601</span>
<span class=normal> 602</span>
<span class=normal> 603</span>
<span class=normal> 604</span>
<span class=normal> 605</span>
<span class=normal> 606</span>
<span class=normal> 607</span>
<span class=normal> 608</span>
<span class=normal> 609</span>
<span class=normal> 610</span>
<span class=normal> 611</span>
<span class=normal> 612</span>
<span class=normal> 613</span>
<span class=normal> 614</span>
<span class=normal> 615</span>
<span class=normal> 616</span>
<span class=normal> 617</span>
<span class=normal> 618</span>
<span class=normal> 619</span>
<span class=normal> 620</span>
<span class=normal> 621</span>
<span class=normal> 622</span>
<span class=normal> 623</span>
<span class=normal> 624</span>
<span class=normal> 625</span>
<span class=normal> 626</span>
<span class=normal> 627</span>
<span class=normal> 628</span>
<span class=normal> 629</span>
<span class=normal> 630</span>
<span class=normal> 631</span>
<span class=normal> 632</span>
<span class=normal> 633</span>
<span class=normal> 634</span>
<span class=normal> 635</span>
<span class=normal> 636</span>
<span class=normal> 637</span>
<span class=normal> 638</span>
<span class=normal> 639</span>
<span class=normal> 640</span>
<span class=normal> 641</span>
<span class=normal> 642</span>
<span class=normal> 643</span>
<span class=normal> 644</span>
<span class=normal> 645</span>
<span class=normal> 646</span>
<span class=normal> 647</span>
<span class=normal> 648</span>
<span class=normal> 649</span>
<span class=normal> 650</span>
<span class=normal> 651</span>
<span class=normal> 652</span>
<span class=normal> 653</span>
<span class=normal> 654</span>
<span class=normal> 655</span>
<span class=normal> 656</span>
<span class=normal> 657</span>
<span class=normal> 658</span>
<span class=normal> 659</span>
<span class=normal> 660</span>
<span class=normal> 661</span>
<span class=normal> 662</span>
<span class=normal> 663</span>
<span class=normal> 664</span>
<span class=normal> 665</span>
<span class=normal> 666</span>
<span class=normal> 667</span>
<span class=normal> 668</span>
<span class=normal> 669</span>
<span class=normal> 670</span>
<span class=normal> 671</span>
<span class=normal> 672</span>
<span class=normal> 673</span>
<span class=normal> 674</span>
<span class=normal> 675</span>
<span class=normal> 676</span>
<span class=normal> 677</span>
<span class=normal> 678</span>
<span class=normal> 679</span>
<span class=normal> 680</span>
<span class=normal> 681</span>
<span class=normal> 682</span>
<span class=normal> 683</span>
<span class=normal> 684</span>
<span class=normal> 685</span>
<span class=normal> 686</span>
<span class=normal> 687</span>
<span class=normal> 688</span>
<span class=normal> 689</span>
<span class=normal> 690</span>
<span class=normal> 691</span>
<span class=normal> 692</span>
<span class=normal> 693</span>
<span class=normal> 694</span>
<span class=normal> 695</span>
<span class=normal> 696</span>
<span class=normal> 697</span>
<span class=normal> 698</span>
<span class=normal> 699</span>
<span class=normal> 700</span>
<span class=normal> 701</span>
<span class=normal> 702</span>
<span class=normal> 703</span>
<span class=normal> 704</span>
<span class=normal> 705</span>
<span class=normal> 706</span>
<span class=normal> 707</span>
<span class=normal> 708</span>
<span class=normal> 709</span>
<span class=normal> 710</span>
<span class=normal> 711</span>
<span class=normal> 712</span>
<span class=normal> 713</span>
<span class=normal> 714</span>
<span class=normal> 715</span>
<span class=normal> 716</span>
<span class=normal> 717</span>
<span class=normal> 718</span>
<span class=normal> 719</span>
<span class=normal> 720</span>
<span class=normal> 721</span>
<span class=normal> 722</span>
<span class=normal> 723</span>
<span class=normal> 724</span>
<span class=normal> 725</span>
<span class=normal> 726</span>
<span class=normal> 727</span>
<span class=normal> 728</span>
<span class=normal> 729</span>
<span class=normal> 730</span>
<span class=normal> 731</span>
<span class=normal> 732</span>
<span class=normal> 733</span>
<span class=normal> 734</span>
<span class=normal> 735</span>
<span class=normal> 736</span>
<span class=normal> 737</span>
<span class=normal> 738</span>
<span class=normal> 739</span>
<span class=normal> 740</span>
<span class=normal> 741</span>
<span class=normal> 742</span>
<span class=normal> 743</span>
<span class=normal> 744</span>
<span class=normal> 745</span>
<span class=normal> 746</span>
<span class=normal> 747</span>
<span class=normal> 748</span>
<span class=normal> 749</span>
<span class=normal> 750</span>
<span class=normal> 751</span>
<span class=normal> 752</span>
<span class=normal> 753</span>
<span class=normal> 754</span>
<span class=normal> 755</span>
<span class=normal> 756</span>
<span class=normal> 757</span>
<span class=normal> 758</span>
<span class=normal> 759</span>
<span class=normal> 760</span>
<span class=normal> 761</span>
<span class=normal> 762</span>
<span class=normal> 763</span>
<span class=normal> 764</span>
<span class=normal> 765</span>
<span class=normal> 766</span>
<span class=normal> 767</span>
<span class=normal> 768</span>
<span class=normal> 769</span>
<span class=normal> 770</span>
<span class=normal> 771</span>
<span class=normal> 772</span>
<span class=normal> 773</span>
<span class=normal> 774</span>
<span class=normal> 775</span>
<span class=normal> 776</span>
<span class=normal> 777</span>
<span class=normal> 778</span>
<span class=normal> 779</span>
<span class=normal> 780</span>
<span class=normal> 781</span>
<span class=normal> 782</span>
<span class=normal> 783</span>
<span class=normal> 784</span>
<span class=normal> 785</span>
<span class=normal> 786</span>
<span class=normal> 787</span>
<span class=normal> 788</span>
<span class=normal> 789</span>
<span class=normal> 790</span>
<span class=normal> 791</span>
<span class=normal> 792</span>
<span class=normal> 793</span>
<span class=normal> 794</span>
<span class=normal> 795</span>
<span class=normal> 796</span>
<span class=normal> 797</span>
<span class=normal> 798</span>
<span class=normal> 799</span>
<span class=normal> 800</span>
<span class=normal> 801</span>
<span class=normal> 802</span>
<span class=normal> 803</span>
<span class=normal> 804</span>
<span class=normal> 805</span>
<span class=normal> 806</span>
<span class=normal> 807</span>
<span class=normal> 808</span>
<span class=normal> 809</span>
<span class=normal> 810</span>
<span class=normal> 811</span>
<span class=normal> 812</span>
<span class=normal> 813</span>
<span class=normal> 814</span>
<span class=normal> 815</span>
<span class=normal> 816</span>
<span class=normal> 817</span>
<span class=normal> 818</span>
<span class=normal> 819</span>
<span class=normal> 820</span>
<span class=normal> 821</span>
<span class=normal> 822</span>
<span class=normal> 823</span>
<span class=normal> 824</span>
<span class=normal> 825</span>
<span class=normal> 826</span>
<span class=normal> 827</span>
<span class=normal> 828</span>
<span class=normal> 829</span>
<span class=normal> 830</span>
<span class=normal> 831</span>
<span class=normal> 832</span>
<span class=normal> 833</span>
<span class=normal> 834</span>
<span class=normal> 835</span>
<span class=normal> 836</span>
<span class=normal> 837</span>
<span class=normal> 838</span>
<span class=normal> 839</span>
<span class=normal> 840</span>
<span class=normal> 841</span>
<span class=normal> 842</span>
<span class=normal> 843</span>
<span class=normal> 844</span>
<span class=normal> 845</span>
<span class=normal> 846</span>
<span class=normal> 847</span>
<span class=normal> 848</span>
<span class=normal> 849</span>
<span class=normal> 850</span>
<span class=normal> 851</span>
<span class=normal> 852</span>
<span class=normal> 853</span>
<span class=normal> 854</span>
<span class=normal> 855</span>
<span class=normal> 856</span>
<span class=normal> 857</span>
<span class=normal> 858</span>
<span class=normal> 859</span>
<span class=normal> 860</span>
<span class=normal> 861</span>
<span class=normal> 862</span>
<span class=normal> 863</span>
<span class=normal> 864</span>
<span class=normal> 865</span>
<span class=normal> 866</span>
<span class=normal> 867</span>
<span class=normal> 868</span>
<span class=normal> 869</span>
<span class=normal> 870</span>
<span class=normal> 871</span>
<span class=normal> 872</span>
<span class=normal> 873</span>
<span class=normal> 874</span>
<span class=normal> 875</span>
<span class=normal> 876</span>
<span class=normal> 877</span>
<span class=normal> 878</span>
<span class=normal> 879</span>
<span class=normal> 880</span>
<span class=normal> 881</span>
<span class=normal> 882</span>
<span class=normal> 883</span>
<span class=normal> 884</span>
<span class=normal> 885</span>
<span class=normal> 886</span>
<span class=normal> 887</span>
<span class=normal> 888</span>
<span class=normal> 889</span>
<span class=normal> 890</span>
<span class=normal> 891</span>
<span class=normal> 892</span>
<span class=normal> 893</span>
<span class=normal> 894</span>
<span class=normal> 895</span>
<span class=normal> 896</span>
<span class=normal> 897</span>
<span class=normal> 898</span>
<span class=normal> 899</span>
<span class=normal> 900</span>
<span class=normal> 901</span>
<span class=normal> 902</span>
<span class=normal> 903</span>
<span class=normal> 904</span>
<span class=normal> 905</span>
<span class=normal> 906</span>
<span class=normal> 907</span>
<span class=normal> 908</span>
<span class=normal> 909</span>
<span class=normal> 910</span>
<span class=normal> 911</span>
<span class=normal> 912</span>
<span class=normal> 913</span>
<span class=normal> 914</span>
<span class=normal> 915</span>
<span class=normal> 916</span>
<span class=normal> 917</span>
<span class=normal> 918</span>
<span class=normal> 919</span>
<span class=normal> 920</span>
<span class=normal> 921</span>
<span class=normal> 922</span>
<span class=normal> 923</span>
<span class=normal> 924</span>
<span class=normal> 925</span>
<span class=normal> 926</span>
<span class=normal> 927</span>
<span class=normal> 928</span>
<span class=normal> 929</span>
<span class=normal> 930</span>
<span class=normal> 931</span>
<span class=normal> 932</span>
<span class=normal> 933</span>
<span class=normal> 934</span>
<span class=normal> 935</span>
<span class=normal> 936</span>
<span class=normal> 937</span>
<span class=normal> 938</span>
<span class=normal> 939</span>
<span class=normal> 940</span>
<span class=normal> 941</span>
<span class=normal> 942</span>
<span class=normal> 943</span>
<span class=normal> 944</span>
<span class=normal> 945</span>
<span class=normal> 946</span>
<span class=normal> 947</span>
<span class=normal> 948</span>
<span class=normal> 949</span>
<span class=normal> 950</span>
<span class=normal> 951</span>
<span class=normal> 952</span>
<span class=normal> 953</span>
<span class=normal> 954</span>
<span class=normal> 955</span>
<span class=normal> 956</span>
<span class=normal> 957</span>
<span class=normal> 958</span>
<span class=normal> 959</span>
<span class=normal> 960</span>
<span class=normal> 961</span>
<span class=normal> 962</span>
<span class=normal> 963</span>
<span class=normal> 964</span>
<span class=normal> 965</span>
<span class=normal> 966</span>
<span class=normal> 967</span>
<span class=normal> 968</span>
<span class=normal> 969</span>
<span class=normal> 970</span>
<span class=normal> 971</span>
<span class=normal> 972</span>
<span class=normal> 973</span>
<span class=normal> 974</span>
<span class=normal> 975</span>
<span class=normal> 976</span>
<span class=normal> 977</span>
<span class=normal> 978</span>
<span class=normal> 979</span>
<span class=normal> 980</span>
<span class=normal> 981</span>
<span class=normal> 982</span>
<span class=normal> 983</span>
<span class=normal> 984</span>
<span class=normal> 985</span>
<span class=normal> 986</span>
<span class=normal> 987</span>
<span class=normal> 988</span>
<span class=normal> 989</span>
<span class=normal> 990</span>
<span class=normal> 991</span>
<span class=normal> 992</span>
<span class=normal> 993</span>
<span class=normal> 994</span>
<span class=normal> 995</span>
<span class=normal> 996</span>
<span class=normal> 997</span>
<span class=normal> 998</span>
<span class=normal> 999</span>
<span class=normal>1000</span>
<span class=normal>1001</span>
<span class=normal>1002</span>
<span class=normal>1003</span>
<span class=normal>1004</span>
<span class=normal>1005</span>
<span class=normal>1006</span>
<span class=normal>1007</span>
<span class=normal>1008</span>
<span class=normal>1009</span>
<span class=normal>1010</span>
<span class=normal>1011</span>
<span class=normal>1012</span>
<span class=normal>1013</span>
<span class=normal>1014</span>
<span class=normal>1015</span>
<span class=normal>1016</span>
<span class=normal>1017</span>
<span class=normal>1018</span>
<span class=normal>1019</span>
<span class=normal>1020</span>
<span class=normal>1021</span>
<span class=normal>1022</span>
<span class=normal>1023</span>
<span class=normal>1024</span>
<span class=normal>1025</span>
<span class=normal>1026</span>
<span class=normal>1027</span>
<span class=normal>1028</span>
<span class=normal>1029</span>
<span class=normal>1030</span>
<span class=normal>1031</span>
<span class=normal>1032</span>
<span class=normal>1033</span>
<span class=normal>1034</span>
<span class=normal>1035</span>
<span class=normal>1036</span>
<span class=normal>1037</span>
<span class=normal>1038</span>
<span class=normal>1039</span>
<span class=normal>1040</span>
<span class=normal>1041</span>
<span class=normal>1042</span>
<span class=normal>1043</span>
<span class=normal>1044</span>
<span class=normal>1045</span>
<span class=normal>1046</span>
<span class=normal>1047</span>
<span class=normal>1048</span>
<span class=normal>1049</span>
<span class=normal>1050</span>
<span class=normal>1051</span>
<span class=normal>1052</span>
<span class=normal>1053</span>
<span class=normal>1054</span>
<span class=normal>1055</span>
<span class=normal>1056</span>
<span class=normal>1057</span>
<span class=normal>1058</span>
<span class=normal>1059</span>
<span class=normal>1060</span>
<span class=normal>1061</span>
<span class=normal>1062</span>
<span class=normal>1063</span>
<span class=normal>1064</span>
<span class=normal>1065</span>
<span class=normal>1066</span>
<span class=normal>1067</span>
<span class=normal>1068</span>
<span class=normal>1069</span>
<span class=normal>1070</span>
<span class=normal>1071</span>
<span class=normal>1072</span>
<span class=normal>1073</span>
<span class=normal>1074</span>
<span class=normal>1075</span>
<span class=normal>1076</span>
<span class=normal>1077</span>
<span class=normal>1078</span>
<span class=normal>1079</span>
<span class=normal>1080</span>
<span class=normal>1081</span>
<span class=normal>1082</span>
<span class=normal>1083</span>
<span class=normal>1084</span>
<span class=normal>1085</span>
<span class=normal>1086</span>
<span class=normal>1087</span>
<span class=normal>1088</span>
<span class=normal>1089</span>
<span class=normal>1090</span>
<span class=normal>1091</span>
<span class=normal>1092</span>
<span class=normal>1093</span>
<span class=normal>1094</span>
<span class=normal>1095</span>
<span class=normal>1096</span>
<span class=normal>1097</span>
<span class=normal>1098</span>
<span class=normal>1099</span>
<span class=normal>1100</span>
<span class=normal>1101</span>
<span class=normal>1102</span>
<span class=normal>1103</span>
<span class=normal>1104</span>
<span class=normal>1105</span>
<span class=normal>1106</span>
<span class=normal>1107</span>
<span class=normal>1108</span>
<span class=normal>1109</span>
<span class=normal>1110</span>
<span class=normal>1111</span>
<span class=normal>1112</span>
<span class=normal>1113</span>
<span class=normal>1114</span>
<span class=normal>1115</span>
<span class=normal>1116</span>
<span class=normal>1117</span>
<span class=normal>1118</span>
<span class=normal>1119</span>
<span class=normal>1120</span>
<span class=normal>1121</span>
<span class=normal>1122</span>
<span class=normal>1123</span>
<span class=normal>1124</span>
<span class=normal>1125</span>
<span class=normal>1126</span>
<span class=normal>1127</span>
<span class=normal>1128</span>
<span class=normal>1129</span>
<span class=normal>1130</span>
<span class=normal>1131</span>
<span class=normal>1132</span>
<span class=normal>1133</span>
<span class=normal>1134</span>
<span class=normal>1135</span>
<span class=normal>1136</span>
<span class=normal>1137</span>
<span class=normal>1138</span>
<span class=normal>1139</span>
<span class=normal>1140</span>
<span class=normal>1141</span>
<span class=normal>1142</span>
<span class=normal>1143</span>
<span class=normal>1144</span>
<span class=normal>1145</span>
<span class=normal>1146</span>
<span class=normal>1147</span>
<span class=normal>1148</span>
<span class=normal>1149</span>
<span class=normal>1150</span>
<span class=normal>1151</span>
<span class=normal>1152</span>
<span class=normal>1153</span>
<span class=normal>1154</span>
<span class=normal>1155</span>
<span class=normal>1156</span>
<span class=normal>1157</span>
<span class=normal>1158</span>
<span class=normal>1159</span>
<span class=normal>1160</span>
<span class=normal>1161</span>
<span class=normal>1162</span>
<span class=normal>1163</span>
<span class=normal>1164</span>
<span class=normal>1165</span>
<span class=normal>1166</span>
<span class=normal>1167</span>
<span class=normal>1168</span>
<span class=normal>1169</span>
<span class=normal>1170</span>
<span class=normal>1171</span>
<span class=normal>1172</span>
<span class=normal>1173</span>
<span class=normal>1174</span>
<span class=normal>1175</span>
<span class=normal>1176</span>
<span class=normal>1177</span>
<span class=normal>1178</span>
<span class=normal>1179</span>
<span class=normal>1180</span>
<span class=normal>1181</span>
<span class=normal>1182</span>
<span class=normal>1183</span>
<span class=normal>1184</span>
<span class=normal>1185</span>
<span class=normal>1186</span>
<span class=normal>1187</span>
<span class=normal>1188</span>
<span class=normal>1189</span>
<span class=normal>1190</span>
<span class=normal>1191</span>
<span class=normal>1192</span>
<span class=normal>1193</span>
<span class=normal>1194</span>
<span class=normal>1195</span>
<span class=normal>1196</span>
<span class=normal>1197</span>
<span class=normal>1198</span>
<span class=normal>1199</span>
<span class=normal>1200</span>
<span class=normal>1201</span>
<span class=normal>1202</span>
<span class=normal>1203</span>
<span class=normal>1204</span>
<span class=normal>1205</span>
<span class=normal>1206</span>
<span class=normal>1207</span>
<span class=normal>1208</span>
<span class=normal>1209</span>
<span class=normal>1210</span>
<span class=normal>1211</span>
<span class=normal>1212</span>
<span class=normal>1213</span>
<span class=normal>1214</span>
<span class=normal>1215</span>
<span class=normal>1216</span>
<span class=normal>1217</span>
<span class=normal>1218</span>
<span class=normal>1219</span>
<span class=normal>1220</span>
<span class=normal>1221</span>
<span class=normal>1222</span>
<span class=normal>1223</span>
<span class=normal>1224</span>
<span class=normal>1225</span>
<span class=normal>1226</span>
<span class=normal>1227</span>
<span class=normal>1228</span>
<span class=normal>1229</span>
<span class=normal>1230</span>
<span class=normal>1231</span>
<span class=normal>1232</span>
<span class=normal>1233</span>
<span class=normal>1234</span>
<span class=normal>1235</span>
<span class=normal>1236</span>
<span class=normal>1237</span>
<span class=normal>1238</span>
<span class=normal>1239</span>
<span class=normal>1240</span>
<span class=normal>1241</span>
<span class=normal>1242</span>
<span class=normal>1243</span>
<span class=normal>1244</span>
<span class=normal>1245</span>
<span class=normal>1246</span>
<span class=normal>1247</span>
<span class=normal>1248</span>
<span class=normal>1249</span>
<span class=normal>1250</span>
<span class=normal>1251</span>
<span class=normal>1252</span>
<span class=normal>1253</span>
<span class=normal>1254</span>
<span class=normal>1255</span>
<span class=normal>1256</span>
<span class=normal>1257</span>
<span class=normal>1258</span>
<span class=normal>1259</span>
<span class=normal>1260</span>
<span class=normal>1261</span>
<span class=normal>1262</span>
<span class=normal>1263</span>
<span class=normal>1264</span>
<span class=normal>1265</span>
<span class=normal>1266</span>
<span class=normal>1267</span>
<span class=normal>1268</span>
<span class=normal>1269</span>
<span class=normal>1270</span>
<span class=normal>1271</span>
<span class=normal>1272</span>
<span class=normal>1273</span>
<span class=normal>1274</span>
<span class=normal>1275</span>
<span class=normal>1276</span>
<span class=normal>1277</span>
<span class=normal>1278</span>
<span class=normal>1279</span>
<span class=normal>1280</span>
<span class=normal>1281</span>
<span class=normal>1282</span>
<span class=normal>1283</span>
<span class=normal>1284</span>
<span class=normal>1285</span>
<span class=normal>1286</span>
<span class=normal>1287</span>
<span class=normal>1288</span>
<span class=normal>1289</span>
<span class=normal>1290</span>
<span class=normal>1291</span>
<span class=normal>1292</span>
<span class=normal>1293</span>
<span class=normal>1294</span>
<span class=normal>1295</span>
<span class=normal>1296</span>
<span class=normal>1297</span>
<span class=normal>1298</span>
<span class=normal>1299</span>
<span class=normal>1300</span>
<span class=normal>1301</span>
<span class=normal>1302</span>
<span class=normal>1303</span>
<span class=normal>1304</span>
<span class=normal>1305</span>
<span class=normal>1306</span>
<span class=normal>1307</span>
<span class=normal>1308</span>
<span class=normal>1309</span>
<span class=normal>1310</span>
<span class=normal>1311</span>
<span class=normal>1312</span>
<span class=normal>1313</span>
<span class=normal>1314</span>
<span class=normal>1315</span>
<span class=normal>1316</span>
<span class=normal>1317</span>
<span class=normal>1318</span>
<span class=normal>1319</span>
<span class=normal>1320</span>
<span class=normal>1321</span>
<span class=normal>1322</span>
<span class=normal>1323</span>
<span class=normal>1324</span>
<span class=normal>1325</span>
<span class=normal>1326</span>
<span class=normal>1327</span>
<span class=normal>1328</span>
<span class=normal>1329</span>
<span class=normal>1330</span>
<span class=normal>1331</span>
<span class=normal>1332</span>
<span class=normal>1333</span>
<span class=normal>1334</span>
<span class=normal>1335</span>
<span class=normal>1336</span>
<span class=normal>1337</span>
<span class=normal>1338</span>
<span class=normal>1339</span>
<span class=normal>1340</span>
<span class=normal>1341</span>
<span class=normal>1342</span>
<span class=normal>1343</span>
<span class=normal>1344</span>
<span class=normal>1345</span>
<span class=normal>1346</span>
<span class=normal>1347</span>
<span class=normal>1348</span>
<span class=normal>1349</span>
<span class=normal>1350</span>
<span class=normal>1351</span>
<span class=normal>1352</span>
<span class=normal>1353</span>
<span class=normal>1354</span>
<span class=normal>1355</span>
<span class=normal>1356</span>
<span class=normal>1357</span>
<span class=normal>1358</span>
<span class=normal>1359</span>
<span class=normal>1360</span>
<span class=normal>1361</span>
<span class=normal>1362</span>
<span class=normal>1363</span>
<span class=normal>1364</span>
<span class=normal>1365</span>
<span class=normal>1366</span>
<span class=normal>1367</span>
<span class=normal>1368</span>
<span class=normal>1369</span>
<span class=normal>1370</span>
<span class=normal>1371</span>
<span class=normal>1372</span>
<span class=normal>1373</span>
<span class=normal>1374</span>
<span class=normal>1375</span>
<span class=normal>1376</span>
<span class=normal>1377</span>
<span class=normal>1378</span>
<span class=normal>1379</span>
<span class=normal>1380</span>
<span class=normal>1381</span>
<span class=normal>1382</span>
<span class=normal>1383</span>
<span class=normal>1384</span>
<span class=normal>1385</span>
<span class=normal>1386</span>
<span class=normal>1387</span>
<span class=normal>1388</span>
<span class=normal>1389</span>
<span class=normal>1390</span>
<span class=normal>1391</span>
<span class=normal>1392</span>
<span class=normal>1393</span>
<span class=normal>1394</span>
<span class=normal>1395</span>
<span class=normal>1396</span>
<span class=normal>1397</span>
<span class=normal>1398</span>
<span class=normal>1399</span>
<span class=normal>1400</span>
<span class=normal>1401</span>
<span class=normal>1402</span>
<span class=normal>1403</span>
<span class=normal>1404</span>
<span class=normal>1405</span>
<span class=normal>1406</span>
<span class=normal>1407</span>
<span class=normal>1408</span>
<span class=normal>1409</span>
<span class=normal>1410</span>
<span class=normal>1411</span>
<span class=normal>1412</span>
<span class=normal>1413</span>
<span class=normal>1414</span>
<span class=normal>1415</span>
<span class=normal>1416</span>
<span class=normal>1417</span>
<span class=normal>1418</span>
<span class=normal>1419</span>
<span class=normal>1420</span>
<span class=normal>1421</span>
<span class=normal>1422</span>
<span class=normal>1423</span>
<span class=normal>1424</span>
<span class=normal>1425</span>
<span class=normal>1426</span>
<span class=normal>1427</span>
<span class=normal>1428</span>
<span class=normal>1429</span>
<span class=normal>1430</span>
<span class=normal>1431</span>
<span class=normal>1432</span>
<span class=normal>1433</span>
<span class=normal>1434</span>
<span class=normal>1435</span>
<span class=normal>1436</span>
<span class=normal>1437</span>
<span class=normal>1438</span>
<span class=normal>1439</span>
<span class=normal>1440</span>
<span class=normal>1441</span>
<span class=normal>1442</span>
<span class=normal>1443</span>
<span class=normal>1444</span>
<span class=normal>1445</span>
<span class=normal>1446</span>
<span class=normal>1447</span>
<span class=normal>1448</span>
<span class=normal>1449</span>
<span class=normal>1450</span>
<span class=normal>1451</span>
<span class=normal>1452</span>
<span class=normal>1453</span>
<span class=normal>1454</span>
<span class=normal>1455</span>
<span class=normal>1456</span>
<span class=normal>1457</span>
<span class=normal>1458</span>
<span class=normal>1459</span>
<span class=normal>1460</span>
<span class=normal>1461</span>
<span class=normal>1462</span>
<span class=normal>1463</span>
<span class=normal>1464</span>
<span class=normal>1465</span>
<span class=normal>1466</span>
<span class=normal>1467</span>
<span class=normal>1468</span>
<span class=normal>1469</span>
<span class=normal>1470</span>
<span class=normal>1471</span>
<span class=normal>1472</span>
<span class=normal>1473</span>
<span class=normal>1474</span>
<span class=normal>1475</span>
<span class=normal>1476</span>
<span class=normal>1477</span>
<span class=normal>1478</span>
<span class=normal>1479</span>
<span class=normal>1480</span>
<span class=normal>1481</span>
<span class=normal>1482</span>
<span class=normal>1483</span>
<span class=normal>1484</span>
<span class=normal>1485</span>
<span class=normal>1486</span>
<span class=normal>1487</span>
<span class=normal>1488</span>
<span class=normal>1489</span>
<span class=normal>1490</span>
<span class=normal>1491</span>
<span class=normal>1492</span>
<span class=normal>1493</span>
<span class=normal>1494</span>
<span class=normal>1495</span>
<span class=normal>1496</span>
<span class=normal>1497</span>
<span class=normal>1498</span>
<span class=normal>1499</span>
<span class=normal>1500</span>
<span class=normal>1501</span>
<span class=normal>1502</span>
<span class=normal>1503</span>
<span class=normal>1504</span>
<span class=normal>1505</span>
<span class=normal>1506</span>
<span class=normal>1507</span>
<span class=normal>1508</span>
<span class=normal>1509</span>
<span class=normal>1510</span>
<span class=normal>1511</span>
<span class=normal>1512</span>
<span class=normal>1513</span>
<span class=normal>1514</span>
<span class=normal>1515</span>
<span class=normal>1516</span>
<span class=normal>1517</span>
<span class=normal>1518</span>
<span class=normal>1519</span>
<span class=normal>1520</span>
<span class=normal>1521</span>
<span class=normal>1522</span>
<span class=normal>1523</span>
<span class=normal>1524</span>
<span class=normal>1525</span>
<span class=normal>1526</span>
<span class=normal>1527</span>
<span class=normal>1528</span>
<span class=normal>1529</span>
<span class=normal>1530</span>
<span class=normal>1531</span>
<span class=normal>1532</span>
<span class=normal>1533</span>
<span class=normal>1534</span>
<span class=normal>1535</span>
<span class=normal>1536</span>
<span class=normal>1537</span>
<span class=normal>1538</span>
<span class=normal>1539</span>
<span class=normal>1540</span>
<span class=normal>1541</span>
<span class=normal>1542</span>
<span class=normal>1543</span>
<span class=normal>1544</span>
<span class=normal>1545</span>
<span class=normal>1546</span>
<span class=normal>1547</span>
<span class=normal>1548</span>
<span class=normal>1549</span>
<span class=normal>1550</span>
<span class=normal>1551</span>
<span class=normal>1552</span>
<span class=normal>1553</span>
<span class=normal>1554</span>
<span class=normal>1555</span>
<span class=normal>1556</span>
<span class=normal>1557</span>
<span class=normal>1558</span>
<span class=normal>1559</span>
<span class=normal>1560</span>
<span class=normal>1561</span>
<span class=normal>1562</span>
<span class=normal>1563</span>
<span class=normal>1564</span>
<span class=normal>1565</span>
<span class=normal>1566</span>
<span class=normal>1567</span>
<span class=normal>1568</span>
<span class=normal>1569</span>
<span class=normal>1570</span>
<span class=normal>1571</span>
<span class=normal>1572</span>
<span class=normal>1573</span>
<span class=normal>1574</span>
<span class=normal>1575</span>
<span class=normal>1576</span>
<span class=normal>1577</span>
<span class=normal>1578</span>
<span class=normal>1579</span>
<span class=normal>1580</span>
<span class=normal>1581</span>
<span class=normal>1582</span>
<span class=normal>1583</span>
<span class=normal>1584</span>
<span class=normal>1585</span>
<span class=normal>1586</span>
<span class=normal>1587</span>
<span class=normal>1588</span>
<span class=normal>1589</span>
<span class=normal>1590</span>
<span class=normal>1591</span>
<span class=normal>1592</span>
<span class=normal>1593</span>
<span class=normal>1594</span>
<span class=normal>1595</span>
<span class=normal>1596</span>
<span class=normal>1597</span>
<span class=normal>1598</span>
<span class=normal>1599</span>
<span class=normal>1600</span>
<span class=normal>1601</span>
<span class=normal>1602</span>
<span class=normal>1603</span>
<span class=normal>1604</span>
<span class=normal>1605</span>
<span class=normal>1606</span>
<span class=normal>1607</span>
<span class=normal>1608</span>
<span class=normal>1609</span>
<span class=normal>1610</span>
<span class=normal>1611</span>
<span class=normal>1612</span>
<span class=normal>1613</span>
<span class=normal>1614</span>
<span class=normal>1615</span>
<span class=normal>1616</span>
<span class=normal>1617</span>
<span class=normal>1618</span>
<span class=normal>1619</span>
<span class=normal>1620</span>
<span class=normal>1621</span>
<span class=normal>1622</span>
<span class=normal>1623</span>
<span class=normal>1624</span>
<span class=normal>1625</span>
<span class=normal>1626</span>
<span class=normal>1627</span>
<span class=normal>1628</span>
<span class=normal>1629</span>
<span class=normal>1630</span>
<span class=normal>1631</span>
<span class=normal>1632</span>
<span class=normal>1633</span>
<span class=normal>1634</span>
<span class=normal>1635</span>
<span class=normal>1636</span>
<span class=normal>1637</span>
<span class=normal>1638</span>
<span class=normal>1639</span>
<span class=normal>1640</span>
<span class=normal>1641</span>
<span class=normal>1642</span>
<span class=normal>1643</span>
<span class=normal>1644</span>
<span class=normal>1645</span>
<span class=normal>1646</span>
<span class=normal>1647</span>
<span class=normal>1648</span>
<span class=normal>1649</span>
<span class=normal>1650</span>
<span class=normal>1651</span>
<span class=normal>1652</span>
<span class=normal>1653</span>
<span class=normal>1654</span>
<span class=normal>1655</span>
<span class=normal>1656</span>
<span class=normal>1657</span>
<span class=normal>1658</span>
<span class=normal>1659</span>
<span class=normal>1660</span>
<span class=normal>1661</span>
<span class=normal>1662</span>
<span class=normal>1663</span>
<span class=normal>1664</span>
<span class=normal>1665</span>
<span class=normal>1666</span>
<span class=normal>1667</span>
<span class=normal>1668</span>
<span class=normal>1669</span>
<span class=normal>1670</span>
<span class=normal>1671</span>
<span class=normal>1672</span>
<span class=normal>1673</span>
<span class=normal>1674</span>
<span class=normal>1675</span>
<span class=normal>1676</span>
<span class=normal>1677</span>
<span class=normal>1678</span>
<span class=normal>1679</span>
<span class=normal>1680</span>
<span class=normal>1681</span>
<span class=normal>1682</span>
<span class=normal>1683</span>
<span class=normal>1684</span>
<span class=normal>1685</span>
<span class=normal>1686</span>
<span class=normal>1687</span>
<span class=normal>1688</span>
<span class=normal>1689</span>
<span class=normal>1690</span>
<span class=normal>1691</span>
<span class=normal>1692</span>
<span class=normal>1693</span>
<span class=normal>1694</span>
<span class=normal>1695</span>
<span class=normal>1696</span>
<span class=normal>1697</span>
<span class=normal>1698</span>
<span class=normal>1699</span>
<span class=normal>1700</span>
<span class=normal>1701</span>
<span class=normal>1702</span>
<span class=normal>1703</span>
<span class=normal>1704</span>
<span class=normal>1705</span>
<span class=normal>1706</span>
<span class=normal>1707</span>
<span class=normal>1708</span>
<span class=normal>1709</span>
<span class=normal>1710</span>
<span class=normal>1711</span>
<span class=normal>1712</span>
<span class=normal>1713</span>
<span class=normal>1714</span>
<span class=normal>1715</span>
<span class=normal>1716</span>
<span class=normal>1717</span>
<span class=normal>1718</span>
<span class=normal>1719</span>
<span class=normal>1720</span>
<span class=normal>1721</span>
<span class=normal>1722</span>
<span class=normal>1723</span>
<span class=normal>1724</span>
<span class=normal>1725</span>
<span class=normal>1726</span>
<span class=normal>1727</span>
<span class=normal>1728</span>
<span class=normal>1729</span>
<span class=normal>1730</span>
<span class=normal>1731</span>
<span class=normal>1732</span>
<span class=normal>1733</span>
<span class=normal>1734</span>
<span class=normal>1735</span>
<span class=normal>1736</span>
<span class=normal>1737</span>
<span class=normal>1738</span>
<span class=normal>1739</span>
<span class=normal>1740</span>
<span class=normal>1741</span>
<span class=normal>1742</span>
<span class=normal>1743</span>
<span class=normal>1744</span>
<span class=normal>1745</span>
<span class=normal>1746</span>
<span class=normal>1747</span>
<span class=normal>1748</span>
<span class=normal>1749</span>
<span class=normal>1750</span>
<span class=normal>1751</span>
<span class=normal>1752</span>
<span class=normal>1753</span>
<span class=normal>1754</span>
<span class=normal>1755</span>
<span class=normal>1756</span>
<span class=normal>1757</span>
<span class=normal>1758</span>
<span class=normal>1759</span>
<span class=normal>1760</span>
<span class=normal>1761</span>
<span class=normal>1762</span>
<span class=normal>1763</span>
<span class=normal>1764</span>
<span class=normal>1765</span>
<span class=normal>1766</span>
<span class=normal>1767</span>
<span class=normal>1768</span>
<span class=normal>1769</span>
<span class=normal>1770</span>
<span class=normal>1771</span>
<span class=normal>1772</span>
<span class=normal>1773</span>
<span class=normal>1774</span>
<span class=normal>1775</span>
<span class=normal>1776</span>
<span class=normal>1777</span>
<span class=normal>1778</span>
<span class=normal>1779</span>
<span class=normal>1780</span>
<span class=normal>1781</span>
<span class=normal>1782</span>
<span class=normal>1783</span>
<span class=normal>1784</span>
<span class=normal>1785</span>
<span class=normal>1786</span>
<span class=normal>1787</span>
<span class=normal>1788</span>
<span class=normal>1789</span>
<span class=normal>1790</span>
<span class=normal>1791</span>
<span class=normal>1792</span>
<span class=normal>1793</span>
<span class=normal>1794</span>
<span class=normal>1795</span>
<span class=normal>1796</span>
<span class=normal>1797</span>
<span class=normal>1798</span>
<span class=normal>1799</span>
<span class=normal>1800</span>
<span class=normal>1801</span>
<span class=normal>1802</span>
<span class=normal>1803</span>
<span class=normal>1804</span>
<span class=normal>1805</span>
<span class=normal>1806</span>
<span class=normal>1807</span>
<span class=normal>1808</span>
<span class=normal>1809</span>
<span class=normal>1810</span>
<span class=normal>1811</span>
<span class=normal>1812</span>
<span class=normal>1813</span>
<span class=normal>1814</span>
<span class=normal>1815</span>
<span class=normal>1816</span>
<span class=normal>1817</span>
<span class=normal>1818</span>
<span class=normal>1819</span>
<span class=normal>1820</span>
<span class=normal>1821</span>
<span class=normal>1822</span>
<span class=normal>1823</span>
<span class=normal>1824</span>
<span class=normal>1825</span>
<span class=normal>1826</span>
<span class=normal>1827</span>
<span class=normal>1828</span>
<span class=normal>1829</span>
<span class=normal>1830</span>
<span class=normal>1831</span>
<span class=normal>1832</span>
<span class=normal>1833</span>
<span class=normal>1834</span>
<span class=normal>1835</span>
<span class=normal>1836</span>
<span class=normal>1837</span>
<span class=normal>1838</span>
<span class=normal>1839</span>
<span class=normal>1840</span>
<span class=normal>1841</span>
<span class=normal>1842</span>
<span class=normal>1843</span>
<span class=normal>1844</span>
<span class=normal>1845</span>
<span class=normal>1846</span>
<span class=normal>1847</span>
<span class=normal>1848</span>
<span class=normal>1849</span>
<span class=normal>1850</span>
<span class=normal>1851</span>
<span class=normal>1852</span>
<span class=normal>1853</span>
<span class=normal>1854</span>
<span class=normal>1855</span>
<span class=normal>1856</span>
<span class=normal>1857</span>
<span class=normal>1858</span>
<span class=normal>1859</span>
<span class=normal>1860</span>
<span class=normal>1861</span>
<span class=normal>1862</span>
<span class=normal>1863</span>
<span class=normal>1864</span>
<span class=normal>1865</span>
<span class=normal>1866</span>
<span class=normal>1867</span>
<span class=normal>1868</span>
<span class=normal>1869</span>
<span class=normal>1870</span>
<span class=normal>1871</span>
<span class=normal>1872</span>
<span class=normal>1873</span>
<span class=normal>1874</span>
<span class=normal>1875</span>
<span class=normal>1876</span>
<span class=normal>1877</span>
<span class=normal>1878</span>
<span class=normal>1879</span>
<span class=normal>1880</span>
<span class=normal>1881</span>
<span class=normal>1882</span>
<span class=normal>1883</span>
<span class=normal>1884</span>
<span class=normal>1885</span>
<span class=normal>1886</span>
<span class=normal>1887</span>
<span class=normal>1888</span>
<span class=normal>1889</span>
<span class=normal>1890</span>
<span class=normal>1891</span>
<span class=normal>1892</span>
<span class=normal>1893</span>
<span class=normal>1894</span>
<span class=normal>1895</span>
<span class=normal>1896</span>
<span class=normal>1897</span>
<span class=normal>1898</span>
<span class=normal>1899</span>
<span class=normal>1900</span>
<span class=normal>1901</span>
<span class=normal>1902</span>
<span class=normal>1903</span>
<span class=normal>1904</span>
<span class=normal>1905</span>
<span class=normal>1906</span>
<span class=normal>1907</span>
<span class=normal>1908</span>
<span class=normal>1909</span>
<span class=normal>1910</span>
<span class=normal>1911</span>
<span class=normal>1912</span>
<span class=normal>1913</span>
<span class=normal>1914</span>
<span class=normal>1915</span>
<span class=normal>1916</span>
<span class=normal>1917</span>
<span class=normal>1918</span>
<span class=normal>1919</span>
<span class=normal>1920</span>
<span class=normal>1921</span>
<span class=normal>1922</span>
<span class=normal>1923</span>
<span class=normal>1924</span>
<span class=normal>1925</span>
<span class=normal>1926</span>
<span class=normal>1927</span>
<span class=normal>1928</span>
<span class=normal>1929</span>
<span class=normal>1930</span>
<span class=normal>1931</span>
<span class=normal>1932</span>
<span class=normal>1933</span>
<span class=normal>1934</span>
<span class=normal>1935</span>
<span class=normal>1936</span>
<span class=normal>1937</span>
<span class=normal>1938</span>
<span class=normal>1939</span>
<span class=normal>1940</span>
<span class=normal>1941</span>
<span class=normal>1942</span>
<span class=normal>1943</span>
<span class=normal>1944</span>
<span class=normal>1945</span>
<span class=normal>1946</span>
<span class=normal>1947</span>
<span class=normal>1948</span>
<span class=normal>1949</span>
<span class=normal>1950</span>
<span class=normal>1951</span>
<span class=normal>1952</span>
<span class=normal>1953</span>
<span class=normal>1954</span>
<span class=normal>1955</span>
<span class=normal>1956</span>
<span class=normal>1957</span>
<span class=normal>1958</span>
<span class=normal>1959</span>
<span class=normal>1960</span>
<span class=normal>1961</span>
<span class=normal>1962</span>
<span class=normal>1963</span>
<span class=normal>1964</span>
<span class=normal>1965</span>
<span class=normal>1966</span>
<span class=normal>1967</span>
<span class=normal>1968</span>
<span class=normal>1969</span>
<span class=normal>1970</span>
<span class=normal>1971</span>
<span class=normal>1972</span>
<span class=normal>1973</span>
<span class=normal>1974</span>
<span class=normal>1975</span>
<span class=normal>1976</span>
<span class=normal>1977</span>
<span class=normal>1978</span>
<span class=normal>1979</span>
<span class=normal>1980</span>
<span class=normal>1981</span>
<span class=normal>1982</span>
<span class=normal>1983</span>
<span class=normal>1984</span>
<span class=normal>1985</span>
<span class=normal>1986</span>
<span class=normal>1987</span>
<span class=normal>1988</span>
<span class=normal>1989</span>
<span class=normal>1990</span>
<span class=normal>1991</span>
<span class=normal>1992</span>
<span class=normal>1993</span>
<span class=normal>1994</span>
<span class=normal>1995</span>
<span class=normal>1996</span>
<span class=normal>1997</span>
<span class=normal>1998</span>
<span class=normal>1999</span>
<span class=normal>2000</span>
<span class=normal>2001</span>
<span class=normal>2002</span>
<span class=normal>2003</span>
<span class=normal>2004</span>
<span class=normal>2005</span>
<span class=normal>2006</span>
<span class=normal>2007</span>
<span class=normal>2008</span>
<span class=normal>2009</span>
<span class=normal>2010</span>
<span class=normal>2011</span>
<span class=normal>2012</span>
<span class=normal>2013</span>
<span class=normal>2014</span>
<span class=normal>2015</span>
<span class=normal>2016</span>
<span class=normal>2017</span>
<span class=normal>2018</span>
<span class=normal>2019</span>
<span class=normal>2020</span>
<span class=normal>2021</span>
<span class=normal>2022</span>
<span class=normal>2023</span>
<span class=normal>2024</span>
<span class=normal>2025</span>
<span class=normal>2026</span>
<span class=normal>2027</span>
<span class=normal>2028</span>
<span class=normal>2029</span>
<span class=normal>2030</span>
<span class=normal>2031</span>
<span class=normal>2032</span>
<span class=normal>2033</span>
<span class=normal>2034</span>
<span class=normal>2035</span>
<span class=normal>2036</span>
<span class=normal>2037</span>
<span class=normal>2038</span>
<span class=normal>2039</span>
<span class=normal>2040</span>
<span class=normal>2041</span>
<span class=normal>2042</span>
<span class=normal>2043</span>
<span class=normal>2044</span>
<span class=normal>2045</span>
<span class=normal>2046</span>
<span class=normal>2047</span>
<span class=normal>2048</span>
<span class=normal>2049</span>
<span class=normal>2050</span>
<span class=normal>2051</span>
<span class=normal>2052</span>
<span class=normal>2053</span>
<span class=normal>2054</span>
<span class=normal>2055</span>
<span class=normal>2056</span>
<span class=normal>2057</span>
<span class=normal>2058</span>
<span class=normal>2059</span>
<span class=normal>2060</span>
<span class=normal>2061</span>
<span class=normal>2062</span>
<span class=normal>2063</span>
<span class=normal>2064</span>
<span class=normal>2065</span>
<span class=normal>2066</span>
<span class=normal>2067</span>
<span class=normal>2068</span>
<span class=normal>2069</span>
<span class=normal>2070</span>
<span class=normal>2071</span>
<span class=normal>2072</span>
<span class=normal>2073</span>
<span class=normal>2074</span>
<span class=normal>2075</span>
<span class=normal>2076</span>
<span class=normal>2077</span>
<span class=normal>2078</span>
<span class=normal>2079</span>
<span class=normal>2080</span>
<span class=normal>2081</span>
<span class=normal>2082</span>
<span class=normal>2083</span>
<span class=normal>2084</span>
<span class=normal>2085</span>
<span class=normal>2086</span>
<span class=normal>2087</span>
<span class=normal>2088</span>
<span class=normal>2089</span>
<span class=normal>2090</span>
<span class=normal>2091</span>
<span class=normal>2092</span>
<span class=normal>2093</span>
<span class=normal>2094</span>
<span class=normal>2095</span>
<span class=normal>2096</span>
<span class=normal>2097</span>
<span class=normal>2098</span>
<span class=normal>2099</span>
<span class=normal>2100</span>
<span class=normal>2101</span>
<span class=normal>2102</span>
<span class=normal>2103</span>
<span class=normal>2104</span>
<span class=normal>2105</span>
<span class=normal>2106</span>
<span class=normal>2107</span>
<span class=normal>2108</span>
<span class=normal>2109</span>
<span class=normal>2110</span>
<span class=normal>2111</span>
<span class=normal>2112</span>
<span class=normal>2113</span>
<span class=normal>2114</span>
<span class=normal>2115</span>
<span class=normal>2116</span>
<span class=normal>2117</span>
<span class=normal>2118</span>
<span class=normal>2119</span>
<span class=normal>2120</span>
<span class=normal>2121</span>
<span class=normal>2122</span>
<span class=normal>2123</span>
<span class=normal>2124</span>
<span class=normal>2125</span>
<span class=normal>2126</span>
<span class=normal>2127</span>
<span class=normal>2128</span>
<span class=normal>2129</span>
<span class=normal>2130</span>
<span class=normal>2131</span>
<span class=normal>2132</span>
<span class=normal>2133</span>
<span class=normal>2134</span>
<span class=normal>2135</span>
<span class=normal>2136</span>
<span class=normal>2137</span>
<span class=normal>2138</span>
<span class=normal>2139</span>
<span class=normal>2140</span>
<span class=normal>2141</span>
<span class=normal>2142</span>
<span class=normal>2143</span>
<span class=normal>2144</span>
<span class=normal>2145</span>
<span class=normal>2146</span>
<span class=normal>2147</span>
<span class=normal>2148</span>
<span class=normal>2149</span>
<span class=normal>2150</span>
<span class=normal>2151</span>
<span class=normal>2152</span>
<span class=normal>2153</span>
<span class=normal>2154</span>
<span class=normal>2155</span>
<span class=normal>2156</span>
<span class=normal>2157</span>
<span class=normal>2158</span>
<span class=normal>2159</span>
<span class=normal>2160</span>
<span class=normal>2161</span>
<span class=normal>2162</span>
<span class=normal>2163</span>
<span class=normal>2164</span>
<span class=normal>2165</span>
<span class=normal>2166</span>
<span class=normal>2167</span>
<span class=normal>2168</span>
<span class=normal>2169</span>
<span class=normal>2170</span>
<span class=normal>2171</span>
<span class=normal>2172</span>
<span class=normal>2173</span>
<span class=normal>2174</span>
<span class=normal>2175</span>
<span class=normal>2176</span>
<span class=normal>2177</span>
<span class=normal>2178</span>
<span class=normal>2179</span>
<span class=normal>2180</span>
<span class=normal>2181</span>
<span class=normal>2182</span>
<span class=normal>2183</span>
<span class=normal>2184</span>
<span class=normal>2185</span>
<span class=normal>2186</span>
<span class=normal>2187</span>
<span class=normal>2188</span>
<span class=normal>2189</span>
<span class=normal>2190</span>
<span class=normal>2191</span>
<span class=normal>2192</span>
<span class=normal>2193</span>
<span class=normal>2194</span>
<span class=normal>2195</span>
<span class=normal>2196</span>
<span class=normal>2197</span>
<span class=normal>2198</span>
<span class=normal>2199</span>
<span class=normal>2200</span>
<span class=normal>2201</span>
<span class=normal>2202</span>
<span class=normal>2203</span>
<span class=normal>2204</span>
<span class=normal>2205</span>
<span class=normal>2206</span>
<span class=normal>2207</span>
<span class=normal>2208</span>
<span class=normal>2209</span>
<span class=normal>2210</span>
<span class=normal>2211</span>
<span class=normal>2212</span>
<span class=normal>2213</span>
<span class=normal>2214</span>
<span class=normal>2215</span>
<span class=normal>2216</span>
<span class=normal>2217</span>
<span class=normal>2218</span>
<span class=normal>2219</span>
<span class=normal>2220</span>
<span class=normal>2221</span>
<span class=normal>2222</span>
<span class=normal>2223</span>
<span class=normal>2224</span>
<span class=normal>2225</span>
<span class=normal>2226</span>
<span class=normal>2227</span>
<span class=normal>2228</span>
<span class=normal>2229</span>
<span class=normal>2230</span>
<span class=normal>2231</span>
<span class=normal>2232</span>
<span class=normal>2233</span>
<span class=normal>2234</span>
<span class=normal>2235</span>
<span class=normal>2236</span>
<span class=normal>2237</span>
<span class=normal>2238</span>
<span class=normal>2239</span>
<span class=normal>2240</span>
<span class=normal>2241</span>
<span class=normal>2242</span>
<span class=normal>2243</span>
<span class=normal>2244</span>
<span class=normal>2245</span>
<span class=normal>2246</span>
<span class=normal>2247</span>
<span class=normal>2248</span>
<span class=normal>2249</span>
<span class=normal>2250</span>
<span class=normal>2251</span>
<span class=normal>2252</span>
<span class=normal>2253</span>
<span class=normal>2254</span>
<span class=normal>2255</span>
<span class=normal>2256</span>
<span class=normal>2257</span>
<span class=normal>2258</span>
<span class=normal>2259</span>
<span class=normal>2260</span>
<span class=normal>2261</span>
<span class=normal>2262</span>
<span class=normal>2263</span>
<span class=normal>2264</span>
<span class=normal>2265</span>
<span class=normal>2266</span>
<span class=normal>2267</span>
<span class=normal>2268</span>
<span class=normal>2269</span>
<span class=normal>2270</span>
<span class=normal>2271</span>
<span class=normal>2272</span>
<span class=normal>2273</span>
<span class=normal>2274</span>
<span class=normal>2275</span>
<span class=normal>2276</span>
<span class=normal>2277</span>
<span class=normal>2278</span>
<span class=normal>2279</span>
<span class=normal>2280</span>
<span class=normal>2281</span>
<span class=normal>2282</span>
<span class=normal>2283</span>
<span class=normal>2284</span>
<span class=normal>2285</span>
<span class=normal>2286</span>
<span class=normal>2287</span>
<span class=normal>2288</span>
<span class=normal>2289</span>
<span class=normal>2290</span>
<span class=normal>2291</span>
<span class=normal>2292</span>
<span class=normal>2293</span>
<span class=normal>2294</span>
<span class=normal>2295</span>
<span class=normal>2296</span>
<span class=normal>2297</span>
<span class=normal>2298</span>
<span class=normal>2299</span>
<span class=normal>2300</span>
<span class=normal>2301</span>
<span class=normal>2302</span>
<span class=normal>2303</span>
<span class=normal>2304</span>
<span class=normal>2305</span>
<span class=normal>2306</span>
<span class=normal>2307</span>
<span class=normal>2308</span>
<span class=normal>2309</span>
<span class=normal>2310</span>
<span class=normal>2311</span>
<span class=normal>2312</span>
<span class=normal>2313</span>
<span class=normal>2314</span>
<span class=normal>2315</span>
<span class=normal>2316</span>
<span class=normal>2317</span>
<span class=normal>2318</span>
<span class=normal>2319</span>
<span class=normal>2320</span>
<span class=normal>2321</span>
<span class=normal>2322</span>
<span class=normal>2323</span>
<span class=normal>2324</span>
<span class=normal>2325</span>
<span class=normal>2326</span>
<span class=normal>2327</span>
<span class=normal>2328</span>
<span class=normal>2329</span>
<span class=normal>2330</span>
<span class=normal>2331</span>
<span class=normal>2332</span>
<span class=normal>2333</span>
<span class=normal>2334</span>
<span class=normal>2335</span>
<span class=normal>2336</span>
<span class=normal>2337</span>
<span class=normal>2338</span>
<span class=normal>2339</span>
<span class=normal>2340</span>
<span class=normal>2341</span>
<span class=normal>2342</span>
<span class=normal>2343</span>
<span class=normal>2344</span>
<span class=normal>2345</span>
<span class=normal>2346</span>
<span class=normal>2347</span>
<span class=normal>2348</span>
<span class=normal>2349</span>
<span class=normal>2350</span>
<span class=normal>2351</span>
<span class=normal>2352</span>
<span class=normal>2353</span>
<span class=normal>2354</span>
<span class=normal>2355</span>
<span class=normal>2356</span>
<span class=normal>2357</span>
<span class=normal>2358</span>
<span class=normal>2359</span>
<span class=normal>2360</span>
<span class=normal>2361</span>
<span class=normal>2362</span>
<span class=normal>2363</span>
<span class=normal>2364</span>
<span class=normal>2365</span>
<span class=normal>2366</span>
<span class=normal>2367</span>
<span class=normal>2368</span>
<span class=normal>2369</span>
<span class=normal>2370</span>
<span class=normal>2371</span>
<span class=normal>2372</span>
<span class=normal>2373</span>
<span class=normal>2374</span>
<span class=normal>2375</span>
<span class=normal>2376</span>
<span class=normal>2377</span>
<span class=normal>2378</span>
<span class=normal>2379</span>
<span class=normal>2380</span>
<span class=normal>2381</span>
<span class=normal>2382</span>
<span class=normal>2383</span>
<span class=normal>2384</span>
<span class=normal>2385</span>
<span class=normal>2386</span>
<span class=normal>2387</span>
<span class=normal>2388</span>
<span class=normal>2389</span>
<span class=normal>2390</span>
<span class=normal>2391</span>
<span class=normal>2392</span>
<span class=normal>2393</span>
<span class=normal>2394</span>
<span class=normal>2395</span>
<span class=normal>2396</span>
<span class=normal>2397</span>
<span class=normal>2398</span>
<span class=normal>2399</span>
<span class=normal>2400</span>
<span class=normal>2401</span>
<span class=normal>2402</span>
<span class=normal>2403</span>
<span class=normal>2404</span>
<span class=normal>2405</span>
<span class=normal>2406</span>
<span class=normal>2407</span>
<span class=normal>2408</span>
<span class=normal>2409</span>
<span class=normal>2410</span>
<span class=normal>2411</span>
<span class=normal>2412</span>
<span class=normal>2413</span>
<span class=normal>2414</span>
<span class=normal>2415</span>
<span class=normal>2416</span>
<span class=normal>2417</span>
<span class=normal>2418</span>
<span class=normal>2419</span>
<span class=normal>2420</span>
<span class=normal>2421</span>
<span class=normal>2422</span>
<span class=normal>2423</span>
<span class=normal>2424</span>
<span class=normal>2425</span>
<span class=normal>2426</span>
<span class=normal>2427</span>
<span class=normal>2428</span>
<span class=normal>2429</span>
<span class=normal>2430</span>
<span class=normal>2431</span>
<span class=normal>2432</span>
<span class=normal>2433</span>
<span class=normal>2434</span>
<span class=normal>2435</span>
<span class=normal>2436</span>
<span class=normal>2437</span>
<span class=normal>2438</span>
<span class=normal>2439</span>
<span class=normal>2440</span>
<span class=normal>2441</span>
<span class=normal>2442</span>
<span class=normal>2443</span>
<span class=normal>2444</span>
<span class=normal>2445</span>
<span class=normal>2446</span>
<span class=normal>2447</span>
<span class=normal>2448</span>
<span class=normal>2449</span>
<span class=normal>2450</span>
<span class=normal>2451</span>
<span class=normal>2452</span>
<span class=normal>2453</span>
<span class=normal>2454</span>
<span class=normal>2455</span>
<span class=normal>2456</span>
<span class=normal>2457</span>
<span class=normal>2458</span>
<span class=normal>2459</span>
<span class=normal>2460</span>
<span class=normal>2461</span>
<span class=normal>2462</span>
<span class=normal>2463</span>
<span class=normal>2464</span>
<span class=normal>2465</span>
<span class=normal>2466</span>
<span class=normal>2467</span>
<span class=normal>2468</span>
<span class=normal>2469</span>
<span class=normal>2470</span>
<span class=normal>2471</span>
<span class=normal>2472</span>
<span class=normal>2473</span>
<span class=normal>2474</span>
<span class=normal>2475</span>
<span class=normal>2476</span>
<span class=normal>2477</span>
<span class=normal>2478</span>
<span class=normal>2479</span>
<span class=normal>2480</span>
<span class=normal>2481</span>
<span class=normal>2482</span>
<span class=normal>2483</span>
<span class=normal>2484</span>
<span class=normal>2485</span>
<span class=normal>2486</span>
<span class=normal>2487</span>
<span class=normal>2488</span>
<span class=normal>2489</span>
<span class=normal>2490</span>
<span class=normal>2491</span>
<span class=normal>2492</span>
<span class=normal>2493</span>
<span class=normal>2494</span>
<span class=normal>2495</span>
<span class=normal>2496</span>
<span class=normal>2497</span>
<span class=normal>2498</span>
<span class=normal>2499</span>
<span class=normal>2500</span>
<span class=normal>2501</span>
<span class=normal>2502</span>
<span class=normal>2503</span>
<span class=normal>2504</span>
<span class=normal>2505</span>
<span class=normal>2506</span>
<span class=normal>2507</span>
<span class=normal>2508</span>
<span class=normal>2509</span>
<span class=normal>2510</span>
<span class=normal>2511</span>
<span class=normal>2512</span>
<span class=normal>2513</span>
<span class=normal>2514</span>
<span class=normal>2515</span>
<span class=normal>2516</span>
<span class=normal>2517</span>
<span class=normal>2518</span>
<span class=normal>2519</span>
<span class=normal>2520</span>
<span class=normal>2521</span>
<span class=normal>2522</span>
<span class=normal>2523</span>
<span class=normal>2524</span>
<span class=normal>2525</span>
<span class=normal>2526</span>
<span class=normal>2527</span>
<span class=normal>2528</span>
<span class=normal>2529</span>
<span class=normal>2530</span>
<span class=normal>2531</span>
<span class=normal>2532</span>
<span class=normal>2533</span>
<span class=normal>2534</span>
<span class=normal>2535</span>
<span class=normal>2536</span>
<span class=normal>2537</span>
<span class=normal>2538</span>
<span class=normal>2539</span>
<span class=normal>2540</span>
<span class=normal>2541</span>
<span class=normal>2542</span>
<span class=normal>2543</span>
<span class=normal>2544</span>
<span class=normal>2545</span>
<span class=normal>2546</span>
<span class=normal>2547</span>
<span class=normal>2548</span>
<span class=normal>2549</span>
<span class=normal>2550</span>
<span class=normal>2551</span>
<span class=normal>2552</span>
<span class=normal>2553</span>
<span class=normal>2554</span>
<span class=normal>2555</span>
<span class=normal>2556</span>
<span class=normal>2557</span>
<span class=normal>2558</span>
<span class=normal>2559</span>
<span class=normal>2560</span>
<span class=normal>2561</span>
<span class=normal>2562</span>
<span class=normal>2563</span>
<span class=normal>2564</span>
<span class=normal>2565</span>
<span class=normal>2566</span>
<span class=normal>2567</span>
<span class=normal>2568</span>
<span class=normal>2569</span>
<span class=normal>2570</span>
<span class=normal>2571</span>
<span class=normal>2572</span>
<span class=normal>2573</span>
<span class=normal>2574</span>
<span class=normal>2575</span>
<span class=normal>2576</span>
<span class=normal>2577</span>
<span class=normal>2578</span>
<span class=normal>2579</span>
<span class=normal>2580</span>
<span class=normal>2581</span>
<span class=normal>2582</span>
<span class=normal>2583</span>
<span class=normal>2584</span>
<span class=normal>2585</span>
<span class=normal>2586</span>
<span class=normal>2587</span>
<span class=normal>2588</span>
<span class=normal>2589</span>
<span class=normal>2590</span>
<span class=normal>2591</span>
<span class=normal>2592</span>
<span class=normal>2593</span>
<span class=normal>2594</span>
<span class=normal>2595</span>
<span class=normal>2596</span>
<span class=normal>2597</span>
<span class=normal>2598</span>
<span class=normal>2599</span>
<span class=normal>2600</span>
<span class=normal>2601</span>
<span class=normal>2602</span>
<span class=normal>2603</span>
<span class=normal>2604</span>
<span class=normal>2605</span>
<span class=normal>2606</span>
<span class=normal>2607</span>
<span class=normal>2608</span>
<span class=normal>2609</span>
<span class=normal>2610</span>
<span class=normal>2611</span>
<span class=normal>2612</span>
<span class=normal>2613</span>
<span class=normal>2614</span>
<span class=normal>2615</span>
<span class=normal>2616</span>
<span class=normal>2617</span>
<span class=normal>2618</span>
<span class=normal>2619</span>
<span class=normal>2620</span>
<span class=normal>2621</span>
<span class=normal>2622</span>
<span class=normal>2623</span>
<span class=normal>2624</span>
<span class=normal>2625</span>
<span class=normal>2626</span>
<span class=normal>2627</span>
<span class=normal>2628</span>
<span class=normal>2629</span>
<span class=normal>2630</span>
<span class=normal>2631</span>
<span class=normal>2632</span>
<span class=normal>2633</span>
<span class=normal>2634</span>
<span class=normal>2635</span>
<span class=normal>2636</span>
<span class=normal>2637</span>
<span class=normal>2638</span>
<span class=normal>2639</span>
<span class=normal>2640</span>
<span class=normal>2641</span>
<span class=normal>2642</span>
<span class=normal>2643</span>
<span class=normal>2644</span>
<span class=normal>2645</span>
<span class=normal>2646</span>
<span class=normal>2647</span>
<span class=normal>2648</span>
<span class=normal>2649</span>
<span class=normal>2650</span>
<span class=normal>2651</span>
<span class=normal>2652</span>
<span class=normal>2653</span>
<span class=normal>2654</span>
<span class=normal>2655</span>
<span class=normal>2656</span>
<span class=normal>2657</span>
<span class=normal>2658</span>
<span class=normal>2659</span>
<span class=normal>2660</span>
<span class=normal>2661</span>
<span class=normal>2662</span>
<span class=normal>2663</span>
<span class=normal>2664</span>
<span class=normal>2665</span>
<span class=normal>2666</span>
<span class=normal>2667</span>
<span class=normal>2668</span>
<span class=normal>2669</span>
<span class=normal>2670</span>
<span class=normal>2671</span>
<span class=normal>2672</span>
<span class=normal>2673</span>
<span class=normal>2674</span>
<span class=normal>2675</span>
<span class=normal>2676</span>
<span class=normal>2677</span>
<span class=normal>2678</span>
<span class=normal>2679</span>
<span class=normal>2680</span>
<span class=normal>2681</span>
<span class=normal>2682</span>
<span class=normal>2683</span>
<span class=normal>2684</span>
<span class=normal>2685</span>
<span class=normal>2686</span>
<span class=normal>2687</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>class</span><span class=w> </span><span class=nc>RegularlySampledAnalogSignalArray</span><span class=p>:</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Continuous analog signal(s) with regular sampling rates (irregular</span>
<span class=sd>    sampling rates can be corrected with operations on the support) and same</span>
<span class=sd>    support. NOTE: data that is not equal dimensionality will NOT work</span>
<span class=sd>    and error/warning messages may/may not be sent out. Assumes abscissa_vals</span>
<span class=sd>    are identical for all signals passed through and are therefore expected</span>
<span class=sd>    to be 1-dimensional.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray, with shape (n_signals, n_samples).</span>
<span class=sd>        Data samples.</span>
<span class=sd>    abscissa_vals : np.ndarray, with shape (n_samples, ).</span>
<span class=sd>        The abscissa coordinate values. Currently we assume that (1) these values</span>
<span class=sd>        are timestamps, and (2) the timestamps are sampled regularly (we rely on</span>
<span class=sd>        these assumptions to generate intervals). Irregular sampling rates can be</span>
<span class=sd>        corrected with operations on the support.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        The sampling rate. abscissa_vals are still expected to be in units of</span>
<span class=sd>        time and fs is expected to be in the corresponding sampling rate (e.g.</span>
<span class=sd>        abscissa_vals in seconds, fs in Hz).</span>
<span class=sd>        Default is 1 Hz.</span>
<span class=sd>    step : float, optional</span>
<span class=sd>        The sampling interval of the data, in seconds.</span>
<span class=sd>        Default is None.</span>
<span class=sd>        specifies step size of samples passed as tdata if fs is given,</span>
<span class=sd>        default is None. If not passed it is inferred by the minimum</span>
<span class=sd>        difference in between samples of tdata passed in (based on if FS</span>
<span class=sd>        is passed). e.g. decimated data would have sample numbers every</span>
<span class=sd>        ten samples so step=10</span>
<span class=sd>    merge_sample_gap : float, optional</span>
<span class=sd>        Optional merging of gaps between support intervals. If intervals are within</span>
<span class=sd>        a certain amount of time, gap, they will be merged as one interval. Example</span>
<span class=sd>        use case is when there is a dropped sample</span>
<span class=sd>    support : nelpy.IntervalArray, optional</span>
<span class=sd>        Where the data are defined. Default is [0, last abscissa value] inclusive.</span>
<span class=sd>    in_core : bool, optional</span>
<span class=sd>        Whether the abscissa values should be treated as residing in core memory.</span>
<span class=sd>        During RSASA construction, np.diff() is called, so for large data, passing</span>
<span class=sd>        in in_core=True might help. In that case, a slower but much smaller memory</span>
<span class=sd>        footprint function is used.</span>
<span class=sd>    labels : np.array, dtype=np.str</span>
<span class=sd>        Labels for each of the signals. If fewer labels than signals are passed in,</span>
<span class=sd>        labels are padded with None&#39;s to match the number of signals. If more labels</span>
<span class=sd>        than signals are passed in, labels are truncated to match the number of</span>
<span class=sd>        signals.</span>
<span class=sd>        Default is None.</span>
<span class=sd>    empty : bool, optional</span>
<span class=sd>        Return an empty RegularlySampledAnalogSignalArray if true else false.</span>
<span class=sd>        Default is false.</span>
<span class=sd>    abscissa : optional</span>
<span class=sd>        The object handling the abscissa values. It is recommended to leave</span>
<span class=sd>        this parameter alone and let nelpy take care of this.</span>
<span class=sd>        Default is a nelpy.core.Abscissa object.</span>
<span class=sd>    ordinate : optional</span>
<span class=sd>        The object handling the ordinate values. It is recommended to leave</span>
<span class=sd>        this parameter alone and let nelpy take care of this.</span>
<span class=sd>        Default is a nelpy.core.Ordinate object.</span>

<span class=sd>    Attributes</span>
<span class=sd>    ----------</span>
<span class=sd>    data : np.ndarray, with shape (n_signals, n_samples)</span>
<span class=sd>        The underlying data.</span>
<span class=sd>    abscissa_vals : np.ndarray, with shape (n_samples, )</span>
<span class=sd>        The values of the abscissa coordinate.</span>
<span class=sd>    is1d : bool</span>
<span class=sd>        Whether there is only 1 signal in the RSASA</span>
<span class=sd>    iswrapped : bool</span>
<span class=sd>        Whether the RSASA&#39;s data is wrapping.</span>
<span class=sd>    base_unit : string</span>
<span class=sd>        Base unit of the abscissa.</span>
<span class=sd>    signals : list</span>
<span class=sd>        A list of RegularlySampledAnalogSignalArrays, each RSASA containing</span>
<span class=sd>        a single signal (channel).</span>
<span class=sd>        WARNING: this method creates a copy of each signal, so is not</span>
<span class=sd>        particularly efficient at this time.</span>
<span class=sd>    isreal : bool</span>
<span class=sd>        Whether ALL of the values in the RSASA&#39;s data are real.</span>
<span class=sd>    iscomplex : bool</span>
<span class=sd>        Whether ANY values in the data are complex.</span>
<span class=sd>    abs : nelpy.RegularlySampledAnalogSignalArray</span>
<span class=sd>        A copy of the RSASA, whose data is the absolute value of the original</span>
<span class=sd>        original RSASA&#39;s (potentially complex) data.</span>
<span class=sd>    phase : nelpy.RegularlySampledAnalogSignalArray</span>
<span class=sd>        A copy of the RSASA, whose data is just the phase angle (in radians) of</span>
<span class=sd>        the original RSASA&#39;s data.</span>
<span class=sd>    real : nelpy.RegularlySampledAnalogSignalArray</span>
<span class=sd>        A copy of the RSASA, whose data is just the real part of the original</span>
<span class=sd>        RSASA&#39;s data.</span>
<span class=sd>    imag : nelpy.RegularlySampledAnalogSignalArray</span>
<span class=sd>        A copy of the RSASA, whose data is just the imaginary part of the</span>
<span class=sd>        original RSASA&#39;s data.</span>
<span class=sd>    lengths : list</span>
<span class=sd>        The number of samples in each interval.</span>
<span class=sd>    labels : list</span>
<span class=sd>        The labels corresponding to each signal.</span>
<span class=sd>    n_signals : int</span>
<span class=sd>        The number of signals in the RSASA.</span>
<span class=sd>    support : nelpy.IntervalArray</span>
<span class=sd>        The support of the RSASA.</span>
<span class=sd>    domain : nelpy.IntervalArray</span>
<span class=sd>        The domain of the RSASA.</span>
<span class=sd>    range : nelpy.IntervalArray</span>
<span class=sd>        The range of the RSASA&#39;s data.</span>
<span class=sd>    step : float</span>
<span class=sd>        The sampling interval of the RSASA. Currently the units are</span>
<span class=sd>        in seconds.</span>
<span class=sd>    fs : float</span>
<span class=sd>        The sampling frequency of the RSASA. Currently the units are</span>
<span class=sd>        in Hz.</span>
<span class=sd>    isempty : bool</span>
<span class=sd>        Whether the underlying data has zero length, i.e. 0 samples</span>
<span class=sd>    n_bytes : int</span>
<span class=sd>        Approximate number of bytes taken up by the RSASA.</span>
<span class=sd>    n_intervals : int</span>
<span class=sd>        The number of underlying intervals in the RSASA.</span>
<span class=sd>    n_samples : int</span>
<span class=sd>        The number of abscissa values in the RSASA.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>__aliases__</span> <span class=o>=</span> <span class=p>{}</span>

    <span class=n>__attributes__</span> <span class=o>=</span> <span class=p>[</span>
        <span class=s2>&quot;_data&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_abscissa_vals&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_fs&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_support&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_interp&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_step&quot;</span><span class=p>,</span>
        <span class=s2>&quot;_labels&quot;</span><span class=p>,</span>
    <span class=p>]</span>

    <span class=nd>@rsasa_init_wrapper</span>
    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>data</span><span class=o>=</span><span class=p>[],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>abscissa_vals</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>step</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>merge_sample_gap</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span>
        <span class=n>support</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>in_core</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
        <span class=n>labels</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>empty</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=n>abscissa</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>ordinate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervalsignalslicer</span> <span class=o>=</span> <span class=n>IntervalSignalSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervaldata</span> <span class=o>=</span> <span class=n>DataSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervaltime</span> <span class=o>=</span> <span class=n>AbscissaSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>type_name</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=vm>__name__</span>
        <span class=k>if</span> <span class=n>abscissa</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>abscissa</span> <span class=o>=</span> <span class=n>core</span><span class=o>.</span><span class=n>Abscissa</span><span class=p>()</span>  <span class=c1># TODO: integrate into constructor?</span>
        <span class=k>if</span> <span class=n>ordinate</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>ordinate</span> <span class=o>=</span> <span class=n>core</span><span class=o>.</span><span class=n>Ordinate</span><span class=p>()</span>  <span class=c1># TODO: integrate into constructor?</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span> <span class=o>=</span> <span class=n>abscissa</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span> <span class=o>=</span> <span class=n>ordinate</span>

        <span class=c1># TODO: #FIXME abscissa and ordinate domain, range, and supports should be integrated and/or coerced with support</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>__version__</span> <span class=o>=</span> <span class=n>version</span><span class=o>.</span><span class=n>__version__</span>

        <span class=c1># cast derivatives of RegularlySampledAnalogSignalArray back into RegularlySampledAnalogSignalArray:</span>
        <span class=c1># if isinstance(data, auxiliary.PositionArray):</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=bp>self</span><span class=o>.</span><span class=vm>__dict__</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=n>data</span><span class=o>.</span><span class=vm>__dict__</span><span class=p>)</span>
            <span class=c1># if self._has_changed:</span>
            <span class=c1># self.__renew__()</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
            <span class=k>return</span>

        <span class=k>if</span> <span class=n>empty</span><span class=p>:</span>
            <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>__attributes__</span><span class=p>:</span>
                <span class=n>exec</span><span class=p>(</span><span class=s2>&quot;self.&quot;</span> <span class=o>+</span> <span class=n>attr</span> <span class=o>+</span> <span class=s2>&quot; = None&quot;</span><span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>__bake__</span><span class=p>()</span>
            <span class=k>return</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_step</span> <span class=o>=</span> <span class=n>step</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_fs</span> <span class=o>=</span> <span class=n>fs</span>

        <span class=c1># Note; if we have an empty array of data with no dimension,</span>
        <span class=c1># then calling len(data) will return a TypeError</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=c1># if no data are given return empty RegularlySampledAnalogSignalArray</span>
            <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
                <span class=k>return</span>
        <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;unsupported type; creating empty RegularlySampledAnalogSignalArray&quot;</span>
            <span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
            <span class=k>return</span>

        <span class=c1># Note: if both abscissa_vals and data are given and dimensionality does not</span>
        <span class=c1># match, then TypeError!</span>

        <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>float</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>abscissa_vals</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
            <span class=c1># self.__init__([],empty=True)</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;abscissa_vals and data size mismatch! Note: data &quot;</span>
                <span class=s2>&quot;is expected to have rows containing signals&quot;</span>
            <span class=p>)</span>
        <span class=c1># data is not sorted and user wants it to be</span>
        <span class=c1># TODO: use faster is_sort from jagular</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>utils</span><span class=o>.</span><span class=n>is_sorted</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>):</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;Data is _not_ sorted! Data will be sorted automatically.&quot;</span><span class=p>)</span>
            <span class=n>ind</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>)</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>abscissa_vals</span><span class=p>[</span><span class=n>ind</span><span class=p>]</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>take</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=n>data</span><span class=p>,</span> <span class=n>indices</span><span class=o>=</span><span class=n>ind</span><span class=p>,</span> <span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>data</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>abscissa_vals</span>

        <span class=c1># handle labels</span>
        <span class=k>if</span> <span class=n>labels</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>labels</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>labels</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=nb>str</span><span class=p>)</span>
            <span class=c1># label size doesn&#39;t match</span>
            <span class=k>if</span> <span class=n>labels</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                    <span class=s2>&quot;More labels than data! Labels are truncated to size of data&quot;</span>
                <span class=p>)</span>
                <span class=n>labels</span> <span class=o>=</span> <span class=n>labels</span><span class=p>[</span><span class=mi>0</span> <span class=p>:</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
            <span class=k>elif</span> <span class=n>labels</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                    <span class=s2>&quot;Fewer labels than abscissa_vals! Labels are filled with &quot;</span>
                    <span class=s2>&quot;None to match data shape&quot;</span>
                <span class=p>)</span>
                <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>labels</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
                    <span class=n>labels</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_labels</span> <span class=o>=</span> <span class=n>labels</span>

        <span class=c1># Alright, let&#39;s handle all the possible parameter cases!</span>
        <span class=k>if</span> <span class=n>support</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=n>intervalarray</span><span class=o>=</span><span class=n>support</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;creating support from abscissa_vals and sampling rate, fs!&quot;</span>
            <span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span>
                <span class=n>utils</span><span class=o>.</span><span class=n>get_contiguous_segments</span><span class=p>(</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>,</span> <span class=n>step</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_step</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=n>fs</span><span class=p>,</span> <span class=n>in_core</span><span class=o>=</span><span class=n>in_core</span>
                <span class=p>)</span>
            <span class=p>)</span>
            <span class=k>if</span> <span class=n>merge_sample_gap</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>merge</span><span class=p>(</span>
                    <span class=n>gap</span><span class=o>=</span><span class=n>merge_sample_gap</span>
                <span class=p>)</span>

        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>((</span><span class=bp>self</span><span class=o>.</span><span class=n>fs</span> <span class=o>-</span> <span class=bp>self</span><span class=o>.</span><span class=n>_estimate_fs</span><span class=p>())</span> <span class=o>/</span> <span class=bp>self</span><span class=o>.</span><span class=n>fs</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mf>0.01</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;estimated fs and provided fs differ by more than 1%&quot;</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>__bake__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Fix object as-is, and bake a new hash.</span>

<span class=sd>        For example, if a label has changed, or if an interp has been attached,</span>
<span class=sd>        then the object&#39;s hash will change, and it needs to be baked</span>
<span class=sd>        again for efficiency / consistency.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_stored_hash_</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=fm>__hash__</span><span class=p>()</span>

    <span class=c1># def _has_changed_data(self):</span>
    <span class=c1>#     &quot;&quot;&quot;Compute hash on abscissa_vals and data and compare to cached hash.&quot;&quot;&quot;</span>
    <span class=c1>#     return self.data.__hash__ elf._data_hash_</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_has_changed</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Compute hash on current object, and compare to previously stored hash&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=fm>__hash__</span><span class=p>()</span> <span class=o>==</span> <span class=bp>self</span><span class=o>.</span><span class=n>_stored_hash_</span>

    <span class=k>def</span><span class=w> </span><span class=nf>__renew__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Re-attach data slicers.&quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervalsignalslicer</span> <span class=o>=</span> <span class=n>IntervalSignalSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervaldata</span> <span class=o>=</span> <span class=n>DataSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_intervaltime</span> <span class=o>=</span> <span class=n>AbscissaSlicer</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__bake__</span><span class=p>()</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__call__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray callable method. Returns</span>
<span class=sd>        interpolated data at requested points. Note that points falling</span>
<span class=sd>        outside the support will not be interpolated.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        x : np.ndarray, list, or tuple, with length n_requested_samples</span>
<span class=sd>            Points at which to interpolate the RSASA&#39;s data</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        A np.ndarray with shape (n_signals, n_samples). If all the requested</span>
<span class=sd>        points lie in the support, then n_samples = n_requested_samples.</span>
<span class=sd>        Otherwise n_samples &lt; n_requested_samples.</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=n>x</span><span class=p>)</span><span class=o>.</span><span class=n>yvals</span>

    <span class=k>def</span><span class=w> </span><span class=nf>center</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Center the data to have zero mean along the sample axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        inplace : bool, optional</span>
<span class=sd>            If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The centered signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; centered = asa.center()</span>
<span class=sd>        &gt;&gt;&gt; centered.mean()</span>
<span class=sd>        0.0</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span><span class=o>.</span><span class=n>T</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>normalize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Normalize the data to have unit standard deviation along the sample axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        inplace : bool, optional</span>
<span class=sd>            If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The normalized signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; normalized = asa.normalize()</span>
<span class=sd>        &gt;&gt;&gt; normalized.std()</span>
<span class=sd>        1.0</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>std</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>std</span><span class=p>())</span>
        <span class=n>std</span><span class=p>[</span><span class=n>std</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>std</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>standardize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Standardize the data to zero mean and unit standard deviation along the sample axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        inplace : bool, optional</span>
<span class=sd>            If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The standardized signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; standardized = asa.standardize()</span>
<span class=sd>        &gt;&gt;&gt; standardized.mean(), standardized.std()</span>
<span class=sd>        (0.0, 1.0)</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span><span class=o>.</span><span class=n>T</span>
        <span class=n>std</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>std</span><span class=p>())</span>
        <span class=n>std</span><span class=p>[</span><span class=n>std</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>std</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>is_1d</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>==</span> <span class=mi>1</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>return</span> <span class=kc>False</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>is_wrapped</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>max</span><span class=p>()</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span> <span class=o>|</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>min</span><span class=p>()</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span>
        <span class=p>):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>_is_wrapped</span> <span class=o>=</span> <span class=kc>False</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>_is_wrapped</span> <span class=o>=</span> <span class=kc>True</span>

        <span class=c1># if self._ordinate._is_wrapped is None:</span>
        <span class=c1>#     if np.any(self.max() &gt; self._ordinate.range.stop) | np.any(self.min() &lt; self._ordinate.range.min):</span>
        <span class=c1>#         self._ordinate._is_wrapped = False</span>
        <span class=c1>#     else:</span>
        <span class=c1>#         self._ordinate._is_wrapped = True</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>_is_wrapped</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_wrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>arr</span><span class=p>,</span> <span class=n>vmin</span><span class=p>,</span> <span class=n>vmax</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Wrap array within finite range.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>isinf</span><span class=p>(</span><span class=n>vmax</span> <span class=o>-</span> <span class=n>vmin</span><span class=p>):</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;range has to be finite!&quot;</span><span class=p>)</span>
        <span class=k>return</span> <span class=p>((</span><span class=n>arr</span> <span class=o>-</span> <span class=n>vmin</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=n>vmax</span> <span class=o>-</span> <span class=n>vmin</span><span class=p>))</span> <span class=o>+</span> <span class=n>vmin</span>

    <span class=k>def</span><span class=w> </span><span class=nf>wrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Wrap the ordinate values within the finite range defined by the ordinate&#39;s range.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        inplace : bool, optional</span>
<span class=sd>            If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The wrapped signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; wrapped = asa.wrap()</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

        <span class=n>out</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span>
            <span class=n>out</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=c1># out._is_wrapped = True</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_unwrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>arr</span><span class=p>,</span> <span class=n>vmin</span><span class=p>,</span> <span class=n>vmax</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Unwrap 2D array (with one signal per row) by minimizing total displacement.&quot;&quot;&quot;</span>
        <span class=n>d</span> <span class=o>=</span> <span class=n>vmax</span> <span class=o>-</span> <span class=n>vmin</span>
        <span class=n>dh</span> <span class=o>=</span> <span class=n>d</span> <span class=o>/</span> <span class=mi>2</span>

        <span class=n>lin</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=n>vmin</span>
        <span class=n>n_signals</span><span class=p>,</span> <span class=n>n_samples</span> <span class=o>=</span> <span class=n>arr</span><span class=o>.</span><span class=n>shape</span>
        <span class=k>for</span> <span class=n>ii</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n_samples</span><span class=p>):</span>
            <span class=n>h1</span> <span class=o>=</span> <span class=n>lin</span><span class=p>[:,</span> <span class=n>ii</span><span class=p>]</span> <span class=o>-</span> <span class=n>lin</span><span class=p>[:,</span> <span class=n>ii</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>dh</span>
            <span class=n>lin</span><span class=p>[</span><span class=n>h1</span><span class=p>,</span> <span class=n>ii</span><span class=p>:]</span> <span class=o>=</span> <span class=n>lin</span><span class=p>[</span><span class=n>h1</span><span class=p>,</span> <span class=n>ii</span><span class=p>:]</span> <span class=o>-</span> <span class=n>d</span>
            <span class=n>h2</span> <span class=o>=</span> <span class=n>lin</span><span class=p>[:,</span> <span class=n>ii</span><span class=p>]</span> <span class=o>-</span> <span class=n>lin</span><span class=p>[:,</span> <span class=n>ii</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=o>-</span><span class=n>dh</span>
            <span class=n>lin</span><span class=p>[</span><span class=n>h2</span><span class=p>,</span> <span class=n>ii</span><span class=p>:]</span> <span class=o>=</span> <span class=n>lin</span><span class=p>[</span><span class=n>h2</span><span class=p>,</span> <span class=n>ii</span><span class=p>:]</span> <span class=o>+</span> <span class=n>d</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span><span class=n>lin</span> <span class=o>+</span> <span class=n>vmin</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>unwrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Unwrap the ordinate values by minimizing total displacement, useful for phase data.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        inplace : bool, optional</span>
<span class=sd>            If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The unwrapped signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; unwrapped = asa.unwrap()</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

        <span class=n>out</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span>
            <span class=n>out</span><span class=o>.</span><span class=n>_unwrap</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=c1># out._is_wrapped = False</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_crossvals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Return all abscissa values where the orinate crosses.</span>

<span class=sd>        Note that this can return multiple values close in succession</span>
<span class=sd>        if the signal oscillates around the maximum or minimum range.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>base_unit</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Base unit of the abscissa.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>base_unit</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_data_interval_indices</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Get the start and stop indices for each interval in the analog signal array.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        indices : np.ndarray</span>
<span class=sd>            Array of shape (n_intervals, 2), where each row contains the start and stop indices for an interval.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>tmp</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>lengths</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>((</span><span class=n>tmp</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>tmp</span><span class=p>[</span><span class=mi>1</span><span class=p>:]))</span><span class=o>.</span><span class=n>T</span>
        <span class=k>return</span> <span class=n>indices</span>

    <span class=k>def</span><span class=w> </span><span class=nf>ddt</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>rectify</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns the derivative of each signal in the RegularlySampledAnalogSignalArray.</span>

<span class=sd>        asa.data = f(t)</span>
<span class=sd>        asa.ddt = d/dt (asa.data)</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        rectify : boolean, optional</span>
<span class=sd>            If True, the absolute value of the derivative will be returned.</span>
<span class=sd>            Default is False.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        ddt : RegularlySampledAnalogSignalArray</span>
<span class=sd>            Time derivative of each signal in the RegularlySampledAnalogSignalArray.</span>

<span class=sd>        Note</span>
<span class=sd>        ----</span>
<span class=sd>        Second order central differences are used here, and it is assumed that</span>
<span class=sd>        the signals are sampled uniformly. If the signals are not uniformly</span>
<span class=sd>        sampled, it is recommended to resample the signal before computing the</span>
<span class=sd>        derivative.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>ddt</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>ddt_asa</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>rectify</span><span class=o>=</span><span class=n>rectify</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>ddt</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>signals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns a list of RegularlySampledAnalogSignalArrays, each array containing</span>
<span class=sd>        a single signal (channel).</span>

<span class=sd>        WARNING: this method creates a copy of each signal, so is not</span>
<span class=sd>        particularly efficient at this time.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; for channel in lfp.signals:</span>
<span class=sd>            print(channel)</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>signals</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>ii</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span><span class=p>):</span>
            <span class=n>signals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=bp>self</span><span class=p>[:,</span> <span class=n>ii</span><span class=p>])</span>
        <span class=k>return</span> <span class=n>signals</span>
        <span class=c1># return np.asanyarray(signals).squeeze()</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>isreal</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns True if entire signal is real.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>all</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>isreal</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=c1># return np.isrealobj(self._data)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>iscomplex</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns True if any part of the signal is complex.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>iscomplex</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=c1># return np.iscomplexobj(self._data)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>abs</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray with absolute value of (potentially complex) data.&quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>angle</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray with only phase angle (in radians) of data.&quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>angle</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>imag</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray with only imaginary part of data.&quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>imag</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>real</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray with only real part of data.&quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>real</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__mul__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;overloaded * operator.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>*</span> <span class=n>other</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span> <span class=o>*</span> <span class=n>other</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=k>if</span> <span class=p>(</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span>
                <span class=ow>or</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>)</span>
                <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>fs</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>fs</span>
            <span class=p>):</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                    <span class=s2>&quot;AnalogSignalArrays must have the same shape, abscissa_vals, and fs to multiply.&quot;</span>
                <span class=p>)</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>*</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for *: &#39;RegularlySampledAnalogSignalArray&#39; and &#39;</span><span class=si>{}</span><span class=s2>&#39;&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>other</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__add__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;overloaded + operator.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>+</span> <span class=n>other</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span> <span class=o>+</span> <span class=n>other</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=k>if</span> <span class=p>(</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span>
                <span class=ow>or</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>)</span>
                <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>fs</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>fs</span>
            <span class=p>):</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                    <span class=s2>&quot;AnalogSignalArrays must have the same shape, abscissa_vals, and fs to add.&quot;</span>
                <span class=p>)</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for +: &#39;RegularlySampledAnalogSignalArray&#39; and &#39;</span><span class=si>{}</span><span class=s2>&#39;&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>other</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__sub__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;overloaded - operator.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>-</span> <span class=n>other</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>other</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=k>if</span> <span class=p>(</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span>
                <span class=ow>or</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>)</span>
                <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>fs</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>fs</span>
            <span class=p>):</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                    <span class=s2>&quot;AnalogSignalArrays must have the same shape, abscissa_vals, and fs to subtract.&quot;</span>
                <span class=p>)</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>-</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for -: &#39;RegularlySampledAnalogSignalArray&#39; and &#39;</span><span class=si>{}</span><span class=s2>&#39;&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>other</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>zscore</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Normalize each signal in the array using z-scores (zero mean, unit variance).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            New object with z-scored data.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; zscored = asa.zscore()</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>zscore</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__truediv__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;overloaded / operator.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>/</span> <span class=n>other</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>):</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>other</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=k>if</span> <span class=p>(</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span>
                <span class=ow>or</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>allclose</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>abscissa_vals</span><span class=p>)</span>
                <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>fs</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>fs</span>
            <span class=p>):</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                    <span class=s2>&quot;AnalogSignalArrays must have the same shape, abscissa_vals, and fs to divide.&quot;</span>
                <span class=p>)</span>
            <span class=n>newasa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>newasa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>/</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span>
            <span class=k>return</span> <span class=n>newasa</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for /: &#39;RegularlySampledAnalogSignalArray&#39; and &#39;</span><span class=si>{}</span><span class=s2>&#39;&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>other</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__rmul__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=fm>__mul__</span><span class=p>(</span><span class=n>other</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__lshift__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;shift abscissa and support to left (&lt;&lt;)&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>new</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>new</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>-=</span> <span class=n>val</span>
            <span class=n>new</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>new</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>&lt;&lt;</span> <span class=n>val</span>
            <span class=k>return</span> <span class=n>new</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for &lt;&lt;: </span><span class=si>{}</span><span class=s2> and </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)),</span> <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>val</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__rshift__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;shift abscissa and support to right (&gt;&gt;)&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=n>numbers</span><span class=o>.</span><span class=n>Number</span><span class=p>):</span>
            <span class=n>new</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=n>new</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>+=</span> <span class=n>val</span>
            <span class=n>new</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>new</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>&gt;&gt;</span> <span class=n>val</span>
            <span class=k>return</span> <span class=n>new</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;unsupported operand type(s) for &gt;&gt;: </span><span class=si>{}</span><span class=s2> and </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)),</span> <span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>val</span><span class=p>))</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__len__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_intervals</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_drop_empty_intervals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Drops empty intervals from support. In-place.&quot;&quot;&quot;</span>
        <span class=n>keep_interval_ids</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argwhere</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>lengths</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>keep_interval_ids</span><span class=p>]</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_estimate_fs</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>abscissa_vals</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Estimate the sampling rate of the data.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>abscissa_vals</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span>
        <span class=k>return</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>median</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>))</span>

    <span class=k>def</span><span class=w> </span><span class=nf>downsample</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs_out</span><span class=p>,</span> <span class=n>aafilter</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Downsamples the RegularlySampledAnalogSignalArray</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        fs_out : float, optional</span>
<span class=sd>            Desired output sampling rate in Hz</span>
<span class=sd>        aafilter : boolean, optional</span>
<span class=sd>            Whether to apply an anti-aliasing filter before performing the actual</span>
<span class=sd>            downsampling. Default is True</span>
<span class=sd>        inplace : boolean, optional</span>
<span class=sd>            If True, the output ASA will replace the input ASA. Default is False</span>
<span class=sd>        kwargs :</span>
<span class=sd>            Other keyword arguments are passed to sosfiltfilt() in the `filtering`</span>
<span class=sd>            module</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            The downsampled RegularlySampledAnalogSignalArray</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=ow>not</span> <span class=n>fs_out</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_fs</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;fs_out must be less than current sampling rate!&quot;</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>aafilter</span><span class=p>:</span>
            <span class=n>fh</span> <span class=o>=</span> <span class=n>fs_out</span> <span class=o>/</span> <span class=mf>2.0</span>
            <span class=n>out</span> <span class=o>=</span> <span class=n>filtering</span><span class=o>.</span><span class=n>sosfiltfilt</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>fl</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>fh</span><span class=o>=</span><span class=n>fh</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=n>inplace</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

        <span class=n>downsampled</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=mi>1</span> <span class=o>/</span> <span class=n>fs_out</span><span class=p>)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>downsampled</span><span class=o>.</span><span class=n>_data</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>downsampled</span><span class=o>.</span><span class=n>_abscissa_vals</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_fs</span> <span class=o>=</span> <span class=n>fs_out</span>

        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>add_signal</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Docstring goes here.</span>
<span class=sd>        Basically we add a signal, and we add a label. THIS HAPPENS IN PLACE?</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=c1># TODO: add functionality to check that supports are the same, etc.</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=n>signal</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>data</span>

        <span class=n>signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>signal</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>signal</span><span class=o>.</span><span class=n>ndim</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;Can only add one signal at a time!&quot;</span><span class=p>)</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>ndim</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span>
                <span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)]</span>
            <span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)])</span>
        <span class=k>if</span> <span class=n>label</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;None label appended&quot;</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_labels</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_labels</span><span class=p>,</span> <span class=n>label</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>intervalarray</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>update</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Restrict self._abscissa_vals and self._data to an IntervalArray. If no</span>
<span class=sd>        IntervalArray is specified, self._abscissa.support is used.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        intervalarray : IntervalArray, optional</span>
<span class=sd>                IntervalArray on which to restrict AnalogSignal. Default is</span>
<span class=sd>                self._abscissa.support</span>
<span class=sd>        update : bool, optional</span>
<span class=sd>                Overwrite self._abscissa.support with intervalarray if True (default).</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>intervalarray</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>intervalarray</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span>
            <span class=n>update</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># support did not change; no need to update</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>intervalarray</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;Support specified is empty&quot;</span><span class=p>)</span>
                <span class=c1># self.__init__([],empty=True)</span>
                <span class=n>exclude</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;_support&quot;</span><span class=p>,</span> <span class=s2>&quot;_data&quot;</span><span class=p>,</span> <span class=s2>&quot;_fs&quot;</span><span class=p>,</span> <span class=s2>&quot;_step&quot;</span><span class=p>]</span>
                <span class=n>attrs</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>__attributes__</span> <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>exclude</span><span class=p>)</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
                <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>attrs</span><span class=p>:</span>
                    <span class=n>exec</span><span class=p>(</span><span class=s2>&quot;self.&quot;</span> <span class=o>+</span> <span class=n>attr</span> <span class=o>+</span> <span class=s2>&quot; = None&quot;</span><span class=p>)</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_data</span><span class=p>[:]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>intervalarray</span>
                <span class=k>return</span>
        <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>AttributeError</span><span class=p>(</span><span class=s2>&quot;IntervalArray expected&quot;</span><span class=p>)</span>

        <span class=n>indices</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>interval</span> <span class=ow>in</span> <span class=n>intervalarray</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
            <span class=n>a_start</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=n>a_stop</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
            <span class=n>frm</span><span class=p>,</span> <span class=n>to</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>,</span> <span class=p>(</span><span class=n>a_start</span><span class=p>,</span> <span class=n>a_stop</span> <span class=o>+</span> <span class=mf>1e-10</span><span class=p>))</span>
            <span class=n>indices</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>frm</span><span class=p>,</span> <span class=n>to</span><span class=p>))</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>indices</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>indices</span><span class=p>)</span><span class=o>.</span><span class=n>sum</span><span class=p>()</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>):</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;ignoring signal outside of support&quot;</span><span class=p>)</span>
        <span class=c1># check if only one interval and interval is already bounds of data</span>
        <span class=c1># if so, we don&#39;t need to do anything</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>indices</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>indices</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>indices</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>):</span>
                <span class=k>if</span> <span class=n>update</span><span class=p>:</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>intervalarray</span>
                    <span class=k>return</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>data_list</span> <span class=o>=</span> <span class=p>[]</span>
            <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>indices</span><span class=p>:</span>
                <span class=n>data_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>(</span><span class=n>data_list</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span><span class=p>[:]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
        <span class=n>time_list</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span> <span class=ow>in</span> <span class=n>indices</span><span class=p>:</span>
            <span class=n>time_list</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>stop</span><span class=p>])</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>time_list</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>update</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>intervalarray</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_restrict_to_interval_array</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>intervalarray</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>update</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Restrict self._abscissa_vals and self._data to an IntervalArray. If no</span>
<span class=sd>        IntervalArray is specified, self._abscissa.support is used.</span>

<span class=sd>        This function is quite slow, as it checks each sample for inclusion.</span>
<span class=sd>        It does this in a vectorized form, which is fast for small or moderately</span>
<span class=sd>        sized objects, but the memory penalty can be large, and it becomes very</span>
<span class=sd>        slow for large objects. Consequently, _restrict_to_interval_array_fast</span>
<span class=sd>        should be used when possible.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        intervalarray : IntervalArray, optional</span>
<span class=sd>                IntervalArray on which to restrict AnalogSignal. Default is</span>
<span class=sd>                self._abscissa.support</span>
<span class=sd>        update : bool, optional</span>
<span class=sd>                Overwrite self._abscissa.support with intervalarray if True (default).</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=n>intervalarray</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>intervalarray</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span>
            <span class=n>update</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># support did not change; no need to update</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>intervalarray</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;Support specified is empty&quot;</span><span class=p>)</span>
                <span class=c1># self.__init__([],empty=True)</span>
                <span class=n>exclude</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;_support&quot;</span><span class=p>,</span> <span class=s2>&quot;_data&quot;</span><span class=p>,</span> <span class=s2>&quot;_fs&quot;</span><span class=p>,</span> <span class=s2>&quot;_step&quot;</span><span class=p>]</span>
                <span class=n>attrs</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>__attributes__</span> <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>exclude</span><span class=p>)</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
                <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>attrs</span><span class=p>:</span>
                    <span class=n>exec</span><span class=p>(</span><span class=s2>&quot;self.&quot;</span> <span class=o>+</span> <span class=n>attr</span> <span class=o>+</span> <span class=s2>&quot; = None&quot;</span><span class=p>)</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_data</span><span class=p>[:]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>intervalarray</span>
                <span class=k>return</span>
        <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>AttributeError</span><span class=p>(</span><span class=s2>&quot;IntervalArray expected&quot;</span><span class=p>)</span>

        <span class=n>indices</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>interval</span> <span class=ow>in</span> <span class=n>intervalarray</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
            <span class=n>a_start</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=n>a_stop</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
            <span class=n>indices</span><span class=o>.</span><span class=n>append</span><span class=p>(</span>
                <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>&gt;=</span> <span class=n>a_start</span><span class=p>)</span> <span class=o>&amp;</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>&lt;</span> <span class=n>a_stop</span><span class=p>)</span>
            <span class=p>)</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>column_stack</span><span class=p>(</span><span class=n>indices</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>count_nonzero</span><span class=p>(</span><span class=n>indices</span><span class=p>)</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>):</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;ignoring signal outside of support&quot;</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>[:,</span> <span class=n>indices</span><span class=p>]</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_data</span><span class=p>[:]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nan</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>indices</span><span class=p>]</span>
        <span class=k>if</span> <span class=n>update</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>intervalarray</span>

    <span class=nd>@keyword_deprecation</span><span class=p>(</span><span class=n>replace_x_with_y</span><span class=o>=</span><span class=p>{</span><span class=s2>&quot;bw&quot;</span><span class=p>:</span> <span class=s2>&quot;truncate&quot;</span><span class=p>})</span>
    <span class=k>def</span><span class=w> </span><span class=nf>smooth</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>sigma</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>truncate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>cval</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>within_intervals</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Smooths the regularly sampled RegularlySampledAnalogSignalArray with a Gaussian kernel.</span>

<span class=sd>        Smoothing is applied along the abscissa, and the same smoothing is applied to each</span>
<span class=sd>        signal in the RegularlySampledAnalogSignalArray, or to each unit in a BinnedSpikeTrainArray.</span>

<span class=sd>        Smoothing is applied ACROSS intervals, but smoothing WITHIN intervals is also supported.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        obj : RegularlySampledAnalogSignalArray or BinnedSpikeTrainArray.</span>
<span class=sd>        fs : float, optional</span>
<span class=sd>            Sampling rate (in obj.base_unit^-1) of obj. If not provided, it will</span>
<span class=sd>            be inferred.</span>
<span class=sd>        sigma : float, optional</span>
<span class=sd>            Standard deviation of Gaussian kernel, in obj.base_units. Default is 0.05</span>
<span class=sd>            (50 ms if base_unit=seconds).</span>
<span class=sd>        truncate : float, optional</span>
<span class=sd>            Bandwidth outside of which the filter value will be zero. Default is 4.0.</span>
<span class=sd>        inplace : bool</span>
<span class=sd>            If True the data will be replaced with the smoothed data.</span>
<span class=sd>            Default is False.</span>
<span class=sd>        mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class=sd>            The mode parameter determines how the array borders are handled,</span>
<span class=sd>            where cval is the value when mode is equal to &#39;constant&#39;. Default is</span>
<span class=sd>            &#39;reflect&#39;.</span>
<span class=sd>        cval : scalar, optional</span>
<span class=sd>            Value to fill past edges of input if mode is &#39;constant&#39;. Default is 0.0.</span>
<span class=sd>        within_intervals : boolean, optional</span>
<span class=sd>            If True, then smooth within each epoch. Otherwise smooth across epochs.</span>
<span class=sd>            Default is False.</span>
<span class=sd>            Note that when mode = &#39;wrap&#39;, then smoothing within epochs aren&#39;t affected</span>
<span class=sd>            by wrapping.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : same type as obj</span>
<span class=sd>            An object with smoothed data is returned.</span>

<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=n>sigma</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>sigma</span> <span class=o>=</span> <span class=mf>0.05</span>
        <span class=k>if</span> <span class=n>truncate</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>truncate</span> <span class=o>=</span> <span class=mi>4</span>

        <span class=n>kwargs</span> <span class=o>=</span> <span class=p>{</span>
            <span class=s2>&quot;inplace&quot;</span><span class=p>:</span> <span class=n>inplace</span><span class=p>,</span>
            <span class=s2>&quot;fs&quot;</span><span class=p>:</span> <span class=n>fs</span><span class=p>,</span>
            <span class=s2>&quot;sigma&quot;</span><span class=p>:</span> <span class=n>sigma</span><span class=p>,</span>
            <span class=s2>&quot;truncate&quot;</span><span class=p>:</span> <span class=n>truncate</span><span class=p>,</span>
            <span class=s2>&quot;mode&quot;</span><span class=p>:</span> <span class=n>mode</span><span class=p>,</span>
            <span class=s2>&quot;cval&quot;</span><span class=p>:</span> <span class=n>cval</span><span class=p>,</span>
            <span class=s2>&quot;within_intervals&quot;</span><span class=p>:</span> <span class=n>within_intervals</span><span class=p>,</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
            <span class=n>ord_is_wrapped</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span>

            <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>unwrap</span><span class=p>()</span>

        <span class=c1># case 1: abs.wrapping=False, ord.linking=False, ord.wrapping=False</span>
        <span class=k>if</span> <span class=p>(</span>
            <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>pass</span>

        <span class=c1># case 2: abs.wrapping=False, ord.linking=False, ord.wrapping=True</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>pass</span>

        <span class=c1># case 3: abs.wrapping=False, ord.linking=True, ord.wrapping=False</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span>

        <span class=c1># case 4: abs.wrapping=False, ord.linking=True, ord.wrapping=True</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span>

        <span class=c1># case 5: abs.wrapping=True, ord.linking=False, ord.wrapping=False</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>if</span> <span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
                <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;mode&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&quot;wrap&quot;</span>

        <span class=c1># case 6: abs.wrapping=True, ord.linking=False, ord.wrapping=True</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=c1># (1) unwrap ordinate (abscissa wrap=False)</span>
            <span class=c1># (2) smooth unwrapped ordinate (absissa wrap=False)</span>
            <span class=c1># (3) repeat unwrapped signal based on conditions from (2):</span>
            <span class=c1># if smoothed wrapped ordinate samples</span>
            <span class=c1># HH ==&gt; SSS (this must be done on a per-signal basis!!!) H = high; L = low; S = same</span>
            <span class=c1># LL ==&gt; SSS (the vertical offset must be such that neighbors have smallest displacement)</span>
            <span class=c1># LH ==&gt; LSH</span>
            <span class=c1># HL ==&gt; HSL</span>
            <span class=c1># (4) smooth expanded and unwrapped ordinate (abscissa wrap=False)</span>
            <span class=c1># (5) cut out orignal signal</span>

            <span class=c1># (1)</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;mode&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&quot;reflect&quot;</span>
            <span class=n>L</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span>
            <span class=n>D</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>length</span>

            <span class=n>tmp</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>unwrap</span><span class=p>(),</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=c1># (2) (3)</span>
            <span class=n>n_reps</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>((</span><span class=n>sigma</span> <span class=o>*</span> <span class=n>truncate</span><span class=p>)</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=n>D</span><span class=p>)))</span>

            <span class=n>smooth_data</span> <span class=o>=</span> <span class=p>[]</span>
            <span class=k>for</span> <span class=n>ss</span><span class=p>,</span> <span class=n>signal</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>tmp</span><span class=o>.</span><span class=n>signals</span><span class=p>):</span>
                <span class=c1># signal = signal.wrap()</span>
                <span class=n>offset</span> <span class=o>=</span> <span class=p>(</span>
                    <span class=nb>float</span><span class=p>((</span><span class=n>signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>])</span> <span class=o>//</span> <span class=p>(</span><span class=n>L</span> <span class=o>/</span> <span class=mi>2</span><span class=p>))</span> <span class=o>*</span> <span class=n>L</span>
                <span class=p>)</span>
                <span class=c1># print(offset)</span>
                <span class=c1># left_high = signal._data[:,0] &gt;= out._ordinate.range.min + L/2</span>
                <span class=c1># right_high = signal._data[:,-1] &gt;= out._ordinate.range.min + L/2</span>
                <span class=c1># signal = signal.unwrap()</span>

                <span class=n>expanded</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
                <span class=k>for</span> <span class=n>nn</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_reps</span><span class=p>):</span>
                    <span class=n>expanded</span> <span class=o>=</span> <span class=n>expanded</span><span class=o>.</span><span class=n>join</span><span class=p>((</span><span class=n>signal</span> <span class=o>&lt;&lt;</span> <span class=n>D</span> <span class=o>*</span> <span class=p>(</span><span class=n>nn</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=o>-</span> <span class=n>offset</span><span class=p>)</span><span class=o>.</span><span class=n>join</span><span class=p>(</span>
                        <span class=p>(</span><span class=n>signal</span> <span class=o>&gt;&gt;</span> <span class=n>D</span> <span class=o>*</span> <span class=p>(</span><span class=n>nn</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=n>offset</span>
                    <span class=p>)</span>
                    <span class=c1># print(expanded)</span>
                    <span class=c1># if left_high == right_high:</span>
                    <span class=c1>#     print(&#39;extending flat! signal {}&#39;.format(ss))</span>
                    <span class=c1>#     expanded = expanded.join(signal &lt;&lt; D*(nn+1)).join(signal &gt;&gt; D*(nn+1))</span>
                    <span class=c1># elif left_high &lt; right_high:</span>
                    <span class=c1>#     print(&#39;extending LSH! signal {}&#39;.format(ss))</span>
                    <span class=c1>#     # LSH</span>
                    <span class=c1>#     expanded = expanded.join((signal &lt;&lt; D*(nn+1))-L).join((signal &gt;&gt; D*(nn+1))+L)</span>
                    <span class=c1># else:</span>
                    <span class=c1>#     # HSL</span>
                    <span class=c1>#     print(&#39;extending HSL! signal {}&#39;.format(ss))</span>
                    <span class=c1>#     expanded = expanded.join((signal &lt;&lt; D*(nn+1))+L).join((signal &gt;&gt; D*(nn+1))-L)</span>
                <span class=c1># (4)</span>
                <span class=n>smooth_signal</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>expanded</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
                <span class=n>smooth_data</span><span class=o>.</span><span class=n>append</span><span class=p>(</span>
                    <span class=n>smooth_signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[</span>
                        <span class=p>:,</span> <span class=n>n_reps</span> <span class=o>*</span> <span class=n>tmp</span><span class=o>.</span><span class=n>n_samples</span> <span class=p>:</span> <span class=p>(</span><span class=n>n_reps</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>tmp</span><span class=o>.</span><span class=n>n_samples</span><span class=p>)</span>
                    <span class=p>]</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
                <span class=p>)</span>
            <span class=c1># (5)</span>
            <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>smooth_data</span><span class=p>)</span>
            <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>

            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
                    <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>wrap</span><span class=p>()</span>

            <span class=k>return</span> <span class=n>out</span>

        <span class=c1># case 7: abs.wrapping=True, ord.linking=True, ord.wrapping=False</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span>

        <span class=c1># case 8: abs.wrapping=True, ord.linking=True, ord.wrapping=True</span>
        <span class=k>elif</span> <span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
            <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=p>):</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span>

        <span class=n>out</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>wrap</span><span class=p>()</span>

        <span class=k>return</span> <span class=n>out</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>lengths</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(list) The number of samples in each interval.&quot;&quot;&quot;</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>interval</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
            <span class=n>a_start</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=n>a_stop</span> <span class=o>=</span> <span class=n>interval</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
            <span class=n>frm</span><span class=p>,</span> <span class=n>to</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>,</span> <span class=p>(</span><span class=n>a_start</span><span class=p>,</span> <span class=n>a_stop</span><span class=p>))</span>
            <span class=n>indices</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>frm</span><span class=p>,</span> <span class=n>to</span><span class=p>))</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>indices</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
        <span class=n>lengths</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>indices</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>())</span>
        <span class=k>return</span> <span class=n>lengths</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>labels</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(list) The labels corresponding to each signal.&quot;&quot;&quot;</span>
        <span class=c1># TODO: make this faster and better!</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_labels</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>n_signals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(int) The number of signals.&quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>utils</span><span class=o>.</span><span class=n>PrettyInt</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
        <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>
            <span class=k>return</span> <span class=mi>0</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>address_str</span> <span class=o>=</span> <span class=s2>&quot; at &quot;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=nb>id</span><span class=p>(</span><span class=bp>self</span><span class=p>)))</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=k>return</span> <span class=s2>&quot;&lt;empty &quot;</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>type_name</span> <span class=o>+</span> <span class=n>address_str</span> <span class=o>+</span> <span class=s2>&quot;&gt;&quot;</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_intervals</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=n>epstr</span> <span class=o>=</span> <span class=s2>&quot; (</span><span class=si>{}</span><span class=s2> segments)&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>epstr</span> <span class=o>=</span> <span class=s2>&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
                <span class=n>nstr</span> <span class=o>=</span> <span class=s2>&quot; </span><span class=si>%s</span><span class=s2> signals</span><span class=si>%s</span><span class=s2>&quot;</span> <span class=o>%</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span><span class=p>,</span> <span class=n>epstr</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=n>nstr</span> <span class=o>=</span> <span class=s2>&quot; 1 signal</span><span class=si>%s</span><span class=s2>&quot;</span> <span class=o>%</span> <span class=n>epstr</span>
        <span class=n>dstr</span> <span class=o>=</span> <span class=s2>&quot; for a total of </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>formatter</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>length</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=k>return</span> <span class=s2>&quot;&lt;</span><span class=si>%s%s</span><span class=s2>:</span><span class=si>%s</span><span class=s2>&gt;</span><span class=si>%s</span><span class=s2>&quot;</span> <span class=o>%</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>type_name</span><span class=p>,</span> <span class=n>address_str</span><span class=p>,</span> <span class=n>nstr</span><span class=p>,</span> <span class=n>dstr</span><span class=p>)</span>

    <span class=nd>@keyword_equivalence</span><span class=p>(</span><span class=n>this_or_that</span><span class=o>=</span><span class=p>{</span><span class=s2>&quot;n_intervals&quot;</span><span class=p>:</span> <span class=s2>&quot;n_epochs&quot;</span><span class=p>})</span>
    <span class=k>def</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_intervals</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns an RegularlySampledAnalogSignalArray whose support has been</span>
<span class=sd>        partitioned.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        ds : float, optional</span>
<span class=sd>            Maximum duration (in seconds), for each interval.</span>
<span class=sd>        n_samples : int, optional</span>
<span class=sd>            Number of intervals. If ds is None and n_intervals is None, then</span>
<span class=sd>            default is to use n_intervals = 100</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            RegularlySampledAnalogSignalArray that has been partitioned.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Irrespective of whether &#39;ds&#39; or &#39;n_intervals&#39; are used, the exact</span>
<span class=sd>        underlying support is propagated, and the first and last points</span>
<span class=sd>        of the supports are always included, even if this would cause</span>
<span class=sd>        n_samples or ds to be violated.</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>partition</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=n>ds</span><span class=p>,</span> <span class=n>n_intervals</span><span class=o>=</span><span class=n>n_intervals</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=c1># @property</span>
    <span class=c1># def ydata(self):</span>
    <span class=c1>#     &quot;&quot;&quot;(np.array N-Dimensional) data with shape (n_signals, n_samples).&quot;&quot;&quot;</span>
    <span class=c1>#     # LEGACY</span>
    <span class=c1>#     return self.data</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>data</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(np.array N-Dimensional) data with shape (n_signals, n_samples).&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_data</span>

    <span class=nd>@data</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>data</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(np.array N-Dimensional) data with shape (n_signals, n_samples).&quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>val</span>
        <span class=c1># print(&#39;data was modified, so clearing interp, etc.&#39;)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>support</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The support of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span>

    <span class=nd>@support</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>support</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The support of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=c1># modify support</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>val</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=p>(</span><span class=nb>tuple</span><span class=p>,</span> <span class=nb>list</span><span class=p>)):</span>
            <span class=n>prev_domain</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>domain</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)([</span><span class=n>val</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>val</span><span class=p>[</span><span class=mi>1</span><span class=p>]])</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>domain</span> <span class=o>=</span> <span class=n>prev_domain</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;support must be of type </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)))</span>
            <span class=p>)</span>
        <span class=c1># restrict data to new support</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=n>intervalarray</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>domain</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The domain of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>domain</span>

    <span class=nd>@domain</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>domain</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The domain of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=c1># modify domain</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>domain</span> <span class=o>=</span> <span class=n>val</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>val</span><span class=p>,</span> <span class=p>(</span><span class=nb>tuple</span><span class=p>,</span> <span class=nb>list</span><span class=p>)):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>domain</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)([</span><span class=n>val</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>val</span><span class=p>[</span><span class=mi>1</span><span class=p>]])</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;support must be of type </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)))</span>
            <span class=p>)</span>
        <span class=c1># restrict data to new support</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=n>intervalarray</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>range</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The range of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span>

    <span class=nd>@range</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>range</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(nelpy.IntervalArray) The range of the underlying RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=c1># modify range</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span> <span class=o>=</span> <span class=n>val</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>step</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;steps per sample</span>
<span class=sd>        Example 1: sample_numbers = np.array([1,2,3,4,5,6]) #aka time</span>
<span class=sd>        Steps per sample in the above case would be 1</span>

<span class=sd>        Example 2: sample_numbers = np.array([1,3,5,7,9]) #aka time</span>
<span class=sd>        Steps per sample in Example 2 would be 2</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_step</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>abscissa_vals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(np.array 1D) Time in seconds.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span>

    <span class=nd>@abscissa_vals</span><span class=o>.</span><span class=n>setter</span>
    <span class=k>def</span><span class=w> </span><span class=nf>abscissa_vals</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>vals</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(np.array 1D) Time in seconds.&quot;&quot;&quot;</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>vals</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>fs</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(float) Sampling frequency.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_fs</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;No sampling frequency has been specified!&quot;</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_fs</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>isempty</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(bool) checks length of data input&quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>  <span class=c1># IndexError should happen if _data = []</span>
            <span class=k>return</span> <span class=kc>True</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>n_bytes</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Approximate number of bytes taken up by object.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=n>utils</span><span class=o>.</span><span class=n>PrettyBytes</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>nbytes</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=o>.</span><span class=n>nbytes</span><span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>n_intervals</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(int) number of intervals in RegularlySampledAnalogSignalArray&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>n_intervals</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>n_samples</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;(int) number of abscissa samples where signal is defined.&quot;&quot;&quot;</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=k>return</span> <span class=mi>0</span>
        <span class=k>return</span> <span class=n>utils</span><span class=o>.</span><span class=n>PrettyInt</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>))</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;AnalogSignal iterator initialization&quot;&quot;&quot;</span>
        <span class=c1># initialize the internal index to zero when used as iterator</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__next__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;AnalogSignal iterator advancer.&quot;&quot;&quot;</span>
        <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_index</span>
        <span class=k>if</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_intervals</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>StopIteration</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
        <span class=n>intervalarray</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>exclude</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;_abscissa_vals&quot;</span><span class=p>]</span>
        <span class=n>attrs</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>__attributes__</span> <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>exclude</span><span class=p>)</span>

        <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>attrs</span><span class=p>:</span>
            <span class=n>exec</span><span class=p>(</span><span class=s2>&quot;intervalarray.&quot;</span> <span class=o>+</span> <span class=n>attr</span> <span class=o>+</span> <span class=s2>&quot; = self._abscissa.support.&quot;</span> <span class=o>+</span> <span class=n>attr</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>intervalarray</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>[</span>
                <span class=nb>tuple</span><span class=p>([</span><span class=n>index</span><span class=p>]),</span> <span class=p>:</span>
            <span class=p>]</span>  <span class=c1># use np integer indexing! Cool!</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=c1># index is out of bounds, so return an empty IntervalArray</span>
            <span class=k>pass</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>_index</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=n>asa</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)([],</span> <span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>exclude</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&quot;_interp&quot;</span><span class=p>,</span> <span class=s2>&quot;_support&quot;</span><span class=p>]</span>
        <span class=n>attrs</span> <span class=o>=</span> <span class=p>(</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>__attributes__</span> <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>exclude</span><span class=p>)</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>attrs</span><span class=p>:</span>
            <span class=n>exec</span><span class=p>(</span><span class=s2>&quot;asa.&quot;</span> <span class=o>+</span> <span class=n>attr</span> <span class=o>+</span> <span class=s2>&quot; = self.&quot;</span> <span class=o>+</span> <span class=n>attr</span><span class=p>)</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=n>intervalarray</span><span class=o>=</span><span class=n>intervalarray</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>asa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;Support is empty. Empty RegularlySampledAnalogSignalArray returned&quot;</span>
            <span class=p>)</span>
            <span class=n>asa</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)([],</span> <span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

        <span class=n>asa</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>asa</span>

    <span class=k>def</span><span class=w> </span><span class=nf>empty</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Remove data (but not metadata) from RegularlySampledAnalogSignalArray.</span>

<span class=sd>        Attributes &#39;data&#39;, &#39;abscissa_vals&#39;, and &#39;support&#39; are all emptied.</span>

<span class=sd>        Note: n_signals is preserved.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>n_signals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>inplace</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_copy_without_data</span><span class=p>()</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
            <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>n_signals</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;RegularlySampledAnalogSignalArray index access.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        idx : IntervalArray, int, slice</span>
<span class=sd>            intersect passed intervalarray with support,</span>
<span class=sd>            index particular a singular interval or multiple intervals with slice</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>intervalslice</span><span class=p>,</span> <span class=n>signalslice</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_intervalsignalslicer</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>

        <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_subset</span><span class=p>(</span><span class=n>signalslice</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>asa</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=n>asa</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>asa</span>

        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>intervalslice</span><span class=p>,</span> <span class=nb>slice</span><span class=p>):</span>
            <span class=k>if</span> <span class=p>(</span>
                <span class=n>intervalslice</span><span class=o>.</span><span class=n>start</span> <span class=ow>is</span> <span class=kc>None</span>
                <span class=ow>and</span> <span class=n>intervalslice</span><span class=o>.</span><span class=n>stop</span> <span class=ow>is</span> <span class=kc>None</span>
                <span class=ow>and</span> <span class=n>intervalslice</span><span class=o>.</span><span class=n>step</span> <span class=ow>is</span> <span class=kc>None</span>
            <span class=p>):</span>
                <span class=n>asa</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
                <span class=k>return</span> <span class=n>asa</span>

        <span class=n>newintervals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>intervalslice</span><span class=p>]</span>
        <span class=c1># TODO: this needs to change so that n_signals etc. are preserved</span>
        <span class=c1>################################################################</span>
        <span class=k>if</span> <span class=n>newintervals</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;Index resulted in empty interval array&quot;</span><span class=p>)</span>
            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>empty</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
        <span class=c1>################################################################</span>

        <span class=n>asa</span><span class=o>.</span><span class=n>_restrict_to_interval_array_fast</span><span class=p>(</span><span class=n>intervalarray</span><span class=o>=</span><span class=n>newintervals</span><span class=p>)</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>asa</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_subset</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
        <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>asa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>[</span><span class=n>idx</span><span class=p>,</span> <span class=p>:])</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
                <span class=s2>&quot;index </span><span class=si>{}</span><span class=s2> is out of bounds for n_signals with size </span><span class=si>{}</span><span class=s2>&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=n>idx</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span>
                <span class=p>)</span>
            <span class=p>)</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>asa</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_copy_without_data</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Return a copy of self, without data and abscissa_vals.</span>

<span class=sd>        Note: the support is left unchanged.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>copy</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>  <span class=c1># shallow copy</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
        <span class=n>out</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span>
            <span class=n>out</span>
        <span class=p>)</span>  <span class=c1># just to be on the safe side, but at least now we are not copying the data!</span>
        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>copy</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Return a copy of the current object.&quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>median</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns the median of each signal in RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>medians</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmedian</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>if</span> <span class=n>medians</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=n>medians</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>medians</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
                <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate median&quot;</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>mean</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Compute the mean of the data along the specified axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        axis : int, optional</span>
<span class=sd>            Axis along which to compute the mean (default is 1, i.e., across samples).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        mean : np.ndarray</span>
<span class=sd>            Mean values along the specified axis.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>means</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>if</span> <span class=n>means</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=n>means</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>means</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
                <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate mean&quot;</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>std</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Compute the standard deviation of the data along the specified axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        axis : int, optional</span>
<span class=sd>            Axis along which to compute the standard deviation (default is 1).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        std : np.ndarray</span>
<span class=sd>            Standard deviation values along the specified axis.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>stds</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanstd</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>if</span> <span class=n>stds</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=n>stds</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>stds</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
                <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate standard deviation&quot;</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>max</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Compute the maximum value of the data along the specified axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        axis : int, optional</span>
<span class=sd>            Axis along which to compute the maximum (default is 1).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        max : np.ndarray</span>
<span class=sd>            Maximum values along the specified axis.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>maxes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>amax</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>if</span> <span class=n>maxes</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=n>maxes</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>maxes</span>
        <span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate maximum&quot;</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>min</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Compute the minimum value of the data along the specified axis.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        axis : int, optional</span>
<span class=sd>            Axis along which to compute the minimum (default is 1).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        min : np.ndarray</span>
<span class=sd>            Minimum values along the specified axis.</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>mins</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>amin</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>if</span> <span class=n>mins</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=n>mins</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
            <span class=k>return</span> <span class=n>mins</span>
        <span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate minimum&quot;</span>
            <span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>clip</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=nb>min</span><span class=p>,</span> <span class=nb>max</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Clip (limit) the values in the data to the interval [min, max].</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        min : float</span>
<span class=sd>            Minimum value.</span>
<span class=sd>        max : float</span>
<span class=sd>            Maximum value.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            New object with clipped data.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; clipped = asa.clip(-1, 1)</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>clip</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=nb>min</span><span class=p>,</span> <span class=nb>max</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=k>def</span><span class=w> </span><span class=nf>trim</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Trim the signal to the specified start and stop times.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        start : float</span>
<span class=sd>            Start time.</span>
<span class=sd>        stop : float, optional</span>
<span class=sd>            Stop time. If None, trims to the end.</span>
<span class=sd>        fs : float, optional</span>
<span class=sd>            Sampling frequency. If None, uses self.fs.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            Trimmed signal array.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; trimmed = asa.trim(0, 10)</span>
<span class=sd>        &quot;&quot;&quot;</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;RegularlySampledAnalogSignalArray: Trim may not work!&quot;</span><span class=p>)</span>
        <span class=c1># TODO: do comprehensive input validation</span>
        <span class=k>if</span> <span class=n>stop</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>start</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start must be a scalar float&quot;</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start must be a scalar float&quot;</span><span class=p>)</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>stop</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>stop</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>stop</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;stop must be a scalar float&quot;</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;stop must be a scalar float&quot;</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>  <span class=c1># start must have two elements</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                        <span class=s2>&quot;unsupported input to RegularlySampledAnalogSignalArray.trim()&quot;</span>
                    <span class=p>)</span>
                <span class=n>stop</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
                <span class=n>start</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>stop</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start and stop must be scalar floats&quot;</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start and stop must be scalar floats&quot;</span><span class=p>)</span>

        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
        <span class=n>interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>intersect</span><span class=p>(</span>
            <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)([</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>],</span> <span class=n>fs</span><span class=o>=</span><span class=n>fs</span><span class=p>)</span>
        <span class=p>)</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>interval</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=n>analogsignalarray</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>interval</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>analogsignalarray</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)([],</span> <span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
        <span class=n>analogsignalarray</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>analogsignalarray</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_ydata_rowsig</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;returns wide-format data s.t. each row is a signal.&quot;&quot;&quot;</span>
        <span class=c1># LEGACY</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_ydata_colsig</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=c1># LEGACY</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;returns skinny-format data s.t. each column is a signal.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_data_rowsig</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;returns wide-format data s.t. each row is a signal.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span>

    <span class=nd>@property</span>
    <span class=k>def</span><span class=w> </span><span class=nf>_data_colsig</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;returns skinny-format data s.t. each column is a signal.&quot;&quot;&quot;</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>T</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_get_interp1d</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>kind</span><span class=o>=</span><span class=s2>&quot;linear&quot;</span><span class=p>,</span>
        <span class=n>copy</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
        <span class=n>bounds_error</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=n>fill_value</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span>
        <span class=n>assume_sorted</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;returns a scipy interp1d object, extended to have values at all interval</span>
<span class=sd>        boundaries!</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=n>assume_sorted</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>assume_sorted</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>is_sorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=n>axis</span> <span class=o>=</span> <span class=mi>1</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>axis</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>

        <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
            <span class=n>yvals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_unwrap</span><span class=p>(</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_data_rowsig</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span>
            <span class=p>)</span>  <span class=c1># always interpolate on the unwrapped data!</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>yvals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_data_rowsig</span>

        <span class=n>lengths</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lengths</span>
        <span class=n>empty_interval_ids</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argwhere</span><span class=p>(</span><span class=n>lengths</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
        <span class=n>first_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
        <span class=n>first_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>last_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=n>last_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>first_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
            <span class=n>first_abscissavals_per_interval_idx</span>
        <span class=p>]</span>
        <span class=n>last_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
            <span class=n>last_abscissavals_per_interval_idx</span>
        <span class=p>]</span>

        <span class=n>boundary_abscissa_vals</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=n>boundary_vals</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>ii</span><span class=p>,</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>lengths</span><span class=p>[</span><span class=n>ii</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=k>continue</span>
            <span class=k>if</span> <span class=n>first_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>start</span><span class=p>:</span>
                <span class=n>boundary_abscissa_vals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
                <span class=n>boundary_vals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>yvals</span><span class=p>[:,</span> <span class=n>first_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>ii</span><span class=p>]])</span>
                <span class=c1># print(&#39;adding {} at abscissa_vals {}&#39;.format(yvals[:,first_abscissavals_per_interval_idx[ii]], start))</span>
            <span class=k>if</span> <span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>stop</span><span class=p>:</span>
                <span class=n>boundary_abscissa_vals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>stop</span><span class=p>)</span>
                <span class=n>boundary_vals</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>yvals</span><span class=p>[:,</span> <span class=n>last_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>ii</span><span class=p>]])</span>

        <span class=k>if</span> <span class=n>boundary_abscissa_vals</span><span class=p>:</span>
            <span class=n>insert_locs</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>searchsorted</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>boundary_abscissa_vals</span><span class=p>)</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span>
                <span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>insert_locs</span><span class=p>,</span> <span class=n>boundary_abscissa_vals</span>
            <span class=p>)</span>
            <span class=n>yvals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>yvals</span><span class=p>,</span> <span class=n>insert_locs</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>boundary_vals</span><span class=p>)</span><span class=o>.</span><span class=n>T</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

            <span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>unique_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>unique</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>return_index</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
            <span class=n>yvals</span> <span class=o>=</span> <span class=n>yvals</span><span class=p>[:,</span> <span class=n>unique_idx</span><span class=p>]</span>

        <span class=n>f</span> <span class=o>=</span> <span class=n>interpolate</span><span class=o>.</span><span class=n>interp1d</span><span class=p>(</span>
            <span class=n>x</span><span class=o>=</span><span class=n>abscissa_vals</span><span class=p>,</span>
            <span class=n>y</span><span class=o>=</span><span class=n>yvals</span><span class=p>,</span>
            <span class=n>kind</span><span class=o>=</span><span class=n>kind</span><span class=p>,</span>
            <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>,</span>
            <span class=n>copy</span><span class=o>=</span><span class=n>copy</span><span class=p>,</span>
            <span class=n>bounds_error</span><span class=o>=</span><span class=n>bounds_error</span><span class=p>,</span>
            <span class=n>fill_value</span><span class=o>=</span><span class=n>fill_value</span><span class=p>,</span>
            <span class=n>assume_sorted</span><span class=o>=</span><span class=n>assume_sorted</span><span class=p>,</span>
        <span class=p>)</span>
        <span class=k>return</span> <span class=n>f</span>

    <span class=k>def</span><span class=w> </span><span class=nf>asarray</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>where</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>at</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>kind</span><span class=o>=</span><span class=s2>&quot;linear&quot;</span><span class=p>,</span>
        <span class=n>copy</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
        <span class=n>bounds_error</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=n>fill_value</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span>
        <span class=n>assume_sorted</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>recalculate</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
        <span class=n>store_interp</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
        <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
        <span class=n>split_by_interval</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>        Return a data-like array at requested points, with optional interpolation.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        where : array_like or tuple, optional</span>
<span class=sd>            Array corresponding to np where condition (e.g., where=(data[1,:]&gt;5)).</span>
<span class=sd>        at : array_like, optional</span>
<span class=sd>            Array of points to evaluate array at. If None, uses self._abscissa_vals.</span>
<span class=sd>        n_samples : int, optional</span>
<span class=sd>            Number of points to interpolate at, distributed uniformly from support start to stop.</span>
<span class=sd>        split_by_interval : bool, optional</span>
<span class=sd>            If True, separate arrays by intervals and return in a list.</span>
<span class=sd>        kind : str, optional</span>
<span class=sd>            Interpolation method. Default is &#39;linear&#39;.</span>
<span class=sd>        copy : bool, optional</span>
<span class=sd>            If True, returns a copy. Default is True.</span>
<span class=sd>        bounds_error : bool, optional</span>
<span class=sd>            If True, raises an error for out-of-bounds interpolation. Default is False.</span>
<span class=sd>        fill_value : float, optional</span>
<span class=sd>            Value to use for out-of-bounds points. Default is np.nan.</span>
<span class=sd>        assume_sorted : bool, optional</span>
<span class=sd>            If True, assumes input is sorted. Default is None.</span>
<span class=sd>        recalculate : bool, optional</span>
<span class=sd>            If True, recalculates the interpolation. Default is False.</span>
<span class=sd>        store_interp : bool, optional</span>
<span class=sd>            If True, stores the interpolation object. Default is True.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : namedtuple (xvals, yvals)</span>
<span class=sd>            xvals: array of abscissa values for which data are returned.</span>
<span class=sd>            yvals: array of shape (n_signals, n_samples) with interpolated data.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        &gt;&gt;&gt; xvals, yvals = asa.asarray(at=[0, 1, 2])</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=c1># TODO: implement splitting by interval</span>

        <span class=k>if</span> <span class=n>split_by_interval</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span><span class=s2>&quot;split_by_interval not yet implemented...&quot;</span><span class=p>)</span>

        <span class=n>XYArray</span> <span class=o>=</span> <span class=n>namedtuple</span><span class=p>(</span><span class=s2>&quot;XYArray&quot;</span><span class=p>,</span> <span class=p>[</span><span class=s2>&quot;xvals&quot;</span><span class=p>,</span> <span class=s2>&quot;yvals&quot;</span><span class=p>])</span>

        <span class=k>if</span> <span class=p>(</span>
            <span class=n>at</span> <span class=ow>is</span> <span class=kc>None</span>
            <span class=ow>and</span> <span class=n>where</span> <span class=ow>is</span> <span class=kc>None</span>
            <span class=ow>and</span> <span class=n>split_by_interval</span> <span class=ow>is</span> <span class=kc>False</span>
            <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span>
        <span class=p>):</span>
            <span class=n>xyarray</span> <span class=o>=</span> <span class=n>XYArray</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_data_rowsig</span><span class=o>.</span><span class=n>squeeze</span><span class=p>())</span>
            <span class=k>return</span> <span class=n>xyarray</span>

        <span class=k>if</span> <span class=n>where</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>assert</span> <span class=n>at</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>,</span> <span class=p>(</span>
                <span class=s2>&quot;&#39;where&#39;, &#39;at&#39;, and &#39;n_samples&#39; cannot be used at the same time&quot;</span>
            <span class=p>)</span>
            <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>where</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>):</span>
                <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>where</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
                <span class=n>x</span> <span class=o>=</span> <span class=n>where</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
                <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>y</span><span class=p>),</span> <span class=p>(</span>
                    <span class=s2>&quot;&#39;where&#39; condition and array must have same number of elements&quot;</span>
                <span class=p>)</span>
                <span class=n>at</span> <span class=o>=</span> <span class=n>y</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>where</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
                <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>),</span> <span class=p>(</span>
                    <span class=s2>&quot;&#39;where&#39; condition must have same number of elements as self._abscissa_vals&quot;</span>
                <span class=p>)</span>
                <span class=n>at</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
        <span class=k>elif</span> <span class=n>at</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>assert</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>,</span> <span class=p>(</span>
                <span class=s2>&quot;&#39;at&#39; and &#39;n_samples&#39; cannot be used at the same time&quot;</span>
            <span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>at</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>stop</span><span class=p>,</span> <span class=n>n_samples</span><span class=p>)</span>

        <span class=n>at</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>at</span><span class=o>.</span><span class=n>ndim</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Requested points must be one-dimensional!&quot;</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>at</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;No points were requested to interpolate&quot;</span><span class=p>)</span>

        <span class=c1># if we made it this far, either at or where has been specified, and at is now well defined.</span>

        <span class=n>kwargs</span> <span class=o>=</span> <span class=p>{</span>
            <span class=s2>&quot;kind&quot;</span><span class=p>:</span> <span class=n>kind</span><span class=p>,</span>
            <span class=s2>&quot;copy&quot;</span><span class=p>:</span> <span class=n>copy</span><span class=p>,</span>
            <span class=s2>&quot;bounds_error&quot;</span><span class=p>:</span> <span class=n>bounds_error</span><span class=p>,</span>
            <span class=s2>&quot;fill_value&quot;</span><span class=p>:</span> <span class=n>fill_value</span><span class=p>,</span>
            <span class=s2>&quot;assume_sorted&quot;</span><span class=p>:</span> <span class=n>assume_sorted</span><span class=p>,</span>
        <span class=p>}</span>

        <span class=c1># retrieve an existing, or construct a new interpolation object</span>
        <span class=k>if</span> <span class=n>recalculate</span><span class=p>:</span>
            <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span>
                <span class=k>if</span> <span class=n>interpobj</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
                    <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>  <span class=c1># does not exist yet</span>
                <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

        <span class=c1># store interpolation object, if desired</span>
        <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>

        <span class=c1># do not interpolate points that lie outside the support</span>
        <span class=n>interval_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>[:,</span> <span class=p>:,</span> <span class=kc>None</span><span class=p>]</span>
        <span class=c1># use broadcasting to check in a vectorized manner if</span>
        <span class=c1># each sample falls within the support, haha aren&#39;t we clever?</span>
        <span class=c1># (n_intervals, n_requested_samples)</span>
        <span class=n>valid</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>logical_and</span><span class=p>(</span>
            <span class=n>at</span> <span class=o>&gt;=</span> <span class=n>interval_data</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>:],</span> <span class=n>at</span> <span class=o>&lt;=</span> <span class=n>interval_data</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>,</span> <span class=p>:]</span>
        <span class=p>)</span>
        <span class=n>valid_mask</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>valid</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
        <span class=n>n_invalid</span> <span class=o>=</span> <span class=n>at</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>valid_mask</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>n_invalid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;</span><span class=si>{}</span><span class=s2> values outside the support were removed&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>n_invalid</span><span class=p>)</span>
            <span class=p>)</span>
        <span class=n>at</span> <span class=o>=</span> <span class=n>at</span><span class=p>[</span><span class=n>valid_mask</span><span class=p>]</span>

        <span class=c1># do the actual interpolation</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span><span class=p>:</span>
                    <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span>
                        <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>),</span>
                        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span>
                        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>,</span>
                    <span class=p>)</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>SystemError</span><span class=p>:</span>
                <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>
                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span><span class=p>:</span>
                    <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span>
                        <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>),</span>
                        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span>
                        <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>,</span>
                    <span class=p>)</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>SystemError</span><span class=p>:</span>
                <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>

        <span class=n>xyarray</span> <span class=o>=</span> <span class=n>XYArray</span><span class=p>(</span><span class=n>xvals</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>at</span><span class=p>),</span> <span class=n>yvals</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>out</span><span class=p>))</span>
        <span class=k>return</span> <span class=n>xyarray</span>

    <span class=k>def</span><span class=w> </span><span class=nf>subsample</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Subsamples a RegularlySampledAnalogSignalArray</span>

<span class=sd>        WARNING! Aliasing can occur! It is better to use downsample when</span>
<span class=sd>        lowering the sampling rate substantially.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        fs : float, optional</span>
<span class=sd>            Desired output sampling rate, in Hz</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            Copy of RegularlySampledAnalogSignalArray where data is only stored at the</span>
<span class=sd>            new subset of points.</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=mi>1</span> <span class=o>/</span> <span class=n>fs</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=nf>simplify</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Returns an RegularlySampledAnalogSignalArray where the data has been</span>
<span class=sd>        simplified / subsampled.</span>

<span class=sd>        This function is primarily intended to be used for plotting and</span>
<span class=sd>        saving vector graphics without having too large file sizes as</span>
<span class=sd>        a result of too many points.</span>

<span class=sd>        Irrespective of whether &#39;ds&#39; or &#39;n_samples&#39; are used, the exact</span>
<span class=sd>        underlying support is propagated, and the first and last points</span>
<span class=sd>        of the supports are always included, even if this would cause</span>
<span class=sd>        n_samples or ds to be violated.</span>

<span class=sd>        WARNING! Simplify can create nan samples, when requesting a timestamp</span>
<span class=sd>        within an interval, but outside of the (first, last) abscissa_vals within that</span>
<span class=sd>        interval, since we don&#39;t extrapolate, but only interpolate. # TODO: fix</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        ds : float, optional</span>
<span class=sd>            Time (in seconds), in which to step points.</span>
<span class=sd>        n_samples : int, optional</span>
<span class=sd>            Number of points at which to intepolate data. If ds is None</span>
<span class=sd>            and n_samples is None, then default is to use n_samples=5,000</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            Copy of RegularlySampledAnalogSignalArray where data is only stored at the</span>
<span class=sd>            new subset of points.</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
            <span class=k>return</span> <span class=bp>self</span>

        <span class=c1># legacy kwarg support:</span>
        <span class=n>n_points</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;n_points&quot;</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>n_points</span><span class=p>:</span>
            <span class=n>n_samples</span> <span class=o>=</span> <span class=n>n_points</span>

        <span class=k>if</span> <span class=n>ds</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ds and n_samples cannot be used together&quot;</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=k>assert</span> <span class=nb>float</span><span class=p>(</span><span class=n>n_samples</span><span class=p>)</span><span class=o>.</span><span class=n>is_integer</span><span class=p>(),</span> <span class=p>(</span>
                <span class=s2>&quot;n_samples must be a positive integer!&quot;</span>
            <span class=p>)</span>
            <span class=k>assert</span> <span class=n>n_samples</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;n_samples must be a positive integer &gt; 1&quot;</span>
            <span class=c1># determine ds from number of desired points:</span>
            <span class=n>ds</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>length</span> <span class=o>/</span> <span class=p>(</span><span class=n>n_samples</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>ds</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=c1># neither n_samples nor ds was specified, so assume defaults:</span>
            <span class=n>n_samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>((</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>250</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span> <span class=o>//</span> <span class=mi>2</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span><span class=p>))</span>
            <span class=n>ds</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>length</span> <span class=o>/</span> <span class=p>(</span><span class=n>n_samples</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

        <span class=c1># build list of points at which to evaluate the RegularlySampledAnalogSignalArray</span>

        <span class=c1># we exclude all empty intervals:</span>
        <span class=n>at</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=n>lengths</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lengths</span>
        <span class=n>empty_interval_ids</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argwhere</span><span class=p>(</span><span class=n>lengths</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
        <span class=n>first_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
        <span class=n>first_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>last_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
        <span class=n>last_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>first_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
            <span class=n>first_abscissavals_per_interval_idx</span>
        <span class=p>]</span>
        <span class=n>last_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
            <span class=n>last_abscissavals_per_interval_idx</span>
        <span class=p>]</span>

        <span class=k>for</span> <span class=n>ii</span><span class=p>,</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>lengths</span><span class=p>[</span><span class=n>ii</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=k>continue</span>
            <span class=n>newxvals</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>frange</span><span class=p>(</span>
                <span class=n>first_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>],</span>
                <span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>],</span>
                <span class=n>step</span><span class=o>=</span><span class=n>ds</span><span class=p>,</span>
            <span class=p>)</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
            <span class=n>at</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>newxvals</span><span class=p>)</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>newxvals</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>]:</span>
                    <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>
            <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
                <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>first_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>
                <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>

        <span class=n>_</span><span class=p>,</span> <span class=n>yvals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=n>at</span><span class=p>,</span> <span class=n>recalculate</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>store_interp</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
        <span class=n>yvals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>yvals</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>

        <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>yvals</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_fs</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>ds</span>

        <span class=k>return</span> <span class=n>asa</span>

    <span class=k>def</span><span class=w> </span><span class=nf>join</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Join another RegularlySampledAnalogSignalArray to this one.</span>

<span class=sd>        WARNING! Numerical precision might cause some epochs to be considered</span>
<span class=sd>        non-disjoint even when they really are, so a better check than ep1[ep2].isempty</span>
<span class=sd>        is to check for samples contained in the intersection of ep1 and ep2.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        other : RegularlySampledAnalogSignalArray</span>
<span class=sd>            RegularlySampledAnalogSignalArray (or derived type) to join to the current</span>
<span class=sd>            RegularlySampledAnalogSignalArray. Other must have the same number of signals as</span>
<span class=sd>            the current RegularlySampledAnalogSignalArray.</span>
<span class=sd>        mode : string, optional</span>
<span class=sd>            One of [&#39;max&#39;, &#39;min&#39;, &#39;left&#39;, &#39;right&#39;, &#39;mean&#39;]. Specifies how the</span>
<span class=sd>            signals are merged inside overlapping intervals. Default is &#39;left&#39;.</span>
<span class=sd>        inplace : boolean, optional</span>
<span class=sd>            If True, then current RegularlySampledAnalogSignalArray is modified. If False, then</span>
<span class=sd>            a copy with the joined result is returned. Default is False.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        out : RegularlySampledAnalogSignalArray</span>
<span class=sd>            Copy of RegularlySampledAnalogSignalArray where the new RegularlySampledAnalogSignalArray has been</span>
<span class=sd>            joined to the current RegularlySampledAnalogSignalArray.</span>
<span class=sd>        &quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>mode</span> <span class=o>=</span> <span class=s2>&quot;left&quot;</span>

        <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># copy without data since we change data at the end?</span>

        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
        <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>asa</span><span class=o>.</span><span class=n>n_signals</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>

        <span class=c1># if ASAs are disjoint:</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>]</span><span class=o>.</span><span class=n>length</span> <span class=o>&gt;</span> <span class=mi>50</span> <span class=o>*</span> <span class=n>float_info</span><span class=o>.</span><span class=n>epsilon</span><span class=p>:</span>
            <span class=c1># do a simple-as-butter join (concat) and sort</span>
            <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
            <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=k>else</span><span class=p>:</span>  <span class=c1># not disjoint</span>
            <span class=n>both_eps</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>]</span>
            <span class=n>self_eps</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span> <span class=o>-</span> <span class=n>both_eps</span> <span class=o>-</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span>
            <span class=n>other_eps</span> <span class=o>=</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span> <span class=o>-</span> <span class=n>both_eps</span> <span class=o>-</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span>

            <span class=k>if</span> <span class=n>mode</span> <span class=o>==</span> <span class=s2>&quot;left&quot;</span><span class=p>:</span>
                <span class=n>self_eps</span> <span class=o>+=</span> <span class=n>both_eps</span>
                <span class=c1># print(self_eps)</span>

                <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>self_eps</span><span class=p>]</span>
                <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>

                <span class=k>if</span> <span class=ow>not</span> <span class=n>other_eps</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                    <span class=n>tmp</span> <span class=o>=</span> <span class=n>other</span><span class=p>[</span><span class=n>other_eps</span><span class=p>]</span>
                    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                    <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
            <span class=k>elif</span> <span class=n>mode</span> <span class=o>==</span> <span class=s2>&quot;right&quot;</span><span class=p>:</span>
                <span class=n>other_eps</span> <span class=o>+=</span> <span class=n>both_eps</span>

                <span class=n>tmp</span> <span class=o>=</span> <span class=n>other</span><span class=p>[</span><span class=n>other_eps</span><span class=p>]</span>
                <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>

                <span class=k>if</span> <span class=ow>not</span> <span class=n>self_eps</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                    <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>self_eps</span><span class=p>]</span>
                    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                    <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span>
                    <span class=s2>&quot;asa.join() has not yet been implemented for mode &#39;</span><span class=si>{}</span><span class=s2>&#39;!&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                        <span class=n>mode</span>
                    <span class=p>)</span>
                <span class=p>)</span>

        <span class=n>sample_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>times</span><span class=p>)</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>times</span><span class=p>[</span><span class=n>sample_order</span><span class=p>]</span>
        <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>[:,</span> <span class=n>sample_order</span><span class=p>]</span>

        <span class=n>asa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>data</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>times</span>
        <span class=n>dom1</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>domain</span>
        <span class=n>dom2</span> <span class=o>=</span> <span class=n>other</span><span class=o>.</span><span class=n>domain</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>)</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span>
        <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>domain</span> <span class=o>=</span> <span class=p>(</span><span class=n>dom1</span> <span class=o>+</span> <span class=n>dom2</span><span class=p>)</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>asa</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_pdf</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>bins</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Return the probability distribution function for each signal.&quot;&quot;&quot;</span>
        <span class=kn>from</span><span class=w> </span><span class=nn>scipy</span><span class=w> </span><span class=kn>import</span> <span class=n>integrate</span>

        <span class=k>if</span> <span class=n>bins</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>bins</span> <span class=o>=</span> <span class=mi>100</span>

        <span class=k>if</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>n_samples</span> <span class=o>=</span> <span class=mi>100</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span><span class=s2>&quot;multiple signals not supported yet!&quot;</span><span class=p>)</span>

        <span class=c1># fx, bins = np.histogram(self.data.squeeze(), bins=bins, normed=True)</span>
        <span class=n>fx</span><span class=p>,</span> <span class=n>bins</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>histogram</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(),</span> <span class=n>bins</span><span class=o>=</span><span class=n>bins</span><span class=p>)</span>
        <span class=n>bin_centers</span> <span class=o>=</span> <span class=p>(</span><span class=n>bins</span> <span class=o>+</span> <span class=p>(</span><span class=n>bins</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>bins</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>

        <span class=n>Ifx</span> <span class=o>=</span> <span class=n>integrate</span><span class=o>.</span><span class=n>simps</span><span class=p>(</span><span class=n>fx</span><span class=p>,</span> <span class=n>bin_centers</span><span class=p>)</span>

        <span class=n>pdf</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)(</span>
            <span class=n>abscissa_vals</span><span class=o>=</span><span class=n>bin_centers</span><span class=p>,</span>
            <span class=n>data</span><span class=o>=</span><span class=n>fx</span> <span class=o>/</span> <span class=n>Ifx</span><span class=p>,</span>
            <span class=n>fs</span><span class=o>=</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>bin_centers</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>bin_centers</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span>
            <span class=n>support</span><span class=o>=</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>min</span><span class=p>(),</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>max</span><span class=p>()),</span>
        <span class=p>)</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>n_samples</span><span class=o>=</span><span class=n>n_samples</span><span class=p>)</span>

        <span class=k>return</span> <span class=n>pdf</span>

        <span class=c1># data = []</span>
        <span class=c1># for signal in self.data:</span>
        <span class=c1>#     fx, bins = np.histogram(signal, bins=bins)</span>
        <span class=c1>#     bin_centers = (bins + (bins[1]-bins[0])/2)[:-1]</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_cdf</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;Return the probability distribution function for each signal.&quot;&quot;&quot;</span>

        <span class=k>if</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>n_samples</span> <span class=o>=</span> <span class=mi>100</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span><span class=s2>&quot;multiple signals not supported yet!&quot;</span><span class=p>)</span>

        <span class=n>X</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>squeeze</span><span class=p>())</span>
        <span class=n>F</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span><span class=p>))</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span><span class=p>)</span>

        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
        <span class=n>cdf</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)(</span>
            <span class=n>abscissa_vals</span><span class=o>=</span><span class=n>X</span><span class=p>,</span>
            <span class=n>data</span><span class=o>=</span><span class=n>F</span><span class=p>,</span>
            <span class=n>support</span><span class=o>=</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>min</span><span class=p>(),</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>max</span><span class=p>()),</span>
        <span class=p>)</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>n_samples</span><span class=o>=</span><span class=n>n_samples</span><span class=p>)</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>

        <span class=k>return</span> <span class=n>cdf</span>

    <span class=k>def</span><span class=w> </span><span class=nf>_eegplot</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ax</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>normalize</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>pad</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>fill</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>        </span><span class=sd>&quot;&quot;&quot;custom_func docstring goes here.&quot;&quot;&quot;</span>

        <span class=kn>import</span><span class=w> </span><span class=nn>matplotlib.pyplot</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nn>plt</span>

        <span class=kn>from</span><span class=w> </span><span class=nn>..plotting</span><span class=w> </span><span class=kn>import</span> <span class=n>utils</span> <span class=k>as</span> <span class=n>plotutils</span>

        <span class=k>if</span> <span class=n>ax</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>gca</span><span class=p>()</span>

        <span class=n>xmin</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>min</span>
        <span class=n>xmax</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>max</span>
        <span class=n>xvals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span>

        <span class=k>if</span> <span class=n>pad</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>pad</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>

        <span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

        <span class=k>if</span> <span class=n>normalize</span><span class=p>:</span>
            <span class=n>peak_vals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>max</span><span class=p>()</span>
            <span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=n>data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>peak_vals</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>

        <span class=n>n_traces</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span>

        <span class=k>for</span> <span class=n>tt</span><span class=p>,</span> <span class=n>trace</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
            <span class=k>if</span> <span class=n>color</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
                <span class=n>line</span> <span class=o>=</span> <span class=n>ax</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span>
                    <span class=n>xvals</span><span class=p>,</span> <span class=n>tt</span> <span class=o>*</span> <span class=n>pad</span> <span class=o>+</span> <span class=n>trace</span><span class=p>,</span> <span class=n>zorder</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=mi>10</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>n_traces</span> <span class=o>-</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>tt</span><span class=p>)</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>line</span> <span class=o>=</span> <span class=n>ax</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span>
                    <span class=n>xvals</span><span class=p>,</span>
                    <span class=n>tt</span> <span class=o>*</span> <span class=n>pad</span> <span class=o>+</span> <span class=n>trace</span><span class=p>,</span>
                    <span class=n>zorder</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=mi>10</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>n_traces</span> <span class=o>-</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>tt</span><span class=p>),</span>
                    <span class=n>color</span><span class=o>=</span><span class=n>color</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>if</span> <span class=n>fill</span><span class=p>:</span>
                <span class=c1># Get the color from the current curve</span>
                <span class=n>fillcolor</span> <span class=o>=</span> <span class=n>line</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>get_color</span><span class=p>()</span>
                <span class=n>ax</span><span class=o>.</span><span class=n>fill_between</span><span class=p>(</span>
                    <span class=n>xvals</span><span class=p>,</span>
                    <span class=n>tt</span> <span class=o>*</span> <span class=n>pad</span><span class=p>,</span>
                    <span class=n>tt</span> <span class=o>*</span> <span class=n>pad</span> <span class=o>+</span> <span class=n>trace</span><span class=p>,</span>
                    <span class=n>alpha</span><span class=o>=</span><span class=mf>0.3</span><span class=p>,</span>
                    <span class=n>color</span><span class=o>=</span><span class=n>fillcolor</span><span class=p>,</span>
                    <span class=n>zorder</span><span class=o>=</span><span class=nb>int</span><span class=p>(</span><span class=mi>10</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>n_traces</span> <span class=o>-</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>tt</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span>
                <span class=p>)</span>

        <span class=n>ax</span><span class=o>.</span><span class=n>set_xlim</span><span class=p>(</span><span class=n>xmin</span><span class=p>,</span> <span class=n>xmax</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>pad</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
            <span class=c1># yticks = np.arange(n_traces)*pad + 0.5*pad</span>
            <span class=n>yticks</span> <span class=o>=</span> <span class=p>[]</span>
            <span class=n>ax</span><span class=o>.</span><span class=n>set_yticks</span><span class=p>(</span><span class=n>yticks</span><span class=p>)</span>
            <span class=n>ax</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>label</span><span class=p>)</span>
            <span class=n>ax</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>label</span><span class=p>)</span>
            <span class=n>plotutils</span><span class=o>.</span><span class=n>no_yticks</span><span class=p>(</span><span class=n>ax</span><span class=p>)</span>
            <span class=n>plotutils</span><span class=o>.</span><span class=n>clear_left</span><span class=p>(</span><span class=n>ax</span><span class=p>)</span>

        <span class=n>plotutils</span><span class=o>.</span><span class=n>clear_top</span><span class=p>(</span><span class=n>ax</span><span class=p>)</span>
        <span class=n>plotutils</span><span class=o>.</span><span class=n>clear_right</span><span class=p>(</span><span class=n>ax</span><span class=p>)</span>

        <span class=k>return</span> <span class=n>ax</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__setattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
        <span class=c1># https://stackoverflow.com/questions/4017572/how-can-i-make-an-alias-to-a-non-function-member-attribute-in-a-python-class</span>
        <span class=n>name</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
        <span class=nb>object</span><span class=o>.</span><span class=fm>__setattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__getattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
        <span class=c1># https://stackoverflow.com/questions/4017572/how-can-i-make-an-alias-to-a-non-function-member-attribute-in-a-python-class</span>
        <span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s2>&quot;aliases&quot;</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>AttributeError</span>  <span class=c1># http://nedbatchelder.com/blog/201010/surprising_getattr_recursion.html</span>
        <span class=n>name</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>__aliases__</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
        <span class=c1># return getattr(self, name) #Causes infinite recursion on non-existent attribute</span>
        <span class=k>return</span> <span class=nb>object</span><span class=o>.</span><span class=fm>__getattribute__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> <div class="doc doc-children"> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abs class="doc doc-heading"> <code class="highlight language-python"><span class=nb>abs</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>RegularlySampledAnalogSignalArray with absolute value of (potentially complex) data.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.abscissa_vals class="doc doc-heading"> <code class="highlight language-python"><span class=n>abscissa_vals</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> <small class="doc doc-label doc-label-writable"><code>writable</code></small> </span> </h3> <div class="doc doc-contents "> <p>(np.array 1D) Time in seconds.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.angle class="doc doc-heading"> <code class="highlight language-python"><span class=n>angle</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>RegularlySampledAnalogSignalArray with only phase angle (in radians) of data.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.base_unit class="doc doc-heading"> <code class="highlight language-python"><span class=n>base_unit</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>Base unit of the abscissa.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.data class="doc doc-heading"> <code class="highlight language-python"><span class=n>data</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> <small class="doc doc-label doc-label-writable"><code>writable</code></small> </span> </h3> <div class="doc doc-contents "> <p>(np.array N-Dimensional) data with shape (n_signals, n_samples).</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.domain class="doc doc-heading"> <code class="highlight language-python"><span class=n>domain</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> <small class="doc doc-label doc-label-writable"><code>writable</code></small> </span> </h3> <div class="doc doc-contents "> <p>(nelpy.IntervalArray) The domain of the underlying RegularlySampledAnalogSignalArray.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.fs class="doc doc-heading"> <code class="highlight language-python"><span class=n>fs</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(float) Sampling frequency.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.imag class="doc doc-heading"> <code class="highlight language-python"><span class=n>imag</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>RegularlySampledAnalogSignalArray with only imaginary part of data.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.iscomplex class="doc doc-heading"> <code class="highlight language-python"><span class=n>iscomplex</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>Returns True if any part of the signal is complex.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isempty class="doc doc-heading"> <code class="highlight language-python"><span class=n>isempty</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(bool) checks length of data input</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.isreal class="doc doc-heading"> <code class="highlight language-python"><span class=n>isreal</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>Returns True if entire signal is real.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.labels class="doc doc-heading"> <code class="highlight language-python"><span class=n>labels</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(list) The labels corresponding to each signal.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.lengths class="doc doc-heading"> <code class="highlight language-python"><span class=n>lengths</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(list) The number of samples in each interval.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_bytes class="doc doc-heading"> <code class="highlight language-python"><span class=n>n_bytes</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>Approximate number of bytes taken up by object.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_intervals class="doc doc-heading"> <code class="highlight language-python"><span class=n>n_intervals</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(int) number of intervals in RegularlySampledAnalogSignalArray</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_samples class="doc doc-heading"> <code class="highlight language-python"><span class=n>n_samples</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(int) number of abscissa samples where signal is defined.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.n_signals class="doc doc-heading"> <code class="highlight language-python"><span class=n>n_signals</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>(int) The number of signals.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.range class="doc doc-heading"> <code class="highlight language-python"><span class=nb>range</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> <small class="doc doc-label doc-label-writable"><code>writable</code></small> </span> </h3> <div class="doc doc-contents "> <p>(nelpy.IntervalArray) The range of the underlying RegularlySampledAnalogSignalArray.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.real class="doc doc-heading"> <code class="highlight language-python"><span class=n>real</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>RegularlySampledAnalogSignalArray with only real part of data.</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.signals class="doc doc-heading"> <code class="highlight language-python"><span class=n>signals</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>Returns a list of RegularlySampledAnalogSignalArrays, each array containing a single signal (channel).</p> <p>WARNING: this method creates a copy of each signal, so is not particularly efficient at this time.</p> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=k>for</span> <span class=n>channel</span> <span class=ow>in</span> <span class=n>lfp</span><span class=o>.</span><span class=n>signals</span><span class=p>:</span>
<span class=go>    print(channel)</span>
</code></pre></div> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.step class="doc doc-heading"> <code class="highlight language-python"><span class=n>step</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> </span> </h3> <div class="doc doc-contents "> <p>steps per sample Example 1: sample_numbers = np.array([1,2,3,4,5,6]) #aka time Steps per sample in the above case would be 1</p> <p>Example 2: sample_numbers = np.array([1,3,5,7,9]) #aka time Steps per sample in Example 2 would be 2</p> </div> </div> <div class="doc doc-object doc-attribute"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.support class="doc doc-heading"> <code class="highlight language-python"><span class=n>support</span></code> <span class="doc doc-labels"> <small class="doc doc-label doc-label-property"><code>property</code></small> <small class="doc doc-label doc-label-writable"><code>writable</code></small> </span> </h3> <div class="doc doc-contents "> <p>(nelpy.IntervalArray) The support of the underlying RegularlySampledAnalogSignalArray.</p> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.add_signal class="doc doc-heading"> <code class="highlight language-python"><span class=n>add_signal</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Docstring goes here. Basically we add a signal, and we add a label. THIS HAPPENS IN PLACE?</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1186</span>
<span class=normal>1187</span>
<span class=normal>1188</span>
<span class=normal>1189</span>
<span class=normal>1190</span>
<span class=normal>1191</span>
<span class=normal>1192</span>
<span class=normal>1193</span>
<span class=normal>1194</span>
<span class=normal>1195</span>
<span class=normal>1196</span>
<span class=normal>1197</span>
<span class=normal>1198</span>
<span class=normal>1199</span>
<span class=normal>1200</span>
<span class=normal>1201</span>
<span class=normal>1202</span>
<span class=normal>1203</span>
<span class=normal>1204</span>
<span class=normal>1205</span>
<span class=normal>1206</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>add_signal</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>signal</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Docstring goes here.</span>
<span class=sd>    Basically we add a signal, and we add a label. THIS HAPPENS IN PLACE?</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=c1># TODO: add functionality to check that supports are the same, etc.</span>
    <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
        <span class=n>signal</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>data</span>

    <span class=n>signal</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>signal</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>signal</span><span class=o>.</span><span class=n>ndim</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;Can only add one signal at a time!&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>ndim</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>(</span>
            <span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>),</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)]</span>
        <span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>vstack</span><span class=p>([</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>signal</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)])</span>
    <span class=k>if</span> <span class=n>label</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;None label appended&quot;</span><span class=p>)</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>_labels</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_labels</span><span class=p>,</span> <span class=n>label</span><span class=p>)</span>
    <span class=k>return</span> <span class=bp>self</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.asarray class="doc doc-heading"> <code class="highlight language-python"><span class=n>asarray</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>where</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>at</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;linear&#39;</span><span class=p>,</span> <span class=n>copy</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>bounds_error</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>fill_value</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span> <span class=n>assume_sorted</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>recalculate</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>store_interp</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>split_by_interval</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Return a data-like array at requested points, with optional interpolation.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>where</code> </td> <td> <code><span title=array_like>array_like</span> or <span title=tuple>tuple</span></code> </td> <td> <div class=doc-md-description> <p>Array corresponding to np where condition (e.g., where=(data[1,:]&gt;5)).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>at</code> </td> <td> <code><span title=array_like>array_like</span></code> </td> <td> <div class=doc-md-description> <p>Array of points to evaluate array at. If None, uses self._abscissa_vals.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_samples</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of points to interpolate at, distributed uniformly from support start to stop.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>split_by_interval</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, separate arrays by intervals and return in a list.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>kind</code> </td> <td> <code><span title=str>str</span></code> </td> <td> <div class=doc-md-description> <p>Interpolation method. Default is 'linear'.</p> </div> </td> <td> <code>&#39;linear&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>copy</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, returns a copy. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>bounds_error</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, raises an error for out-of-bounds interpolation. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>fill_value</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Value to use for out-of-bounds points. Default is np.nan.</p> </div> </td> <td> <code><span title=numpy.nan>nan</span></code> </td> </tr> <tr class=doc-section-item> <td> <code>assume_sorted</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, assumes input is sorted. Default is None.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>recalculate</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, recalculates the interpolation. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>store_interp</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, stores the interpolation object. Default is True.</p> </div> </td> <td> <code>True</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><span title=collections.namedtuple>namedtuple</span>(<span title=xvals>xvals</span>, <span title=yvals>yvals</span>)</code> </td> <td> <div class=doc-md-description> <p>xvals: array of abscissa values for which data are returned. yvals: array of shape (n_signals, n_samples) with interpolated data.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>xvals</span><span class=p>,</span> <span class=n>yvals</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2173</span>
<span class=normal>2174</span>
<span class=normal>2175</span>
<span class=normal>2176</span>
<span class=normal>2177</span>
<span class=normal>2178</span>
<span class=normal>2179</span>
<span class=normal>2180</span>
<span class=normal>2181</span>
<span class=normal>2182</span>
<span class=normal>2183</span>
<span class=normal>2184</span>
<span class=normal>2185</span>
<span class=normal>2186</span>
<span class=normal>2187</span>
<span class=normal>2188</span>
<span class=normal>2189</span>
<span class=normal>2190</span>
<span class=normal>2191</span>
<span class=normal>2192</span>
<span class=normal>2193</span>
<span class=normal>2194</span>
<span class=normal>2195</span>
<span class=normal>2196</span>
<span class=normal>2197</span>
<span class=normal>2198</span>
<span class=normal>2199</span>
<span class=normal>2200</span>
<span class=normal>2201</span>
<span class=normal>2202</span>
<span class=normal>2203</span>
<span class=normal>2204</span>
<span class=normal>2205</span>
<span class=normal>2206</span>
<span class=normal>2207</span>
<span class=normal>2208</span>
<span class=normal>2209</span>
<span class=normal>2210</span>
<span class=normal>2211</span>
<span class=normal>2212</span>
<span class=normal>2213</span>
<span class=normal>2214</span>
<span class=normal>2215</span>
<span class=normal>2216</span>
<span class=normal>2217</span>
<span class=normal>2218</span>
<span class=normal>2219</span>
<span class=normal>2220</span>
<span class=normal>2221</span>
<span class=normal>2222</span>
<span class=normal>2223</span>
<span class=normal>2224</span>
<span class=normal>2225</span>
<span class=normal>2226</span>
<span class=normal>2227</span>
<span class=normal>2228</span>
<span class=normal>2229</span>
<span class=normal>2230</span>
<span class=normal>2231</span>
<span class=normal>2232</span>
<span class=normal>2233</span>
<span class=normal>2234</span>
<span class=normal>2235</span>
<span class=normal>2236</span>
<span class=normal>2237</span>
<span class=normal>2238</span>
<span class=normal>2239</span>
<span class=normal>2240</span>
<span class=normal>2241</span>
<span class=normal>2242</span>
<span class=normal>2243</span>
<span class=normal>2244</span>
<span class=normal>2245</span>
<span class=normal>2246</span>
<span class=normal>2247</span>
<span class=normal>2248</span>
<span class=normal>2249</span>
<span class=normal>2250</span>
<span class=normal>2251</span>
<span class=normal>2252</span>
<span class=normal>2253</span>
<span class=normal>2254</span>
<span class=normal>2255</span>
<span class=normal>2256</span>
<span class=normal>2257</span>
<span class=normal>2258</span>
<span class=normal>2259</span>
<span class=normal>2260</span>
<span class=normal>2261</span>
<span class=normal>2262</span>
<span class=normal>2263</span>
<span class=normal>2264</span>
<span class=normal>2265</span>
<span class=normal>2266</span>
<span class=normal>2267</span>
<span class=normal>2268</span>
<span class=normal>2269</span>
<span class=normal>2270</span>
<span class=normal>2271</span>
<span class=normal>2272</span>
<span class=normal>2273</span>
<span class=normal>2274</span>
<span class=normal>2275</span>
<span class=normal>2276</span>
<span class=normal>2277</span>
<span class=normal>2278</span>
<span class=normal>2279</span>
<span class=normal>2280</span>
<span class=normal>2281</span>
<span class=normal>2282</span>
<span class=normal>2283</span>
<span class=normal>2284</span>
<span class=normal>2285</span>
<span class=normal>2286</span>
<span class=normal>2287</span>
<span class=normal>2288</span>
<span class=normal>2289</span>
<span class=normal>2290</span>
<span class=normal>2291</span>
<span class=normal>2292</span>
<span class=normal>2293</span>
<span class=normal>2294</span>
<span class=normal>2295</span>
<span class=normal>2296</span>
<span class=normal>2297</span>
<span class=normal>2298</span>
<span class=normal>2299</span>
<span class=normal>2300</span>
<span class=normal>2301</span>
<span class=normal>2302</span>
<span class=normal>2303</span>
<span class=normal>2304</span>
<span class=normal>2305</span>
<span class=normal>2306</span>
<span class=normal>2307</span>
<span class=normal>2308</span>
<span class=normal>2309</span>
<span class=normal>2310</span>
<span class=normal>2311</span>
<span class=normal>2312</span>
<span class=normal>2313</span>
<span class=normal>2314</span>
<span class=normal>2315</span>
<span class=normal>2316</span>
<span class=normal>2317</span>
<span class=normal>2318</span>
<span class=normal>2319</span>
<span class=normal>2320</span>
<span class=normal>2321</span>
<span class=normal>2322</span>
<span class=normal>2323</span>
<span class=normal>2324</span>
<span class=normal>2325</span>
<span class=normal>2326</span>
<span class=normal>2327</span>
<span class=normal>2328</span>
<span class=normal>2329</span>
<span class=normal>2330</span>
<span class=normal>2331</span>
<span class=normal>2332</span>
<span class=normal>2333</span>
<span class=normal>2334</span>
<span class=normal>2335</span>
<span class=normal>2336</span>
<span class=normal>2337</span>
<span class=normal>2338</span>
<span class=normal>2339</span>
<span class=normal>2340</span>
<span class=normal>2341</span>
<span class=normal>2342</span>
<span class=normal>2343</span>
<span class=normal>2344</span>
<span class=normal>2345</span>
<span class=normal>2346</span>
<span class=normal>2347</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>asarray</span><span class=p>(</span>
    <span class=bp>self</span><span class=p>,</span>
    <span class=o>*</span><span class=p>,</span>
    <span class=n>where</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>at</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>kind</span><span class=o>=</span><span class=s2>&quot;linear&quot;</span><span class=p>,</span>
    <span class=n>copy</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
    <span class=n>bounds_error</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=n>fill_value</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>nan</span><span class=p>,</span>
    <span class=n>assume_sorted</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>recalculate</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=n>store_interp</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
    <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>split_by_interval</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
<span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Return a data-like array at requested points, with optional interpolation.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    where : array_like or tuple, optional</span>
<span class=sd>        Array corresponding to np where condition (e.g., where=(data[1,:]&gt;5)).</span>
<span class=sd>    at : array_like, optional</span>
<span class=sd>        Array of points to evaluate array at. If None, uses self._abscissa_vals.</span>
<span class=sd>    n_samples : int, optional</span>
<span class=sd>        Number of points to interpolate at, distributed uniformly from support start to stop.</span>
<span class=sd>    split_by_interval : bool, optional</span>
<span class=sd>        If True, separate arrays by intervals and return in a list.</span>
<span class=sd>    kind : str, optional</span>
<span class=sd>        Interpolation method. Default is &#39;linear&#39;.</span>
<span class=sd>    copy : bool, optional</span>
<span class=sd>        If True, returns a copy. Default is True.</span>
<span class=sd>    bounds_error : bool, optional</span>
<span class=sd>        If True, raises an error for out-of-bounds interpolation. Default is False.</span>
<span class=sd>    fill_value : float, optional</span>
<span class=sd>        Value to use for out-of-bounds points. Default is np.nan.</span>
<span class=sd>    assume_sorted : bool, optional</span>
<span class=sd>        If True, assumes input is sorted. Default is None.</span>
<span class=sd>    recalculate : bool, optional</span>
<span class=sd>        If True, recalculates the interpolation. Default is False.</span>
<span class=sd>    store_interp : bool, optional</span>
<span class=sd>        If True, stores the interpolation object. Default is True.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : namedtuple (xvals, yvals)</span>
<span class=sd>        xvals: array of abscissa values for which data are returned.</span>
<span class=sd>        yvals: array of shape (n_signals, n_samples) with interpolated data.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; xvals, yvals = asa.asarray(at=[0, 1, 2])</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=c1># TODO: implement splitting by interval</span>

    <span class=k>if</span> <span class=n>split_by_interval</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span><span class=s2>&quot;split_by_interval not yet implemented...&quot;</span><span class=p>)</span>

    <span class=n>XYArray</span> <span class=o>=</span> <span class=n>namedtuple</span><span class=p>(</span><span class=s2>&quot;XYArray&quot;</span><span class=p>,</span> <span class=p>[</span><span class=s2>&quot;xvals&quot;</span><span class=p>,</span> <span class=s2>&quot;yvals&quot;</span><span class=p>])</span>

    <span class=k>if</span> <span class=p>(</span>
        <span class=n>at</span> <span class=ow>is</span> <span class=kc>None</span>
        <span class=ow>and</span> <span class=n>where</span> <span class=ow>is</span> <span class=kc>None</span>
        <span class=ow>and</span> <span class=n>split_by_interval</span> <span class=ow>is</span> <span class=kc>False</span>
        <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span>
    <span class=p>):</span>
        <span class=n>xyarray</span> <span class=o>=</span> <span class=n>XYArray</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_data_rowsig</span><span class=o>.</span><span class=n>squeeze</span><span class=p>())</span>
        <span class=k>return</span> <span class=n>xyarray</span>

    <span class=k>if</span> <span class=n>where</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>assert</span> <span class=n>at</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>,</span> <span class=p>(</span>
            <span class=s2>&quot;&#39;where&#39;, &#39;at&#39;, and &#39;n_samples&#39; cannot be used at the same time&quot;</span>
        <span class=p>)</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>where</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>):</span>
            <span class=n>y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>where</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=n>x</span> <span class=o>=</span> <span class=n>where</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
            <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>y</span><span class=p>),</span> <span class=p>(</span>
                <span class=s2>&quot;&#39;where&#39; condition and array must have same number of elements&quot;</span>
            <span class=p>)</span>
            <span class=n>at</span> <span class=o>=</span> <span class=n>y</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>where</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>),</span> <span class=p>(</span>
                <span class=s2>&quot;&#39;where&#39; condition must have same number of elements as self._abscissa_vals&quot;</span>
            <span class=p>)</span>
            <span class=n>at</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
    <span class=k>elif</span> <span class=n>at</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>assert</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>,</span> <span class=p>(</span>
            <span class=s2>&quot;&#39;at&#39; and &#39;n_samples&#39; cannot be used at the same time&quot;</span>
        <span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>at</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>start</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>stop</span><span class=p>,</span> <span class=n>n_samples</span><span class=p>)</span>

    <span class=n>at</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>at</span><span class=o>.</span><span class=n>ndim</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;Requested points must be one-dimensional!&quot;</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>at</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;No points were requested to interpolate&quot;</span><span class=p>)</span>

    <span class=c1># if we made it this far, either at or where has been specified, and at is now well defined.</span>

    <span class=n>kwargs</span> <span class=o>=</span> <span class=p>{</span>
        <span class=s2>&quot;kind&quot;</span><span class=p>:</span> <span class=n>kind</span><span class=p>,</span>
        <span class=s2>&quot;copy&quot;</span><span class=p>:</span> <span class=n>copy</span><span class=p>,</span>
        <span class=s2>&quot;bounds_error&quot;</span><span class=p>:</span> <span class=n>bounds_error</span><span class=p>,</span>
        <span class=s2>&quot;fill_value&quot;</span><span class=p>:</span> <span class=n>fill_value</span><span class=p>,</span>
        <span class=s2>&quot;assume_sorted&quot;</span><span class=p>:</span> <span class=n>assume_sorted</span><span class=p>,</span>
    <span class=p>}</span>

    <span class=c1># retrieve an existing, or construct a new interpolation object</span>
    <span class=k>if</span> <span class=n>recalculate</span><span class=p>:</span>
        <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span>
            <span class=k>if</span> <span class=n>interpobj</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
                <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>  <span class=c1># does not exist yet</span>
            <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

    <span class=c1># store interpolation object, if desired</span>
    <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>

    <span class=c1># do not interpolate points that lie outside the support</span>
    <span class=n>interval_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>[:,</span> <span class=p>:,</span> <span class=kc>None</span><span class=p>]</span>
    <span class=c1># use broadcasting to check in a vectorized manner if</span>
    <span class=c1># each sample falls within the support, haha aren&#39;t we clever?</span>
    <span class=c1># (n_intervals, n_requested_samples)</span>
    <span class=n>valid</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>logical_and</span><span class=p>(</span>
        <span class=n>at</span> <span class=o>&gt;=</span> <span class=n>interval_data</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>:],</span> <span class=n>at</span> <span class=o>&lt;=</span> <span class=n>interval_data</span><span class=p>[:,</span> <span class=mi>1</span><span class=p>,</span> <span class=p>:]</span>
    <span class=p>)</span>
    <span class=n>valid_mask</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>valid</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>n_invalid</span> <span class=o>=</span> <span class=n>at</span><span class=o>.</span><span class=n>size</span> <span class=o>-</span> <span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>valid_mask</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>n_invalid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
        <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
            <span class=s2>&quot;</span><span class=si>{}</span><span class=s2> values outside the support were removed&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>n_invalid</span><span class=p>)</span>
        <span class=p>)</span>
    <span class=n>at</span> <span class=o>=</span> <span class=n>at</span><span class=p>[</span><span class=n>valid_mask</span><span class=p>]</span>

    <span class=c1># do the actual interpolation</span>
    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span>
                    <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>),</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>SystemError</span><span class=p>:</span>
            <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>
            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span>
                    <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>),</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span>
                    <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>SystemError</span><span class=p>:</span>
            <span class=n>interpobj</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_interp1d</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>store_interp</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>_interp</span> <span class=o>=</span> <span class=n>interpobj</span>
            <span class=n>out</span> <span class=o>=</span> <span class=n>interpobj</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>

    <span class=n>xyarray</span> <span class=o>=</span> <span class=n>XYArray</span><span class=p>(</span><span class=n>xvals</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>at</span><span class=p>),</span> <span class=n>yvals</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>out</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>xyarray</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.center class="doc doc-heading"> <code class="highlight language-python"><span class=n>center</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Center the data to have zero mean along the sample axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, modifies the data in place. If False (default), returns a new object.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The centered signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>centered</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>center</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>centered</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span>
<span class=go>0.0</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>671</span>
<span class=normal>672</span>
<span class=normal>673</span>
<span class=normal>674</span>
<span class=normal>675</span>
<span class=normal>676</span>
<span class=normal>677</span>
<span class=normal>678</span>
<span class=normal>679</span>
<span class=normal>680</span>
<span class=normal>681</span>
<span class=normal>682</span>
<span class=normal>683</span>
<span class=normal>684</span>
<span class=normal>685</span>
<span class=normal>686</span>
<span class=normal>687</span>
<span class=normal>688</span>
<span class=normal>689</span>
<span class=normal>690</span>
<span class=normal>691</span>
<span class=normal>692</span>
<span class=normal>693</span>
<span class=normal>694</span>
<span class=normal>695</span>
<span class=normal>696</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>center</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Center the data to have zero mean along the sample axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    inplace : bool, optional</span>
<span class=sd>        If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The centered signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; centered = asa.center()</span>
<span class=sd>    &gt;&gt;&gt; centered.mean()</span>
<span class=sd>    0.0</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span><span class=o>.</span><span class=n>T</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.clip class="doc doc-heading"> <code class="highlight language-python"><span class=n>clip</span><span class=p>(</span><span class=nb>min</span><span class=p>,</span> <span class=nb>max</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Clip (limit) the values in the data to the interval [min, max].</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>min</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Minimum value.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>max</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Maximum value.</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>New object with clipped data.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>clipped</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>clip</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1987</span>
<span class=normal>1988</span>
<span class=normal>1989</span>
<span class=normal>1990</span>
<span class=normal>1991</span>
<span class=normal>1992</span>
<span class=normal>1993</span>
<span class=normal>1994</span>
<span class=normal>1995</span>
<span class=normal>1996</span>
<span class=normal>1997</span>
<span class=normal>1998</span>
<span class=normal>1999</span>
<span class=normal>2000</span>
<span class=normal>2001</span>
<span class=normal>2002</span>
<span class=normal>2003</span>
<span class=normal>2004</span>
<span class=normal>2005</span>
<span class=normal>2006</span>
<span class=normal>2007</span>
<span class=normal>2008</span>
<span class=normal>2009</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>clip</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=nb>min</span><span class=p>,</span> <span class=nb>max</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Clip (limit) the values in the data to the interval [min, max].</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    min : float</span>
<span class=sd>        Minimum value.</span>
<span class=sd>    max : float</span>
<span class=sd>        Maximum value.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        New object with clipped data.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; clipped = asa.clip(-1, 1)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>clip</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=nb>min</span><span class=p>,</span> <span class=nb>max</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.copy class="doc doc-heading"> <code class="highlight language-python"><span class=n>copy</span><span class=p>()</span></code> </h3> <div class="doc doc-contents "> <p>Return a copy of the current object.</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1873</span>
<span class=normal>1874</span>
<span class=normal>1875</span>
<span class=normal>1876</span>
<span class=normal>1877</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>copy</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Return a copy of the current object.&quot;&quot;&quot;</span>
    <span class=n>out</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
    <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.ddt class="doc doc-heading"> <code class="highlight language-python"><span class=n>ddt</span><span class=p>(</span><span class=n>rectify</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Returns the derivative of each signal in the RegularlySampledAnalogSignalArray.</p> <p>asa.data = f(t) asa.ddt = d/dt (asa.data)</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>rectify</code> </td> <td> <code><span title=boolean>boolean</span></code> </td> <td> <div class=doc-md-description> <p>If True, the absolute value of the derivative will be returned. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>ddt</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>Time derivative of each signal in the RegularlySampledAnalogSignalArray.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Note</summary> <p>Second order central differences are used here, and it is assumed that the signals are sampled uniformly. If the signals are not uniformly sampled, it is recommended to resample the signal before computing the derivative.</p> </details> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>884</span>
<span class=normal>885</span>
<span class=normal>886</span>
<span class=normal>887</span>
<span class=normal>888</span>
<span class=normal>889</span>
<span class=normal>890</span>
<span class=normal>891</span>
<span class=normal>892</span>
<span class=normal>893</span>
<span class=normal>894</span>
<span class=normal>895</span>
<span class=normal>896</span>
<span class=normal>897</span>
<span class=normal>898</span>
<span class=normal>899</span>
<span class=normal>900</span>
<span class=normal>901</span>
<span class=normal>902</span>
<span class=normal>903</span>
<span class=normal>904</span>
<span class=normal>905</span>
<span class=normal>906</span>
<span class=normal>907</span>
<span class=normal>908</span>
<span class=normal>909</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>ddt</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>rectify</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Returns the derivative of each signal in the RegularlySampledAnalogSignalArray.</span>

<span class=sd>    asa.data = f(t)</span>
<span class=sd>    asa.ddt = d/dt (asa.data)</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    rectify : boolean, optional</span>
<span class=sd>        If True, the absolute value of the derivative will be returned.</span>
<span class=sd>        Default is False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    ddt : RegularlySampledAnalogSignalArray</span>
<span class=sd>        Time derivative of each signal in the RegularlySampledAnalogSignalArray.</span>

<span class=sd>    Note</span>
<span class=sd>    ----</span>
<span class=sd>    Second order central differences are used here, and it is assumed that</span>
<span class=sd>    the signals are sampled uniformly. If the signals are not uniformly</span>
<span class=sd>    sampled, it is recommended to resample the signal before computing the</span>
<span class=sd>    derivative.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>ddt</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>ddt_asa</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>rectify</span><span class=o>=</span><span class=n>rectify</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>ddt</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.downsample class="doc doc-heading"> <code class="highlight language-python"><span class=n>downsample</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>fs_out</span><span class=p>,</span> <span class=n>aafilter</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Downsamples the RegularlySampledAnalogSignalArray</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>fs_out</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Desired output sampling rate in Hz</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>aafilter</code> </td> <td> <code><span title=boolean>boolean</span></code> </td> <td> <div class=doc-md-description> <p>Whether to apply an anti-aliasing filter before performing the actual downsampling. Default is True</p> </div> </td> <td> <code>True</code> </td> </tr> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=boolean>boolean</span></code> </td> <td> <div class=doc-md-description> <p>If True, the output ASA will replace the input ASA. Default is False</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>kwargs</code> </td> <td> </td> <td> <div class=doc-md-description> <p>Other keyword arguments are passed to sosfiltfilt() in the <code>filtering</code> module</p> </div> </td> <td> <code>{}</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The downsampled RegularlySampledAnalogSignalArray</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1149</span>
<span class=normal>1150</span>
<span class=normal>1151</span>
<span class=normal>1152</span>
<span class=normal>1153</span>
<span class=normal>1154</span>
<span class=normal>1155</span>
<span class=normal>1156</span>
<span class=normal>1157</span>
<span class=normal>1158</span>
<span class=normal>1159</span>
<span class=normal>1160</span>
<span class=normal>1161</span>
<span class=normal>1162</span>
<span class=normal>1163</span>
<span class=normal>1164</span>
<span class=normal>1165</span>
<span class=normal>1166</span>
<span class=normal>1167</span>
<span class=normal>1168</span>
<span class=normal>1169</span>
<span class=normal>1170</span>
<span class=normal>1171</span>
<span class=normal>1172</span>
<span class=normal>1173</span>
<span class=normal>1174</span>
<span class=normal>1175</span>
<span class=normal>1176</span>
<span class=normal>1177</span>
<span class=normal>1178</span>
<span class=normal>1179</span>
<span class=normal>1180</span>
<span class=normal>1181</span>
<span class=normal>1182</span>
<span class=normal>1183</span>
<span class=normal>1184</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>downsample</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs_out</span><span class=p>,</span> <span class=n>aafilter</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Downsamples the RegularlySampledAnalogSignalArray</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    fs_out : float, optional</span>
<span class=sd>        Desired output sampling rate in Hz</span>
<span class=sd>    aafilter : boolean, optional</span>
<span class=sd>        Whether to apply an anti-aliasing filter before performing the actual</span>
<span class=sd>        downsampling. Default is True</span>
<span class=sd>    inplace : boolean, optional</span>
<span class=sd>        If True, the output ASA will replace the input ASA. Default is False</span>
<span class=sd>    kwargs :</span>
<span class=sd>        Other keyword arguments are passed to sosfiltfilt() in the `filtering`</span>
<span class=sd>        module</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The downsampled RegularlySampledAnalogSignalArray</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=ow>not</span> <span class=n>fs_out</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>_fs</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;fs_out must be less than current sampling rate!&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>aafilter</span><span class=p>:</span>
        <span class=n>fh</span> <span class=o>=</span> <span class=n>fs_out</span> <span class=o>/</span> <span class=mf>2.0</span>
        <span class=n>out</span> <span class=o>=</span> <span class=n>filtering</span><span class=o>.</span><span class=n>sosfiltfilt</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>fl</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>fh</span><span class=o>=</span><span class=n>fh</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=n>inplace</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

    <span class=n>downsampled</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=mi>1</span> <span class=o>/</span> <span class=n>fs_out</span><span class=p>)</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>downsampled</span><span class=o>.</span><span class=n>_data</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>downsampled</span><span class=o>.</span><span class=n>_abscissa_vals</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_fs</span> <span class=o>=</span> <span class=n>fs_out</span>

    <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.empty class="doc doc-heading"> <code class="highlight language-python"><span class=n>empty</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Remove data (but not metadata) from RegularlySampledAnalogSignalArray.</p> <p>Attributes 'data', 'abscissa_vals', and 'support' are all emptied.</p> <p>Note: n_signals is preserved.</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1790</span>
<span class=normal>1791</span>
<span class=normal>1792</span>
<span class=normal>1793</span>
<span class=normal>1794</span>
<span class=normal>1795</span>
<span class=normal>1796</span>
<span class=normal>1797</span>
<span class=normal>1798</span>
<span class=normal>1799</span>
<span class=normal>1800</span>
<span class=normal>1801</span>
<span class=normal>1802</span>
<span class=normal>1803</span>
<span class=normal>1804</span>
<span class=normal>1805</span>
<span class=normal>1806</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>empty</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Remove data (but not metadata) from RegularlySampledAnalogSignalArray.</span>

<span class=sd>    Attributes &#39;data&#39;, &#39;abscissa_vals&#39;, and &#39;support&#39; are all emptied.</span>

<span class=sd>    Note: n_signals is preserved.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>n_signals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_signals</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_copy_without_data</span><span class=p>()</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>n_signals</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)(</span><span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.join class="doc doc-heading"> <code class="highlight language-python"><span class=n>join</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Join another RegularlySampledAnalogSignalArray to this one.</p> <p>WARNING! Numerical precision might cause some epochs to be considered non-disjoint even when they really are, so a better check than ep1[ep2].isempty is to check for samples contained in the intersection of ep1 and ep2.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>other</code> </td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>RegularlySampledAnalogSignalArray (or derived type) to join to the current RegularlySampledAnalogSignalArray. Other must have the same number of signals as the current RegularlySampledAnalogSignalArray.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>mode</code> </td> <td> <code><span title=string>string</span></code> </td> <td> <div class=doc-md-description> <p>One of ['max', 'min', 'left', 'right', 'mean']. Specifies how the signals are merged inside overlapping intervals. Default is 'left'.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=boolean>boolean</span></code> </td> <td> <div class=doc-md-description> <p>If True, then current RegularlySampledAnalogSignalArray is modified. If False, then a copy with the joined result is returned. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>Copy of RegularlySampledAnalogSignalArray where the new RegularlySampledAnalogSignalArray has been joined to the current RegularlySampledAnalogSignalArray.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2468</span>
<span class=normal>2469</span>
<span class=normal>2470</span>
<span class=normal>2471</span>
<span class=normal>2472</span>
<span class=normal>2473</span>
<span class=normal>2474</span>
<span class=normal>2475</span>
<span class=normal>2476</span>
<span class=normal>2477</span>
<span class=normal>2478</span>
<span class=normal>2479</span>
<span class=normal>2480</span>
<span class=normal>2481</span>
<span class=normal>2482</span>
<span class=normal>2483</span>
<span class=normal>2484</span>
<span class=normal>2485</span>
<span class=normal>2486</span>
<span class=normal>2487</span>
<span class=normal>2488</span>
<span class=normal>2489</span>
<span class=normal>2490</span>
<span class=normal>2491</span>
<span class=normal>2492</span>
<span class=normal>2493</span>
<span class=normal>2494</span>
<span class=normal>2495</span>
<span class=normal>2496</span>
<span class=normal>2497</span>
<span class=normal>2498</span>
<span class=normal>2499</span>
<span class=normal>2500</span>
<span class=normal>2501</span>
<span class=normal>2502</span>
<span class=normal>2503</span>
<span class=normal>2504</span>
<span class=normal>2505</span>
<span class=normal>2506</span>
<span class=normal>2507</span>
<span class=normal>2508</span>
<span class=normal>2509</span>
<span class=normal>2510</span>
<span class=normal>2511</span>
<span class=normal>2512</span>
<span class=normal>2513</span>
<span class=normal>2514</span>
<span class=normal>2515</span>
<span class=normal>2516</span>
<span class=normal>2517</span>
<span class=normal>2518</span>
<span class=normal>2519</span>
<span class=normal>2520</span>
<span class=normal>2521</span>
<span class=normal>2522</span>
<span class=normal>2523</span>
<span class=normal>2524</span>
<span class=normal>2525</span>
<span class=normal>2526</span>
<span class=normal>2527</span>
<span class=normal>2528</span>
<span class=normal>2529</span>
<span class=normal>2530</span>
<span class=normal>2531</span>
<span class=normal>2532</span>
<span class=normal>2533</span>
<span class=normal>2534</span>
<span class=normal>2535</span>
<span class=normal>2536</span>
<span class=normal>2537</span>
<span class=normal>2538</span>
<span class=normal>2539</span>
<span class=normal>2540</span>
<span class=normal>2541</span>
<span class=normal>2542</span>
<span class=normal>2543</span>
<span class=normal>2544</span>
<span class=normal>2545</span>
<span class=normal>2546</span>
<span class=normal>2547</span>
<span class=normal>2548</span>
<span class=normal>2549</span>
<span class=normal>2550</span>
<span class=normal>2551</span>
<span class=normal>2552</span>
<span class=normal>2553</span>
<span class=normal>2554</span>
<span class=normal>2555</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>join</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Join another RegularlySampledAnalogSignalArray to this one.</span>

<span class=sd>    WARNING! Numerical precision might cause some epochs to be considered</span>
<span class=sd>    non-disjoint even when they really are, so a better check than ep1[ep2].isempty</span>
<span class=sd>    is to check for samples contained in the intersection of ep1 and ep2.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    other : RegularlySampledAnalogSignalArray</span>
<span class=sd>        RegularlySampledAnalogSignalArray (or derived type) to join to the current</span>
<span class=sd>        RegularlySampledAnalogSignalArray. Other must have the same number of signals as</span>
<span class=sd>        the current RegularlySampledAnalogSignalArray.</span>
<span class=sd>    mode : string, optional</span>
<span class=sd>        One of [&#39;max&#39;, &#39;min&#39;, &#39;left&#39;, &#39;right&#39;, &#39;mean&#39;]. Specifies how the</span>
<span class=sd>        signals are merged inside overlapping intervals. Default is &#39;left&#39;.</span>
<span class=sd>    inplace : boolean, optional</span>
<span class=sd>        If True, then current RegularlySampledAnalogSignalArray is modified. If False, then</span>
<span class=sd>        a copy with the joined result is returned. Default is False.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        Copy of RegularlySampledAnalogSignalArray where the new RegularlySampledAnalogSignalArray has been</span>
<span class=sd>        joined to the current RegularlySampledAnalogSignalArray.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>mode</span> <span class=o>=</span> <span class=s2>&quot;left&quot;</span>

    <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># copy without data since we change data at the end?</span>

    <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>asa</span><span class=o>.</span><span class=n>n_signals</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>

    <span class=c1># if ASAs are disjoint:</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>]</span><span class=o>.</span><span class=n>length</span> <span class=o>&gt;</span> <span class=mi>50</span> <span class=o>*</span> <span class=n>float_info</span><span class=o>.</span><span class=n>epsilon</span><span class=p>:</span>
        <span class=c1># do a simple-as-butter join (concat) and sort</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
        <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
        <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>other</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
    <span class=k>else</span><span class=p>:</span>  <span class=c1># not disjoint</span>
        <span class=n>both_eps</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>[</span><span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>]</span>
        <span class=n>self_eps</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span> <span class=o>-</span> <span class=n>both_eps</span> <span class=o>-</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span>
        <span class=n>other_eps</span> <span class=o>=</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span> <span class=o>-</span> <span class=n>both_eps</span> <span class=o>-</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span>

        <span class=k>if</span> <span class=n>mode</span> <span class=o>==</span> <span class=s2>&quot;left&quot;</span><span class=p>:</span>
            <span class=n>self_eps</span> <span class=o>+=</span> <span class=n>both_eps</span>
            <span class=c1># print(self_eps)</span>

            <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>self_eps</span><span class=p>]</span>
            <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>

            <span class=k>if</span> <span class=ow>not</span> <span class=n>other_eps</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                <span class=n>tmp</span> <span class=o>=</span> <span class=n>other</span><span class=p>[</span><span class=n>other_eps</span><span class=p>]</span>
                <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=k>elif</span> <span class=n>mode</span> <span class=o>==</span> <span class=s2>&quot;right&quot;</span><span class=p>:</span>
            <span class=n>other_eps</span> <span class=o>+=</span> <span class=n>both_eps</span>

            <span class=n>tmp</span> <span class=o>=</span> <span class=n>other</span><span class=p>[</span><span class=n>other_eps</span><span class=p>]</span>
            <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>

            <span class=k>if</span> <span class=ow>not</span> <span class=n>self_eps</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
                <span class=n>tmp</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>self_eps</span><span class=p>]</span>
                <span class=n>times</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>)</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>hstack</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=n>tmp</span><span class=o>.</span><span class=n>data</span><span class=p>))</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span>
                <span class=s2>&quot;asa.join() has not yet been implemented for mode &#39;</span><span class=si>{}</span><span class=s2>&#39;!&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=n>mode</span>
                <span class=p>)</span>
            <span class=p>)</span>

    <span class=n>sample_order</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>times</span><span class=p>)</span>
    <span class=n>times</span> <span class=o>=</span> <span class=n>times</span><span class=p>[</span><span class=n>sample_order</span><span class=p>]</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=p>[:,</span> <span class=n>sample_order</span><span class=p>]</span>

    <span class=n>asa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>data</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>times</span>
    <span class=n>dom1</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>domain</span>
    <span class=n>dom2</span> <span class=o>=</span> <span class=n>other</span><span class=o>.</span><span class=n>domain</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span> <span class=o>+</span> <span class=n>other</span><span class=o>.</span><span class=n>support</span><span class=p>)</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>domain</span> <span class=o>=</span> <span class=p>(</span><span class=n>dom1</span> <span class=o>+</span> <span class=n>dom2</span><span class=p>)</span><span class=o>.</span><span class=n>merge</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>asa</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.max class="doc doc-heading"> <code class="highlight language-python"><span class=nb>max</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Compute the maximum value of the data along the specified axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Axis along which to compute the maximum (default is 1).</p> </div> </td> <td> <code>1</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>max</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Maximum values along the specified axis.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1939</span>
<span class=normal>1940</span>
<span class=normal>1941</span>
<span class=normal>1942</span>
<span class=normal>1943</span>
<span class=normal>1944</span>
<span class=normal>1945</span>
<span class=normal>1946</span>
<span class=normal>1947</span>
<span class=normal>1948</span>
<span class=normal>1949</span>
<span class=normal>1950</span>
<span class=normal>1951</span>
<span class=normal>1952</span>
<span class=normal>1953</span>
<span class=normal>1954</span>
<span class=normal>1955</span>
<span class=normal>1956</span>
<span class=normal>1957</span>
<span class=normal>1958</span>
<span class=normal>1959</span>
<span class=normal>1960</span>
<span class=normal>1961</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>max</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the maximum value of the data along the specified axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    axis : int, optional</span>
<span class=sd>        Axis along which to compute the maximum (default is 1).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    max : np.ndarray</span>
<span class=sd>        Maximum values along the specified axis.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>maxes</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>amax</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
        <span class=k>if</span> <span class=n>maxes</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>maxes</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>maxes</span>
    <span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate maximum&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.mean class="doc doc-heading"> <code class="highlight language-python"><span class=n>mean</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Compute the mean of the data along the specified axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Axis along which to compute the mean (default is 1, i.e., across samples).</p> </div> </td> <td> <code>1</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>mean</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Mean values along the specified axis.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1891</span>
<span class=normal>1892</span>
<span class=normal>1893</span>
<span class=normal>1894</span>
<span class=normal>1895</span>
<span class=normal>1896</span>
<span class=normal>1897</span>
<span class=normal>1898</span>
<span class=normal>1899</span>
<span class=normal>1900</span>
<span class=normal>1901</span>
<span class=normal>1902</span>
<span class=normal>1903</span>
<span class=normal>1904</span>
<span class=normal>1905</span>
<span class=normal>1906</span>
<span class=normal>1907</span>
<span class=normal>1908</span>
<span class=normal>1909</span>
<span class=normal>1910</span>
<span class=normal>1911</span>
<span class=normal>1912</span>
<span class=normal>1913</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>mean</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the mean of the data along the specified axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    axis : int, optional</span>
<span class=sd>        Axis along which to compute the mean (default is 1, i.e., across samples).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    mean : np.ndarray</span>
<span class=sd>        Mean values along the specified axis.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>means</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmean</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
        <span class=k>if</span> <span class=n>means</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>means</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>means</span>
    <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
            <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate mean&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.median class="doc doc-heading"> <code class="highlight language-python"><span class=n>median</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Returns the median of each signal in RegularlySampledAnalogSignalArray.</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1879</span>
<span class=normal>1880</span>
<span class=normal>1881</span>
<span class=normal>1882</span>
<span class=normal>1883</span>
<span class=normal>1884</span>
<span class=normal>1885</span>
<span class=normal>1886</span>
<span class=normal>1887</span>
<span class=normal>1888</span>
<span class=normal>1889</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>median</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Returns the median of each signal in RegularlySampledAnalogSignalArray.&quot;&quot;&quot;</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>medians</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanmedian</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
        <span class=k>if</span> <span class=n>medians</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>medians</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>medians</span>
    <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
            <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate median&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.min class="doc doc-heading"> <code class="highlight language-python"><span class=nb>min</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Compute the minimum value of the data along the specified axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Axis along which to compute the minimum (default is 1).</p> </div> </td> <td> <code>1</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>min</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Minimum values along the specified axis.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1963</span>
<span class=normal>1964</span>
<span class=normal>1965</span>
<span class=normal>1966</span>
<span class=normal>1967</span>
<span class=normal>1968</span>
<span class=normal>1969</span>
<span class=normal>1970</span>
<span class=normal>1971</span>
<span class=normal>1972</span>
<span class=normal>1973</span>
<span class=normal>1974</span>
<span class=normal>1975</span>
<span class=normal>1976</span>
<span class=normal>1977</span>
<span class=normal>1978</span>
<span class=normal>1979</span>
<span class=normal>1980</span>
<span class=normal>1981</span>
<span class=normal>1982</span>
<span class=normal>1983</span>
<span class=normal>1984</span>
<span class=normal>1985</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>min</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the minimum value of the data along the specified axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    axis : int, optional</span>
<span class=sd>        Axis along which to compute the minimum (default is 1).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    min : np.ndarray</span>
<span class=sd>        Minimum values along the specified axis.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>mins</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>amin</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
        <span class=k>if</span> <span class=n>mins</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>mins</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>mins</span>
    <span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate minimum&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.normalize class="doc doc-heading"> <code class="highlight language-python"><span class=n>normalize</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Normalize the data to have unit standard deviation along the sample axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, modifies the data in place. If False (default), returns a new object.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The normalized signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>normalized</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>normalize</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>normalized</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>
<span class=go>1.0</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>698</span>
<span class=normal>699</span>
<span class=normal>700</span>
<span class=normal>701</span>
<span class=normal>702</span>
<span class=normal>703</span>
<span class=normal>704</span>
<span class=normal>705</span>
<span class=normal>706</span>
<span class=normal>707</span>
<span class=normal>708</span>
<span class=normal>709</span>
<span class=normal>710</span>
<span class=normal>711</span>
<span class=normal>712</span>
<span class=normal>713</span>
<span class=normal>714</span>
<span class=normal>715</span>
<span class=normal>716</span>
<span class=normal>717</span>
<span class=normal>718</span>
<span class=normal>719</span>
<span class=normal>720</span>
<span class=normal>721</span>
<span class=normal>722</span>
<span class=normal>723</span>
<span class=normal>724</span>
<span class=normal>725</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>normalize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Normalize the data to have unit standard deviation along the sample axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    inplace : bool, optional</span>
<span class=sd>        If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The normalized signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; normalized = asa.normalize()</span>
<span class=sd>    &gt;&gt;&gt; normalized.std()</span>
<span class=sd>    1.0</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>std</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>std</span><span class=p>())</span>
    <span class=n>std</span><span class=p>[</span><span class=n>std</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>std</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.partition class="doc doc-heading"> <code class="highlight language-python"><span class=n>partition</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_intervals</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Returns an RegularlySampledAnalogSignalArray whose support has been partitioned.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>ds</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Maximum duration (in seconds), for each interval.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_samples</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of intervals. If ds is None and n_intervals is None, then default is to use n_intervals = 100</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>RegularlySampledAnalogSignalArray that has been partitioned.</p> </div> </td> </tr> </tbody> </table> <details class=note open> <summary>Notes</summary> <p>Irrespective of whether 'ds' or 'n_intervals' are used, the exact underlying support is propagated, and the first and last points of the supports are always included, even if this would cause n_samples or ds to be violated.</p> </details> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1590</span>
<span class=normal>1591</span>
<span class=normal>1592</span>
<span class=normal>1593</span>
<span class=normal>1594</span>
<span class=normal>1595</span>
<span class=normal>1596</span>
<span class=normal>1597</span>
<span class=normal>1598</span>
<span class=normal>1599</span>
<span class=normal>1600</span>
<span class=normal>1601</span>
<span class=normal>1602</span>
<span class=normal>1603</span>
<span class=normal>1604</span>
<span class=normal>1605</span>
<span class=normal>1606</span>
<span class=normal>1607</span>
<span class=normal>1608</span>
<span class=normal>1609</span>
<span class=normal>1610</span>
<span class=normal>1611</span>
<span class=normal>1612</span>
<span class=normal>1613</span>
<span class=normal>1614</span>
<span class=normal>1615</span>
<span class=normal>1616</span>
<span class=normal>1617</span>
<span class=normal>1618</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@keyword_equivalence</span><span class=p>(</span><span class=n>this_or_that</span><span class=o>=</span><span class=p>{</span><span class=s2>&quot;n_intervals&quot;</span><span class=p>:</span> <span class=s2>&quot;n_epochs&quot;</span><span class=p>})</span>
<span class=k>def</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_intervals</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Returns an RegularlySampledAnalogSignalArray whose support has been</span>
<span class=sd>    partitioned.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    ds : float, optional</span>
<span class=sd>        Maximum duration (in seconds), for each interval.</span>
<span class=sd>    n_samples : int, optional</span>
<span class=sd>        Number of intervals. If ds is None and n_intervals is None, then</span>
<span class=sd>        default is to use n_intervals = 100</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        RegularlySampledAnalogSignalArray that has been partitioned.</span>

<span class=sd>    Notes</span>
<span class=sd>    -----</span>
<span class=sd>    Irrespective of whether &#39;ds&#39; or &#39;n_intervals&#39; are used, the exact</span>
<span class=sd>    underlying support is propagated, and the first and last points</span>
<span class=sd>    of the supports are always included, even if this would cause</span>
<span class=sd>    n_samples or ds to be violated.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>partition</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=n>ds</span><span class=p>,</span> <span class=n>n_intervals</span><span class=o>=</span><span class=n>n_intervals</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.simplify class="doc doc-heading"> <code class="highlight language-python"><span class=n>simplify</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Returns an RegularlySampledAnalogSignalArray where the data has been simplified / subsampled.</p> <p>This function is primarily intended to be used for plotting and saving vector graphics without having too large file sizes as a result of too many points.</p> <p>Irrespective of whether 'ds' or 'n_samples' are used, the exact underlying support is propagated, and the first and last points of the supports are always included, even if this would cause n_samples or ds to be violated.</p> <p>WARNING! Simplify can create nan samples, when requesting a timestamp within an interval, but outside of the (first, last) abscissa_vals within that interval, since we don't extrapolate, but only interpolate. # TODO: fix</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>ds</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Time (in seconds), in which to step points.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>n_samples</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Number of points at which to intepolate data. If ds is None and n_samples is None, then default is to use n_samples=5,000</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>Copy of RegularlySampledAnalogSignalArray where data is only stored at the new subset of points.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2369</span>
<span class=normal>2370</span>
<span class=normal>2371</span>
<span class=normal>2372</span>
<span class=normal>2373</span>
<span class=normal>2374</span>
<span class=normal>2375</span>
<span class=normal>2376</span>
<span class=normal>2377</span>
<span class=normal>2378</span>
<span class=normal>2379</span>
<span class=normal>2380</span>
<span class=normal>2381</span>
<span class=normal>2382</span>
<span class=normal>2383</span>
<span class=normal>2384</span>
<span class=normal>2385</span>
<span class=normal>2386</span>
<span class=normal>2387</span>
<span class=normal>2388</span>
<span class=normal>2389</span>
<span class=normal>2390</span>
<span class=normal>2391</span>
<span class=normal>2392</span>
<span class=normal>2393</span>
<span class=normal>2394</span>
<span class=normal>2395</span>
<span class=normal>2396</span>
<span class=normal>2397</span>
<span class=normal>2398</span>
<span class=normal>2399</span>
<span class=normal>2400</span>
<span class=normal>2401</span>
<span class=normal>2402</span>
<span class=normal>2403</span>
<span class=normal>2404</span>
<span class=normal>2405</span>
<span class=normal>2406</span>
<span class=normal>2407</span>
<span class=normal>2408</span>
<span class=normal>2409</span>
<span class=normal>2410</span>
<span class=normal>2411</span>
<span class=normal>2412</span>
<span class=normal>2413</span>
<span class=normal>2414</span>
<span class=normal>2415</span>
<span class=normal>2416</span>
<span class=normal>2417</span>
<span class=normal>2418</span>
<span class=normal>2419</span>
<span class=normal>2420</span>
<span class=normal>2421</span>
<span class=normal>2422</span>
<span class=normal>2423</span>
<span class=normal>2424</span>
<span class=normal>2425</span>
<span class=normal>2426</span>
<span class=normal>2427</span>
<span class=normal>2428</span>
<span class=normal>2429</span>
<span class=normal>2430</span>
<span class=normal>2431</span>
<span class=normal>2432</span>
<span class=normal>2433</span>
<span class=normal>2434</span>
<span class=normal>2435</span>
<span class=normal>2436</span>
<span class=normal>2437</span>
<span class=normal>2438</span>
<span class=normal>2439</span>
<span class=normal>2440</span>
<span class=normal>2441</span>
<span class=normal>2442</span>
<span class=normal>2443</span>
<span class=normal>2444</span>
<span class=normal>2445</span>
<span class=normal>2446</span>
<span class=normal>2447</span>
<span class=normal>2448</span>
<span class=normal>2449</span>
<span class=normal>2450</span>
<span class=normal>2451</span>
<span class=normal>2452</span>
<span class=normal>2453</span>
<span class=normal>2454</span>
<span class=normal>2455</span>
<span class=normal>2456</span>
<span class=normal>2457</span>
<span class=normal>2458</span>
<span class=normal>2459</span>
<span class=normal>2460</span>
<span class=normal>2461</span>
<span class=normal>2462</span>
<span class=normal>2463</span>
<span class=normal>2464</span>
<span class=normal>2465</span>
<span class=normal>2466</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>simplify</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>ds</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>n_samples</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Returns an RegularlySampledAnalogSignalArray where the data has been</span>
<span class=sd>    simplified / subsampled.</span>

<span class=sd>    This function is primarily intended to be used for plotting and</span>
<span class=sd>    saving vector graphics without having too large file sizes as</span>
<span class=sd>    a result of too many points.</span>

<span class=sd>    Irrespective of whether &#39;ds&#39; or &#39;n_samples&#39; are used, the exact</span>
<span class=sd>    underlying support is propagated, and the first and last points</span>
<span class=sd>    of the supports are always included, even if this would cause</span>
<span class=sd>    n_samples or ds to be violated.</span>

<span class=sd>    WARNING! Simplify can create nan samples, when requesting a timestamp</span>
<span class=sd>    within an interval, but outside of the (first, last) abscissa_vals within that</span>
<span class=sd>    interval, since we don&#39;t extrapolate, but only interpolate. # TODO: fix</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    ds : float, optional</span>
<span class=sd>        Time (in seconds), in which to step points.</span>
<span class=sd>    n_samples : int, optional</span>
<span class=sd>        Number of points at which to intepolate data. If ds is None</span>
<span class=sd>        and n_samples is None, then default is to use n_samples=5,000</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        Copy of RegularlySampledAnalogSignalArray where data is only stored at the</span>
<span class=sd>        new subset of points.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=c1># legacy kwarg support:</span>
    <span class=n>n_points</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;n_points&quot;</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>n_points</span><span class=p>:</span>
        <span class=n>n_samples</span> <span class=o>=</span> <span class=n>n_points</span>

    <span class=k>if</span> <span class=n>ds</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;ds and n_samples cannot be used together&quot;</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>n_samples</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>assert</span> <span class=nb>float</span><span class=p>(</span><span class=n>n_samples</span><span class=p>)</span><span class=o>.</span><span class=n>is_integer</span><span class=p>(),</span> <span class=p>(</span>
            <span class=s2>&quot;n_samples must be a positive integer!&quot;</span>
        <span class=p>)</span>
        <span class=k>assert</span> <span class=n>n_samples</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&quot;n_samples must be a positive integer &gt; 1&quot;</span>
        <span class=c1># determine ds from number of desired points:</span>
        <span class=n>ds</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>length</span> <span class=o>/</span> <span class=p>(</span><span class=n>n_samples</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

    <span class=k>if</span> <span class=n>ds</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=c1># neither n_samples nor ds was specified, so assume defaults:</span>
        <span class=n>n_samples</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>min</span><span class=p>((</span><span class=mi>5000</span><span class=p>,</span> <span class=mi>250</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span> <span class=o>//</span> <span class=mi>2</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>n_samples</span><span class=p>))</span>
        <span class=n>ds</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>length</span> <span class=o>/</span> <span class=p>(</span><span class=n>n_samples</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

    <span class=c1># build list of points at which to evaluate the RegularlySampledAnalogSignalArray</span>

    <span class=c1># we exclude all empty intervals:</span>
    <span class=n>at</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>lengths</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lengths</span>
    <span class=n>empty_interval_ids</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argwhere</span><span class=p>(</span><span class=n>lengths</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
    <span class=n>first_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
    <span class=n>first_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>last_abscissavals_per_interval_idx</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>cumsum</span><span class=p>(</span><span class=n>lengths</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=n>last_abscissavals_per_interval_idx</span><span class=p>[</span><span class=n>empty_interval_ids</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>first_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
        <span class=n>first_abscissavals_per_interval_idx</span>
    <span class=p>]</span>
    <span class=n>last_abscissavals_per_interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa_vals</span><span class=p>[</span>
        <span class=n>last_abscissavals_per_interval_idx</span>
    <span class=p>]</span>

    <span class=k>for</span> <span class=n>ii</span><span class=p>,</span> <span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>data</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>lengths</span><span class=p>[</span><span class=n>ii</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=k>continue</span>
        <span class=n>newxvals</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>frange</span><span class=p>(</span>
            <span class=n>first_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>],</span>
            <span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>],</span>
            <span class=n>step</span><span class=o>=</span><span class=n>ds</span><span class=p>,</span>
        <span class=p>)</span><span class=o>.</span><span class=n>tolist</span><span class=p>()</span>
        <span class=n>at</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>newxvals</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>newxvals</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>]:</span>
                <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>
        <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
            <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>first_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>
            <span class=n>at</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>last_abscissavals_per_interval</span><span class=p>[</span><span class=n>ii</span><span class=p>])</span>

    <span class=n>_</span><span class=p>,</span> <span class=n>yvals</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>asarray</span><span class=p>(</span><span class=n>at</span><span class=o>=</span><span class=n>at</span><span class=p>,</span> <span class=n>recalculate</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>store_interp</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
    <span class=n>yvals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>yvals</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>

    <span class=n>asa</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>asanyarray</span><span class=p>(</span><span class=n>at</span><span class=p>)</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>yvals</span>
    <span class=n>asa</span><span class=o>.</span><span class=n>_fs</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>ds</span>

    <span class=k>return</span> <span class=n>asa</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.smooth class="doc doc-heading"> <code class="highlight language-python"><span class=n>smooth</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>sigma</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>truncate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>cval</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>within_intervals</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Smooths the regularly sampled RegularlySampledAnalogSignalArray with a Gaussian kernel.</p> <p>Smoothing is applied along the abscissa, and the same smoothing is applied to each signal in the RegularlySampledAnalogSignalArray, or to each unit in a BinnedSpikeTrainArray.</p> <p>Smoothing is applied ACROSS intervals, but smoothing WITHIN intervals is also supported.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>obj</code> </td> <td> <code>RegularlySampledAnalogSignalArray or BinnedSpikeTrainArray.</code> </td> <td> <div class=doc-md-description> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling rate (in obj.base_unit^-1) of obj. If not provided, it will be inferred.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>sigma</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Standard deviation of Gaussian kernel, in obj.base_units. Default is 0.05 (50 ms if base_unit=seconds).</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>truncate</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Bandwidth outside of which the filter value will be zero. Default is 4.0.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True the data will be replaced with the smoothed data. Default is False.</p> </div> </td> <td> <code>False</code> </td> </tr> <tr class=doc-section-item> <td> <code>mode</code> </td> <td> <code>(<span title=reflect>reflect</span>, <span title=constant>constant</span>, <span title=nearest>nearest</span>, <span title=mirror>mirror</span>, <a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.wrap>wrap</a>)</code> </td> <td> <div class=doc-md-description> <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to 'constant'. Default is 'reflect'.</p> </div> </td> <td> <code>&#39;reflect&#39;</code> </td> </tr> <tr class=doc-section-item> <td> <code>cval</code> </td> <td> <code><span title=scalar>scalar</span></code> </td> <td> <div class=doc-md-description> <p>Value to fill past edges of input if mode is 'constant'. Default is 0.0.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>within_intervals</code> </td> <td> <code><span title=boolean>boolean</span></code> </td> <td> <div class=doc-md-description> <p>If True, then smooth within each epoch. Otherwise smooth across epochs. Default is False. Note that when mode = 'wrap', then smoothing within epochs aren't affected by wrapping.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code>same type as obj</code> </td> <td> <div class=doc-md-description> <p>An object with smoothed data is returned.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1330</span>
<span class=normal>1331</span>
<span class=normal>1332</span>
<span class=normal>1333</span>
<span class=normal>1334</span>
<span class=normal>1335</span>
<span class=normal>1336</span>
<span class=normal>1337</span>
<span class=normal>1338</span>
<span class=normal>1339</span>
<span class=normal>1340</span>
<span class=normal>1341</span>
<span class=normal>1342</span>
<span class=normal>1343</span>
<span class=normal>1344</span>
<span class=normal>1345</span>
<span class=normal>1346</span>
<span class=normal>1347</span>
<span class=normal>1348</span>
<span class=normal>1349</span>
<span class=normal>1350</span>
<span class=normal>1351</span>
<span class=normal>1352</span>
<span class=normal>1353</span>
<span class=normal>1354</span>
<span class=normal>1355</span>
<span class=normal>1356</span>
<span class=normal>1357</span>
<span class=normal>1358</span>
<span class=normal>1359</span>
<span class=normal>1360</span>
<span class=normal>1361</span>
<span class=normal>1362</span>
<span class=normal>1363</span>
<span class=normal>1364</span>
<span class=normal>1365</span>
<span class=normal>1366</span>
<span class=normal>1367</span>
<span class=normal>1368</span>
<span class=normal>1369</span>
<span class=normal>1370</span>
<span class=normal>1371</span>
<span class=normal>1372</span>
<span class=normal>1373</span>
<span class=normal>1374</span>
<span class=normal>1375</span>
<span class=normal>1376</span>
<span class=normal>1377</span>
<span class=normal>1378</span>
<span class=normal>1379</span>
<span class=normal>1380</span>
<span class=normal>1381</span>
<span class=normal>1382</span>
<span class=normal>1383</span>
<span class=normal>1384</span>
<span class=normal>1385</span>
<span class=normal>1386</span>
<span class=normal>1387</span>
<span class=normal>1388</span>
<span class=normal>1389</span>
<span class=normal>1390</span>
<span class=normal>1391</span>
<span class=normal>1392</span>
<span class=normal>1393</span>
<span class=normal>1394</span>
<span class=normal>1395</span>
<span class=normal>1396</span>
<span class=normal>1397</span>
<span class=normal>1398</span>
<span class=normal>1399</span>
<span class=normal>1400</span>
<span class=normal>1401</span>
<span class=normal>1402</span>
<span class=normal>1403</span>
<span class=normal>1404</span>
<span class=normal>1405</span>
<span class=normal>1406</span>
<span class=normal>1407</span>
<span class=normal>1408</span>
<span class=normal>1409</span>
<span class=normal>1410</span>
<span class=normal>1411</span>
<span class=normal>1412</span>
<span class=normal>1413</span>
<span class=normal>1414</span>
<span class=normal>1415</span>
<span class=normal>1416</span>
<span class=normal>1417</span>
<span class=normal>1418</span>
<span class=normal>1419</span>
<span class=normal>1420</span>
<span class=normal>1421</span>
<span class=normal>1422</span>
<span class=normal>1423</span>
<span class=normal>1424</span>
<span class=normal>1425</span>
<span class=normal>1426</span>
<span class=normal>1427</span>
<span class=normal>1428</span>
<span class=normal>1429</span>
<span class=normal>1430</span>
<span class=normal>1431</span>
<span class=normal>1432</span>
<span class=normal>1433</span>
<span class=normal>1434</span>
<span class=normal>1435</span>
<span class=normal>1436</span>
<span class=normal>1437</span>
<span class=normal>1438</span>
<span class=normal>1439</span>
<span class=normal>1440</span>
<span class=normal>1441</span>
<span class=normal>1442</span>
<span class=normal>1443</span>
<span class=normal>1444</span>
<span class=normal>1445</span>
<span class=normal>1446</span>
<span class=normal>1447</span>
<span class=normal>1448</span>
<span class=normal>1449</span>
<span class=normal>1450</span>
<span class=normal>1451</span>
<span class=normal>1452</span>
<span class=normal>1453</span>
<span class=normal>1454</span>
<span class=normal>1455</span>
<span class=normal>1456</span>
<span class=normal>1457</span>
<span class=normal>1458</span>
<span class=normal>1459</span>
<span class=normal>1460</span>
<span class=normal>1461</span>
<span class=normal>1462</span>
<span class=normal>1463</span>
<span class=normal>1464</span>
<span class=normal>1465</span>
<span class=normal>1466</span>
<span class=normal>1467</span>
<span class=normal>1468</span>
<span class=normal>1469</span>
<span class=normal>1470</span>
<span class=normal>1471</span>
<span class=normal>1472</span>
<span class=normal>1473</span>
<span class=normal>1474</span>
<span class=normal>1475</span>
<span class=normal>1476</span>
<span class=normal>1477</span>
<span class=normal>1478</span>
<span class=normal>1479</span>
<span class=normal>1480</span>
<span class=normal>1481</span>
<span class=normal>1482</span>
<span class=normal>1483</span>
<span class=normal>1484</span>
<span class=normal>1485</span>
<span class=normal>1486</span>
<span class=normal>1487</span>
<span class=normal>1488</span>
<span class=normal>1489</span>
<span class=normal>1490</span>
<span class=normal>1491</span>
<span class=normal>1492</span>
<span class=normal>1493</span>
<span class=normal>1494</span>
<span class=normal>1495</span>
<span class=normal>1496</span>
<span class=normal>1497</span>
<span class=normal>1498</span>
<span class=normal>1499</span>
<span class=normal>1500</span>
<span class=normal>1501</span>
<span class=normal>1502</span>
<span class=normal>1503</span>
<span class=normal>1504</span>
<span class=normal>1505</span>
<span class=normal>1506</span>
<span class=normal>1507</span>
<span class=normal>1508</span>
<span class=normal>1509</span>
<span class=normal>1510</span>
<span class=normal>1511</span>
<span class=normal>1512</span>
<span class=normal>1513</span>
<span class=normal>1514</span>
<span class=normal>1515</span>
<span class=normal>1516</span>
<span class=normal>1517</span>
<span class=normal>1518</span>
<span class=normal>1519</span>
<span class=normal>1520</span>
<span class=normal>1521</span>
<span class=normal>1522</span>
<span class=normal>1523</span>
<span class=normal>1524</span>
<span class=normal>1525</span>
<span class=normal>1526</span>
<span class=normal>1527</span>
<span class=normal>1528</span>
<span class=normal>1529</span>
<span class=normal>1530</span>
<span class=normal>1531</span>
<span class=normal>1532</span>
<span class=normal>1533</span>
<span class=normal>1534</span>
<span class=normal>1535</span>
<span class=normal>1536</span>
<span class=normal>1537</span>
<span class=normal>1538</span>
<span class=normal>1539</span>
<span class=normal>1540</span>
<span class=normal>1541</span>
<span class=normal>1542</span>
<span class=normal>1543</span></pre></div></td><td class=code><div><pre><span></span><code><span class=nd>@keyword_deprecation</span><span class=p>(</span><span class=n>replace_x_with_y</span><span class=o>=</span><span class=p>{</span><span class=s2>&quot;bw&quot;</span><span class=p>:</span> <span class=s2>&quot;truncate&quot;</span><span class=p>})</span>
<span class=k>def</span><span class=w> </span><span class=nf>smooth</span><span class=p>(</span>
    <span class=bp>self</span><span class=p>,</span>
    <span class=o>*</span><span class=p>,</span>
    <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>sigma</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>truncate</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
    <span class=n>mode</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>cval</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
    <span class=n>within_intervals</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
<span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Smooths the regularly sampled RegularlySampledAnalogSignalArray with a Gaussian kernel.</span>

<span class=sd>    Smoothing is applied along the abscissa, and the same smoothing is applied to each</span>
<span class=sd>    signal in the RegularlySampledAnalogSignalArray, or to each unit in a BinnedSpikeTrainArray.</span>

<span class=sd>    Smoothing is applied ACROSS intervals, but smoothing WITHIN intervals is also supported.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    obj : RegularlySampledAnalogSignalArray or BinnedSpikeTrainArray.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Sampling rate (in obj.base_unit^-1) of obj. If not provided, it will</span>
<span class=sd>        be inferred.</span>
<span class=sd>    sigma : float, optional</span>
<span class=sd>        Standard deviation of Gaussian kernel, in obj.base_units. Default is 0.05</span>
<span class=sd>        (50 ms if base_unit=seconds).</span>
<span class=sd>    truncate : float, optional</span>
<span class=sd>        Bandwidth outside of which the filter value will be zero. Default is 4.0.</span>
<span class=sd>    inplace : bool</span>
<span class=sd>        If True the data will be replaced with the smoothed data.</span>
<span class=sd>        Default is False.</span>
<span class=sd>    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class=sd>        The mode parameter determines how the array borders are handled,</span>
<span class=sd>        where cval is the value when mode is equal to &#39;constant&#39;. Default is</span>
<span class=sd>        &#39;reflect&#39;.</span>
<span class=sd>    cval : scalar, optional</span>
<span class=sd>        Value to fill past edges of input if mode is &#39;constant&#39;. Default is 0.0.</span>
<span class=sd>    within_intervals : boolean, optional</span>
<span class=sd>        If True, then smooth within each epoch. Otherwise smooth across epochs.</span>
<span class=sd>        Default is False.</span>
<span class=sd>        Note that when mode = &#39;wrap&#39;, then smoothing within epochs aren&#39;t affected</span>
<span class=sd>        by wrapping.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : same type as obj</span>
<span class=sd>        An object with smoothed data is returned.</span>

<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>if</span> <span class=n>sigma</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>sigma</span> <span class=o>=</span> <span class=mf>0.05</span>
    <span class=k>if</span> <span class=n>truncate</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>truncate</span> <span class=o>=</span> <span class=mi>4</span>

    <span class=n>kwargs</span> <span class=o>=</span> <span class=p>{</span>
        <span class=s2>&quot;inplace&quot;</span><span class=p>:</span> <span class=n>inplace</span><span class=p>,</span>
        <span class=s2>&quot;fs&quot;</span><span class=p>:</span> <span class=n>fs</span><span class=p>,</span>
        <span class=s2>&quot;sigma&quot;</span><span class=p>:</span> <span class=n>sigma</span><span class=p>,</span>
        <span class=s2>&quot;truncate&quot;</span><span class=p>:</span> <span class=n>truncate</span><span class=p>,</span>
        <span class=s2>&quot;mode&quot;</span><span class=p>:</span> <span class=n>mode</span><span class=p>,</span>
        <span class=s2>&quot;cval&quot;</span><span class=p>:</span> <span class=n>cval</span><span class=p>,</span>
        <span class=s2>&quot;within_intervals&quot;</span><span class=p>:</span> <span class=n>within_intervals</span><span class=p>,</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
        <span class=n>ord_is_wrapped</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_wrapped</span>

        <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>unwrap</span><span class=p>()</span>

    <span class=c1># case 1: abs.wrapping=False, ord.linking=False, ord.wrapping=False</span>
    <span class=k>if</span> <span class=p>(</span>
        <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>pass</span>

    <span class=c1># case 2: abs.wrapping=False, ord.linking=False, ord.wrapping=True</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>pass</span>

    <span class=c1># case 3: abs.wrapping=False, ord.linking=True, ord.wrapping=False</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span>

    <span class=c1># case 4: abs.wrapping=False, ord.linking=True, ord.wrapping=True</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span>

    <span class=c1># case 5: abs.wrapping=True, ord.linking=False, ord.wrapping=False</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>if</span> <span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;mode&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&quot;wrap&quot;</span>

    <span class=c1># case 6: abs.wrapping=True, ord.linking=False, ord.wrapping=True</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=c1># (1) unwrap ordinate (abscissa wrap=False)</span>
        <span class=c1># (2) smooth unwrapped ordinate (absissa wrap=False)</span>
        <span class=c1># (3) repeat unwrapped signal based on conditions from (2):</span>
        <span class=c1># if smoothed wrapped ordinate samples</span>
        <span class=c1># HH ==&gt; SSS (this must be done on a per-signal basis!!!) H = high; L = low; S = same</span>
        <span class=c1># LL ==&gt; SSS (the vertical offset must be such that neighbors have smallest displacement)</span>
        <span class=c1># LH ==&gt; LSH</span>
        <span class=c1># HL ==&gt; HSL</span>
        <span class=c1># (4) smooth expanded and unwrapped ordinate (abscissa wrap=False)</span>
        <span class=c1># (5) cut out orignal signal</span>

        <span class=c1># (1)</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;mode&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=s2>&quot;reflect&quot;</span>
        <span class=n>L</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span>
        <span class=n>D</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>domain</span><span class=o>.</span><span class=n>length</span>

        <span class=n>tmp</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>unwrap</span><span class=p>(),</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=c1># (2) (3)</span>
        <span class=n>n_reps</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>ceil</span><span class=p>((</span><span class=n>sigma</span> <span class=o>*</span> <span class=n>truncate</span><span class=p>)</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=n>D</span><span class=p>)))</span>

        <span class=n>smooth_data</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>ss</span><span class=p>,</span> <span class=n>signal</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>tmp</span><span class=o>.</span><span class=n>signals</span><span class=p>):</span>
            <span class=c1># signal = signal.wrap()</span>
            <span class=n>offset</span> <span class=o>=</span> <span class=p>(</span>
                <span class=nb>float</span><span class=p>((</span><span class=n>signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[:,</span> <span class=mi>0</span><span class=p>])</span> <span class=o>//</span> <span class=p>(</span><span class=n>L</span> <span class=o>/</span> <span class=mi>2</span><span class=p>))</span> <span class=o>*</span> <span class=n>L</span>
            <span class=p>)</span>
            <span class=c1># print(offset)</span>
            <span class=c1># left_high = signal._data[:,0] &gt;= out._ordinate.range.min + L/2</span>
            <span class=c1># right_high = signal._data[:,-1] &gt;= out._ordinate.range.min + L/2</span>
            <span class=c1># signal = signal.unwrap()</span>

            <span class=n>expanded</span> <span class=o>=</span> <span class=n>signal</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
            <span class=k>for</span> <span class=n>nn</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_reps</span><span class=p>):</span>
                <span class=n>expanded</span> <span class=o>=</span> <span class=n>expanded</span><span class=o>.</span><span class=n>join</span><span class=p>((</span><span class=n>signal</span> <span class=o>&lt;&lt;</span> <span class=n>D</span> <span class=o>*</span> <span class=p>(</span><span class=n>nn</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=o>-</span> <span class=n>offset</span><span class=p>)</span><span class=o>.</span><span class=n>join</span><span class=p>(</span>
                    <span class=p>(</span><span class=n>signal</span> <span class=o>&gt;&gt;</span> <span class=n>D</span> <span class=o>*</span> <span class=p>(</span><span class=n>nn</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=o>+</span> <span class=n>offset</span>
                <span class=p>)</span>
                <span class=c1># print(expanded)</span>
                <span class=c1># if left_high == right_high:</span>
                <span class=c1>#     print(&#39;extending flat! signal {}&#39;.format(ss))</span>
                <span class=c1>#     expanded = expanded.join(signal &lt;&lt; D*(nn+1)).join(signal &gt;&gt; D*(nn+1))</span>
                <span class=c1># elif left_high &lt; right_high:</span>
                <span class=c1>#     print(&#39;extending LSH! signal {}&#39;.format(ss))</span>
                <span class=c1>#     # LSH</span>
                <span class=c1>#     expanded = expanded.join((signal &lt;&lt; D*(nn+1))-L).join((signal &gt;&gt; D*(nn+1))+L)</span>
                <span class=c1># else:</span>
                <span class=c1>#     # HSL</span>
                <span class=c1>#     print(&#39;extending HSL! signal {}&#39;.format(ss))</span>
                <span class=c1>#     expanded = expanded.join((signal &lt;&lt; D*(nn+1))+L).join((signal &gt;&gt; D*(nn+1))-L)</span>
            <span class=c1># (4)</span>
            <span class=n>smooth_signal</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>expanded</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=n>smooth_data</span><span class=o>.</span><span class=n>append</span><span class=p>(</span>
                <span class=n>smooth_signal</span><span class=o>.</span><span class=n>_data</span><span class=p>[</span>
                    <span class=p>:,</span> <span class=n>n_reps</span> <span class=o>*</span> <span class=n>tmp</span><span class=o>.</span><span class=n>n_samples</span> <span class=p>:</span> <span class=p>(</span><span class=n>n_reps</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>tmp</span><span class=o>.</span><span class=n>n_samples</span><span class=p>)</span>
                <span class=p>]</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
            <span class=p>)</span>
        <span class=c1># (5)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>smooth_data</span><span class=p>)</span>
        <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>wrap</span><span class=p>()</span>

        <span class=k>return</span> <span class=n>out</span>

    <span class=c1># case 7: abs.wrapping=True, ord.linking=True, ord.wrapping=False</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span>

    <span class=c1># case 8: abs.wrapping=True, ord.linking=True, ord.wrapping=True</span>
    <span class=k>elif</span> <span class=p>(</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>is_wrapping</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_linking</span>
        <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span>
    <span class=p>):</span>
        <span class=k>raise</span> <span class=ne>NotImplementedError</span>

    <span class=n>out</span> <span class=o>=</span> <span class=n>utils</span><span class=o>.</span><span class=n>gaussian_filter</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
    <span class=n>out</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>

    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>is_wrapping</span><span class=p>:</span>
        <span class=k>if</span> <span class=n>ord_is_wrapped</span><span class=p>:</span>
            <span class=n>out</span> <span class=o>=</span> <span class=n>out</span><span class=o>.</span><span class=n>wrap</span><span class=p>()</span>

    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.standardize class="doc doc-heading"> <code class="highlight language-python"><span class=n>standardize</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Standardize the data to zero mean and unit standard deviation along the sample axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, modifies the data in place. If False (default), returns a new object.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The standardized signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>standardized</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>standardize</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>standardized</span><span class=o>.</span><span class=n>mean</span><span class=p>(),</span> <span class=n>standardized</span><span class=o>.</span><span class=n>std</span><span class=p>()</span>
<span class=go>(0.0, 1.0)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>727</span>
<span class=normal>728</span>
<span class=normal>729</span>
<span class=normal>730</span>
<span class=normal>731</span>
<span class=normal>732</span>
<span class=normal>733</span>
<span class=normal>734</span>
<span class=normal>735</span>
<span class=normal>736</span>
<span class=normal>737</span>
<span class=normal>738</span>
<span class=normal>739</span>
<span class=normal>740</span>
<span class=normal>741</span>
<span class=normal>742</span>
<span class=normal>743</span>
<span class=normal>744</span>
<span class=normal>745</span>
<span class=normal>746</span>
<span class=normal>747</span>
<span class=normal>748</span>
<span class=normal>749</span>
<span class=normal>750</span>
<span class=normal>751</span>
<span class=normal>752</span>
<span class=normal>753</span>
<span class=normal>754</span>
<span class=normal>755</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>standardize</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Standardize the data to zero mean and unit standard deviation along the sample axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    inplace : bool, optional</span>
<span class=sd>        If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The standardized signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; standardized = asa.standardize()</span>
<span class=sd>    &gt;&gt;&gt; standardized.mean(), standardized.std()</span>
<span class=sd>    (0.0, 1.0)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>-</span> <span class=n>out</span><span class=o>.</span><span class=n>mean</span><span class=p>())</span><span class=o>.</span><span class=n>T</span>
    <span class=n>std</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_1d</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>std</span><span class=p>())</span>
    <span class=n>std</span><span class=p>[</span><span class=n>std</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=o>.</span><span class=n>T</span> <span class=o>/</span> <span class=n>std</span><span class=p>)</span><span class=o>.</span><span class=n>T</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.std class="doc doc-heading"> <code class="highlight language-python"><span class=n>std</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Compute the standard deviation of the data along the specified axis.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>axis</code> </td> <td> <code><span title=int>int</span></code> </td> <td> <div class=doc-md-description> <p>Axis along which to compute the standard deviation (default is 1).</p> </div> </td> <td> <code>1</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>std</code></td> <td> <code><span title=numpy.ndarray>ndarray</span></code> </td> <td> <div class=doc-md-description> <p>Standard deviation values along the specified axis.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1915</span>
<span class=normal>1916</span>
<span class=normal>1917</span>
<span class=normal>1918</span>
<span class=normal>1919</span>
<span class=normal>1920</span>
<span class=normal>1921</span>
<span class=normal>1922</span>
<span class=normal>1923</span>
<span class=normal>1924</span>
<span class=normal>1925</span>
<span class=normal>1926</span>
<span class=normal>1927</span>
<span class=normal>1928</span>
<span class=normal>1929</span>
<span class=normal>1930</span>
<span class=normal>1931</span>
<span class=normal>1932</span>
<span class=normal>1933</span>
<span class=normal>1934</span>
<span class=normal>1935</span>
<span class=normal>1936</span>
<span class=normal>1937</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>std</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Compute the standard deviation of the data along the specified axis.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    axis : int, optional</span>
<span class=sd>        Axis along which to compute the standard deviation (default is 1).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    std : np.ndarray</span>
<span class=sd>        Standard deviation values along the specified axis.</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>try</span><span class=p>:</span>
        <span class=n>stds</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>nanstd</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=n>axis</span><span class=p>)</span><span class=o>.</span><span class=n>squeeze</span><span class=p>()</span>
        <span class=k>if</span> <span class=n>stds</span><span class=o>.</span><span class=n>size</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>return</span> <span class=n>stds</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
        <span class=k>return</span> <span class=n>stds</span>
    <span class=k>except</span> <span class=ne>IndexError</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>IndexError</span><span class=p>(</span>
            <span class=s2>&quot;Empty RegularlySampledAnalogSignalArray cannot calculate standard deviation&quot;</span>
        <span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.subsample class="doc doc-heading"> <code class="highlight language-python"><span class=n>subsample</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Subsamples a RegularlySampledAnalogSignalArray</p> <p>WARNING! Aliasing can occur! It is better to use downsample when lowering the sampling rate substantially.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Desired output sampling rate, in Hz</p> </div> </td> <td> <em>required</em> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>Copy of RegularlySampledAnalogSignalArray where data is only stored at the new subset of points.</p> </div> </td> </tr> </tbody> </table> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2349</span>
<span class=normal>2350</span>
<span class=normal>2351</span>
<span class=normal>2352</span>
<span class=normal>2353</span>
<span class=normal>2354</span>
<span class=normal>2355</span>
<span class=normal>2356</span>
<span class=normal>2357</span>
<span class=normal>2358</span>
<span class=normal>2359</span>
<span class=normal>2360</span>
<span class=normal>2361</span>
<span class=normal>2362</span>
<span class=normal>2363</span>
<span class=normal>2364</span>
<span class=normal>2365</span>
<span class=normal>2366</span>
<span class=normal>2367</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>subsample</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Subsamples a RegularlySampledAnalogSignalArray</span>

<span class=sd>    WARNING! Aliasing can occur! It is better to use downsample when</span>
<span class=sd>    lowering the sampling rate substantially.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Desired output sampling rate, in Hz</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        Copy of RegularlySampledAnalogSignalArray where data is only stored at the</span>
<span class=sd>        new subset of points.</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>simplify</span><span class=p>(</span><span class=n>ds</span><span class=o>=</span><span class=mi>1</span> <span class=o>/</span> <span class=n>fs</span><span class=p>)</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.trim class="doc doc-heading"> <code class="highlight language-python"><span class=n>trim</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Trim the signal to the specified start and stop times.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>start</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Start time.</p> </div> </td> <td> <em>required</em> </td> </tr> <tr class=doc-section-item> <td> <code>stop</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Stop time. If None, trims to the end.</p> </div> </td> <td> <code>None</code> </td> </tr> <tr class=doc-section-item> <td> <code>fs</code> </td> <td> <code><span title=float>float</span></code> </td> <td> <div class=doc-md-description> <p>Sampling frequency. If None, uses self.fs.</p> </div> </td> <td> <code>None</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>Trimmed signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>trimmed</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>trim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2011</span>
<span class=normal>2012</span>
<span class=normal>2013</span>
<span class=normal>2014</span>
<span class=normal>2015</span>
<span class=normal>2016</span>
<span class=normal>2017</span>
<span class=normal>2018</span>
<span class=normal>2019</span>
<span class=normal>2020</span>
<span class=normal>2021</span>
<span class=normal>2022</span>
<span class=normal>2023</span>
<span class=normal>2024</span>
<span class=normal>2025</span>
<span class=normal>2026</span>
<span class=normal>2027</span>
<span class=normal>2028</span>
<span class=normal>2029</span>
<span class=normal>2030</span>
<span class=normal>2031</span>
<span class=normal>2032</span>
<span class=normal>2033</span>
<span class=normal>2034</span>
<span class=normal>2035</span>
<span class=normal>2036</span>
<span class=normal>2037</span>
<span class=normal>2038</span>
<span class=normal>2039</span>
<span class=normal>2040</span>
<span class=normal>2041</span>
<span class=normal>2042</span>
<span class=normal>2043</span>
<span class=normal>2044</span>
<span class=normal>2045</span>
<span class=normal>2046</span>
<span class=normal>2047</span>
<span class=normal>2048</span>
<span class=normal>2049</span>
<span class=normal>2050</span>
<span class=normal>2051</span>
<span class=normal>2052</span>
<span class=normal>2053</span>
<span class=normal>2054</span>
<span class=normal>2055</span>
<span class=normal>2056</span>
<span class=normal>2057</span>
<span class=normal>2058</span>
<span class=normal>2059</span>
<span class=normal>2060</span>
<span class=normal>2061</span>
<span class=normal>2062</span>
<span class=normal>2063</span>
<span class=normal>2064</span>
<span class=normal>2065</span>
<span class=normal>2066</span>
<span class=normal>2067</span>
<span class=normal>2068</span>
<span class=normal>2069</span>
<span class=normal>2070</span>
<span class=normal>2071</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>trim</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>fs</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Trim the signal to the specified start and stop times.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    start : float</span>
<span class=sd>        Start time.</span>
<span class=sd>    stop : float, optional</span>
<span class=sd>        Stop time. If None, trims to the end.</span>
<span class=sd>    fs : float, optional</span>
<span class=sd>        Sampling frequency. If None, uses self.fs.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        Trimmed signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; trimmed = asa.trim(0, 10)</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;RegularlySampledAnalogSignalArray: Trim may not work!&quot;</span><span class=p>)</span>
    <span class=c1># TODO: do comprehensive input validation</span>
    <span class=k>if</span> <span class=n>stop</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>start</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start must be a scalar float&quot;</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start must be a scalar float&quot;</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>stop</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>stop</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>stop</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;stop must be a scalar float&quot;</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;stop must be a scalar float&quot;</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>  <span class=c1># start must have two elements</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                    <span class=s2>&quot;unsupported input to RegularlySampledAnalogSignalArray.trim()&quot;</span>
                <span class=p>)</span>
            <span class=n>stop</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=n>start</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>start</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>ndmin</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>start</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span> <span class=ow>or</span> <span class=nb>len</span><span class=p>(</span><span class=n>stop</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start and stop must be scalar floats&quot;</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;start and stop must be scalar floats&quot;</span><span class=p>)</span>

    <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=n>logging</span><span class=o>.</span><span class=n>CRITICAL</span><span class=p>)</span>
    <span class=n>interval</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_abscissa</span><span class=o>.</span><span class=n>support</span><span class=o>.</span><span class=n>intersect</span><span class=p>(</span>
        <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>support</span><span class=p>)([</span><span class=n>start</span><span class=p>,</span> <span class=n>stop</span><span class=p>],</span> <span class=n>fs</span><span class=o>=</span><span class=n>fs</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>interval</span><span class=o>.</span><span class=n>isempty</span><span class=p>:</span>
        <span class=n>analogsignalarray</span> <span class=o>=</span> <span class=bp>self</span><span class=p>[</span><span class=n>interval</span><span class=p>]</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>analogsignalarray</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)([],</span> <span class=n>empty</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
    <span class=n>logging</span><span class=o>.</span><span class=n>disable</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
    <span class=n>analogsignalarray</span><span class=o>.</span><span class=n>__renew__</span><span class=p>()</span>
    <span class=k>return</span> <span class=n>analogsignalarray</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.unwrap class="doc doc-heading"> <code class="highlight language-python"><span class=n>unwrap</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Unwrap the ordinate values by minimizing total displacement, useful for phase data.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, modifies the data in place. If False (default), returns a new object.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The unwrapped signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>unwrapped</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>unwrap</span><span class=p>()</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>829</span>
<span class=normal>830</span>
<span class=normal>831</span>
<span class=normal>832</span>
<span class=normal>833</span>
<span class=normal>834</span>
<span class=normal>835</span>
<span class=normal>836</span>
<span class=normal>837</span>
<span class=normal>838</span>
<span class=normal>839</span>
<span class=normal>840</span>
<span class=normal>841</span>
<span class=normal>842</span>
<span class=normal>843</span>
<span class=normal>844</span>
<span class=normal>845</span>
<span class=normal>846</span>
<span class=normal>847</span>
<span class=normal>848</span>
<span class=normal>849</span>
<span class=normal>850</span>
<span class=normal>851</span>
<span class=normal>852</span>
<span class=normal>853</span>
<span class=normal>854</span>
<span class=normal>855</span>
<span class=normal>856</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>unwrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Unwrap the ordinate values by minimizing total displacement, useful for phase data.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    inplace : bool, optional</span>
<span class=sd>        If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The unwrapped signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; unwrapped = asa.unwrap()</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

    <span class=n>out</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_unwrap</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=c1># out._is_wrapped = False</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.wrap class="doc doc-heading"> <code class="highlight language-python"><span class=n>wrap</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span></code> </h3> <div class="doc doc-contents "> <p>Wrap the ordinate values within the finite range defined by the ordinate's range.</p> <p><span class=doc-section-title>Parameters:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> <th>Default</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td> <code>inplace</code> </td> <td> <code><span title=bool>bool</span></code> </td> <td> <div class=doc-md-description> <p>If True, modifies the data in place. If False (default), returns a new object.</p> </div> </td> <td> <code>False</code> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>The wrapped signal array.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>wrapped</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>wrap</span><span class=p>()</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>786</span>
<span class=normal>787</span>
<span class=normal>788</span>
<span class=normal>789</span>
<span class=normal>790</span>
<span class=normal>791</span>
<span class=normal>792</span>
<span class=normal>793</span>
<span class=normal>794</span>
<span class=normal>795</span>
<span class=normal>796</span>
<span class=normal>797</span>
<span class=normal>798</span>
<span class=normal>799</span>
<span class=normal>800</span>
<span class=normal>801</span>
<span class=normal>802</span>
<span class=normal>803</span>
<span class=normal>804</span>
<span class=normal>805</span>
<span class=normal>806</span>
<span class=normal>807</span>
<span class=normal>808</span>
<span class=normal>809</span>
<span class=normal>810</span>
<span class=normal>811</span>
<span class=normal>812</span>
<span class=normal>813</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>wrap</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Wrap the ordinate values within the finite range defined by the ordinate&#39;s range.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    inplace : bool, optional</span>
<span class=sd>        If True, modifies the data in place. If False (default), returns a new object.</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        The wrapped signal array.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; wrapped = asa.wrap()</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=k>if</span> <span class=n>inplace</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>

    <span class=n>out</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>atleast_2d</span><span class=p>(</span>
        <span class=n>out</span><span class=o>.</span><span class=n>_wrap</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>min</span><span class=p>,</span> <span class=n>out</span><span class=o>.</span><span class=n>_ordinate</span><span class=o>.</span><span class=n>range</span><span class=o>.</span><span class=n>max</span><span class=p>)</span>
    <span class=p>)</span>
    <span class=c1># out._is_wrapped = True</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h3 id=nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray.zscore class="doc doc-heading"> <code class="highlight language-python"><span class=n>zscore</span><span class=p>()</span></code> </h3> <div class="doc doc-contents "> <p>Normalize each signal in the array using z-scores (zero mean, unit variance).</p> <p><span class=doc-section-title>Returns:</span></p> <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr class=doc-section-item> <td><code>out</code></td> <td> <code><a class="autorefs autorefs-internal" href=#nelpy.core._analogsignalarray.RegularlySampledAnalogSignalArray>RegularlySampledAnalogSignalArray</a></code> </td> <td> <div class=doc-md-description> <p>New object with z-scored data.</p> </div> </td> </tr> </tbody> </table> <p><span class=doc-section-title>Examples:</span></p> <div class=highlight><pre><span></span><code><span class=gp>&gt;&gt;&gt; </span><span class=n>zscored</span> <span class=o>=</span> <span class=n>asa</span><span class=o>.</span><span class=n>zscore</span><span class=p>()</span>
</code></pre></div> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1057</span>
<span class=normal>1058</span>
<span class=normal>1059</span>
<span class=normal>1060</span>
<span class=normal>1061</span>
<span class=normal>1062</span>
<span class=normal>1063</span>
<span class=normal>1064</span>
<span class=normal>1065</span>
<span class=normal>1066</span>
<span class=normal>1067</span>
<span class=normal>1068</span>
<span class=normal>1069</span>
<span class=normal>1070</span>
<span class=normal>1071</span>
<span class=normal>1072</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>zscore</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;</span>
<span class=sd>    Normalize each signal in the array using z-scores (zero mean, unit variance).</span>

<span class=sd>    Returns</span>
<span class=sd>    -------</span>
<span class=sd>    out : RegularlySampledAnalogSignalArray</span>
<span class=sd>        New object with z-scored data.</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    &gt;&gt;&gt; zscored = asa.zscore()</span>
<span class=sd>    &quot;&quot;&quot;</span>
    <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=n>out</span><span class=o>.</span><span class=n>_data</span> <span class=o>=</span> <span class=n>zscore</span><span class=p>(</span><span class=n>out</span><span class=o>.</span><span class=n>_data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>out</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> </div> </div> </div> <div class="doc doc-object doc-function"> <h2 id=nelpy.core._analogsignalarray.legacyASAkwargs class="doc doc-heading"> <code class="highlight language-python"><span class=n>legacyASAkwargs</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Provide support for legacy AnalogSignalArray kwargs.</p> <p>kwarg: time &lt;==&gt; timestamps &lt;==&gt; abscissa_vals kwarg: data &lt;==&gt; ydata</p> <p><span class=doc-section-title>Examples:</span></p> <p>asa = nel.AnalogSignalArray(time=..., data=...) asa = nel.AnalogSignalArray(timestamps=..., data=...) asa = nel.AnalogSignalArray(time=..., ydata=...) asa = nel.AnalogSignalArray(ydata=...) asa = nel.AnalogSignalArray(abscissa_vals=..., data=...)</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>2690</span>
<span class=normal>2691</span>
<span class=normal>2692</span>
<span class=normal>2693</span>
<span class=normal>2694</span>
<span class=normal>2695</span>
<span class=normal>2696</span>
<span class=normal>2697</span>
<span class=normal>2698</span>
<span class=normal>2699</span>
<span class=normal>2700</span>
<span class=normal>2701</span>
<span class=normal>2702</span>
<span class=normal>2703</span>
<span class=normal>2704</span>
<span class=normal>2705</span>
<span class=normal>2706</span>
<span class=normal>2707</span>
<span class=normal>2708</span>
<span class=normal>2709</span>
<span class=normal>2710</span>
<span class=normal>2711</span>
<span class=normal>2712</span>
<span class=normal>2713</span>
<span class=normal>2714</span>
<span class=normal>2715</span>
<span class=normal>2716</span>
<span class=normal>2717</span>
<span class=normal>2718</span>
<span class=normal>2719</span>
<span class=normal>2720</span>
<span class=normal>2721</span>
<span class=normal>2722</span>
<span class=normal>2723</span>
<span class=normal>2724</span>
<span class=normal>2725</span>
<span class=normal>2726</span>
<span class=normal>2727</span>
<span class=normal>2728</span>
<span class=normal>2729</span>
<span class=normal>2730</span>
<span class=normal>2731</span>
<span class=normal>2732</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>legacyASAkwargs</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Provide support for legacy AnalogSignalArray kwargs.</span>

<span class=sd>    kwarg: time &lt;==&gt; timestamps &lt;==&gt; abscissa_vals</span>
<span class=sd>    kwarg: data &lt;==&gt; ydata</span>

<span class=sd>    Examples</span>
<span class=sd>    --------</span>
<span class=sd>    asa = nel.AnalogSignalArray(time=..., data=...)</span>
<span class=sd>    asa = nel.AnalogSignalArray(timestamps=..., data=...)</span>
<span class=sd>    asa = nel.AnalogSignalArray(time=..., ydata=...)</span>
<span class=sd>    asa = nel.AnalogSignalArray(ydata=...)</span>
<span class=sd>    asa = nel.AnalogSignalArray(abscissa_vals=..., data=...)</span>
<span class=sd>    &quot;&quot;&quot;</span>

    <span class=k>def</span><span class=w> </span><span class=nf>only_one_of</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
        <span class=n>num_non_null_args</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=n>out</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=k>for</span> <span class=n>arg</span> <span class=ow>in</span> <span class=n>args</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>arg</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
                <span class=n>num_non_null_args</span> <span class=o>+=</span> <span class=mi>1</span>
                <span class=n>out</span> <span class=o>=</span> <span class=n>arg</span>
        <span class=k>if</span> <span class=n>num_non_null_args</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;multiple conflicting arguments received&quot;</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>out</span>

    <span class=c1># legacy ASA constructor support for backward compatibility</span>
    <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;abscissa_vals&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
    <span class=n>timestamps</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;timestamps&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
    <span class=n>time</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;time&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
    <span class=c1># only one of the above, else raise exception</span>
    <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>only_one_of</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>,</span> <span class=n>timestamps</span><span class=p>,</span> <span class=n>time</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>abscissa_vals</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;abscissa_vals&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>abscissa_vals</span>

    <span class=n>data</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;data&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
    <span class=n>ydata</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&quot;ydata&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
    <span class=c1># only one of the above, else raise exception</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>only_one_of</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>ydata</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>data</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;data&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span>

    <span class=k>return</span> <span class=n>kwargs</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> <div class="doc doc-object doc-function"> <h2 id=nelpy.core._analogsignalarray.rsasa_init_wrapper class="doc doc-heading"> <code class="highlight language-python"><span class=n>rsasa_init_wrapper</span><span class=p>(</span><span class=n>func</span><span class=p>)</span></code> </h2> <div class="doc doc-contents "> <p>Decorator that helps figure out abscissa_vals, fs, and sample numbers</p> <details class=quote> <summary>Source code in <code>nelpy/core/_analogsignalarray.py</code></summary> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>256</span>
<span class=normal>257</span>
<span class=normal>258</span>
<span class=normal>259</span>
<span class=normal>260</span>
<span class=normal>261</span>
<span class=normal>262</span>
<span class=normal>263</span>
<span class=normal>264</span>
<span class=normal>265</span>
<span class=normal>266</span>
<span class=normal>267</span>
<span class=normal>268</span>
<span class=normal>269</span>
<span class=normal>270</span>
<span class=normal>271</span>
<span class=normal>272</span>
<span class=normal>273</span>
<span class=normal>274</span>
<span class=normal>275</span>
<span class=normal>276</span>
<span class=normal>277</span>
<span class=normal>278</span>
<span class=normal>279</span>
<span class=normal>280</span>
<span class=normal>281</span>
<span class=normal>282</span>
<span class=normal>283</span>
<span class=normal>284</span>
<span class=normal>285</span>
<span class=normal>286</span>
<span class=normal>287</span>
<span class=normal>288</span>
<span class=normal>289</span>
<span class=normal>290</span>
<span class=normal>291</span>
<span class=normal>292</span>
<span class=normal>293</span>
<span class=normal>294</span>
<span class=normal>295</span>
<span class=normal>296</span>
<span class=normal>297</span>
<span class=normal>298</span>
<span class=normal>299</span>
<span class=normal>300</span>
<span class=normal>301</span>
<span class=normal>302</span>
<span class=normal>303</span>
<span class=normal>304</span>
<span class=normal>305</span>
<span class=normal>306</span>
<span class=normal>307</span>
<span class=normal>308</span>
<span class=normal>309</span>
<span class=normal>310</span>
<span class=normal>311</span>
<span class=normal>312</span>
<span class=normal>313</span>
<span class=normal>314</span>
<span class=normal>315</span>
<span class=normal>316</span>
<span class=normal>317</span>
<span class=normal>318</span>
<span class=normal>319</span>
<span class=normal>320</span>
<span class=normal>321</span>
<span class=normal>322</span>
<span class=normal>323</span>
<span class=normal>324</span>
<span class=normal>325</span>
<span class=normal>326</span>
<span class=normal>327</span>
<span class=normal>328</span>
<span class=normal>329</span>
<span class=normal>330</span>
<span class=normal>331</span>
<span class=normal>332</span>
<span class=normal>333</span>
<span class=normal>334</span>
<span class=normal>335</span>
<span class=normal>336</span>
<span class=normal>337</span>
<span class=normal>338</span>
<span class=normal>339</span>
<span class=normal>340</span>
<span class=normal>341</span>
<span class=normal>342</span>
<span class=normal>343</span>
<span class=normal>344</span>
<span class=normal>345</span>
<span class=normal>346</span>
<span class=normal>347</span>
<span class=normal>348</span>
<span class=normal>349</span>
<span class=normal>350</span>
<span class=normal>351</span>
<span class=normal>352</span>
<span class=normal>353</span>
<span class=normal>354</span>
<span class=normal>355</span>
<span class=normal>356</span>
<span class=normal>357</span>
<span class=normal>358</span>
<span class=normal>359</span>
<span class=normal>360</span>
<span class=normal>361</span>
<span class=normal>362</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>def</span><span class=w> </span><span class=nf>rsasa_init_wrapper</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
<span class=w>    </span><span class=sd>&quot;&quot;&quot;Decorator that helps figure out abscissa_vals, fs, and sample numbers&quot;&quot;&quot;</span>

    <span class=nd>@wraps</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
    <span class=k>def</span><span class=w> </span><span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;empty&quot;</span><span class=p>,</span> <span class=kc>False</span><span class=p>):</span>
            <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>return</span>

        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>args</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span>
                <span class=s2>&quot;__init__() takes 1 positional arguments but </span><span class=si>{}</span><span class=s2> positional arguments (and </span><span class=si>{}</span><span class=s2> keyword-only arguments) were given&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
                    <span class=nb>len</span><span class=p>(</span><span class=n>args</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>kwargs</span><span class=o>.</span><span class=n>items</span><span class=p>())</span>
                <span class=p>)</span>
            <span class=p>)</span>

        <span class=n>data</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;data&quot;</span><span class=p>,</span> <span class=p>[])</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>

        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;No ordinate data! Returning empty RegularlySampledAnalogSignalArray.&quot;</span>
            <span class=p>)</span>
            <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>return</span>

        <span class=c1># handle casting other nelpy objects to RegularlySampledAnalogSignalArrays:</span>
        <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>core</span><span class=o>.</span><span class=n>BinnedEventArray</span><span class=p>):</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>bin_centers</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;abscissa_vals&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>abscissa_vals</span>
            <span class=c1># support = data.support</span>
            <span class=c1># kwargs[&#39;support&#39;] = support</span>
            <span class=n>abscissa</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>_abscissa</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;abscissa&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>abscissa</span>
            <span class=n>fs</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>/</span> <span class=n>data</span><span class=o>.</span><span class=n>ds</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;fs&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>fs</span>
            <span class=k>if</span> <span class=nb>list</span><span class=p>(</span><span class=n>data</span><span class=o>.</span><span class=n>series_labels</span><span class=p>):</span>
                <span class=n>labels</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>series_labels</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>labels</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>series_ids</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;labels&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>labels</span>
            <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>data</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>float</span><span class=p>)</span>
        <span class=c1># elif isinstance(data, auxiliary.PositionArray):</span>
        <span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>RegularlySampledAnalogSignalArray</span><span class=p>):</span>
            <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;data&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span>
            <span class=n>func</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
            <span class=k>return</span>

        <span class=c1># check if single AnalogSignal or multiple AnalogSignals in array</span>
        <span class=c1># and standardize data to 2D</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>memmap</span><span class=p>):</span>  <span class=c1># memmap is a special case</span>
            <span class=k>if</span> <span class=ow>not</span> <span class=n>np</span><span class=o>.</span><span class=n>any</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>iscomplex</span><span class=p>(</span><span class=n>data</span><span class=p>)):</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>data</span><span class=o>.</span><span class=n>size</span><span class=p>:</span>
                <span class=n>data</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;Unsupported data type!&quot;</span><span class=p>)</span>

        <span class=n>re_estimate_fs</span> <span class=o>=</span> <span class=kc>False</span>
        <span class=n>no_fs</span> <span class=o>=</span> <span class=kc>True</span>
        <span class=n>fs</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;fs&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>fs</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>no_fs</span> <span class=o>=</span> <span class=kc>False</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>fs</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&quot;fs must be positive&quot;</span><span class=p>)</span>
            <span class=k>except</span> <span class=ne>TypeError</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s2>&quot;fs must be a scalar!&quot;</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>fs</span> <span class=o>=</span> <span class=mi>1</span>
            <span class=n>re_estimate_fs</span> <span class=o>=</span> <span class=kc>True</span>

        <span class=n>tdata</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;tdata&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>tdata</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                <span class=s2>&quot;&#39;tdata&#39; has been deprecated! Use &#39;abscissa_vals&#39; instead. &#39;tdata&#39; will be interpreted as &#39;abscissa_vals&#39; in seconds.&quot;</span>
            <span class=p>)</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>tdata</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>kwargs</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&quot;abscissa_vals&quot;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
        <span class=k>if</span> <span class=n>abscissa_vals</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>linspace</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>/</span> <span class=n>fs</span><span class=p>,</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
            <span class=n>abscissa_vals</span> <span class=o>=</span> <span class=n>abscissa_vals</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>re_estimate_fs</span><span class=p>:</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                    <span class=s2>&quot;fs was not specified, so we try to estimate it from the data...&quot;</span>
                <span class=p>)</span>
                <span class=n>fs</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>np</span><span class=o>.</span><span class=n>median</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>diff</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>))</span>
                <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span><span class=s2>&quot;fs was estimated to be </span><span class=si>{}</span><span class=s2> Hz&quot;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>fs</span><span class=p>))</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>no_fs</span><span class=p>:</span>
                    <span class=n>logging</span><span class=o>.</span><span class=n>warning</span><span class=p>(</span>
                        <span class=s2>&quot;fs was not specified, so we will assume default of 1 Hz...&quot;</span>
                    <span class=p>)</span>
                    <span class=n>fs</span> <span class=o>=</span> <span class=mi>1</span>

        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;fs&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>fs</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;data&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span>
        <span class=n>kwargs</span><span class=p>[</span><span class=s2>&quot;abscissa_vals&quot;</span><span class=p>]</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(</span><span class=n>abscissa_vals</span><span class=p>)</span>

        <span class=n>func</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=k>return</span>

    <span class=k>return</span> <span class=n>wrapper</span>
</code></pre></div></td></tr></table></div> </details> </div> </div> </div> </div> </div> </article> </div> <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../eventarray/ class="md-footer__link md-footer__link--prev" aria-label="Previous: EventArray"> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> Previous </span> <div class=md-ellipsis> EventArray </div> </div> </a> <a href=../intervalarray/ class="md-footer__link md-footer__link--next" aria-label="Next: IntervalArray"> <div class=md-footer__title> <span class=md-footer__direction> Next </span> <div class=md-ellipsis> IntervalArray </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-progress data-md-component=progress role=progressbar></div> <script id=__config type=application/json>{"base": "../../..", "features": ["announce.dismiss", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "content.tooltips", "content.tabs.link", "navigation.footer", "navigation.indexes", "navigation.instant.prefetch", "navigation.instant.preview", "navigation.instant.progress", "navigation.path", "navigation.sections", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.tracking", "search.highlight", "search.suggest", "toc.follow"], "search": "../../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.50899def.min.js></script> </body> </html>